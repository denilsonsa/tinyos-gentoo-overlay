diff -Nru gcc-3.3-orig/config.sub gcc-3.3/config.sub
--- gcc-3.3-orig/config.sub	2007-04-03 19:29:10.000000000 +0200
+++ gcc-3.3/config.sub	2003-06-03 15:32:25.000000000 +0200
@@ -228,7 +228,7 @@
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
 	| am33_2.0 \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr | avr32 | msp430 \
 	| bfin \
 	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx | dvp \
@@ -318,6 +318,7 @@
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| msp430-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
 	| clipper-* | craynv-* | cydra-* \
diff -Nru gcc-3.3-orig/gcc/config/msp430/libgcc.S gcc-3.3/gcc/config/msp430/libgcc.S
--- gcc-3.3-orig/gcc/config/msp430/libgcc.S	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/libgcc.S	2003-06-03 15:32:26.000000000 +0200
@@ -0,0 +1,1280 @@
+/* Low-level subroutines for Texas Instruments MSP430 MCU
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   Contributed by Dmitry Diky <diwil@mail.ru>
+
+   This file is part of GCC.
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+   
+   In addition to the permissions in the GNU General Public License, the
+   Free Software Foundation gives you unlimited permission to link the
+   compiled version of this file into combinations with other programs,
+   and to distribute those combinations without any restriction coming
+   from the use of this file.  (The General Public License restrictions
+   do apply in other respects; for example, they cover modification of
+   the file, and distribution when not linked into a combine
+   executable.)
+
+   GNU CC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+
+	.section .text.libgcc, "ax", @progbits
+
+#if defined (L_cmpdi2)
+	
+	.global	__cmpdi2
+	.func	__cmpdi2
+__cmpdi2:
+	sub     2(r1), r12	; a = a-b;
+	subc    4(r1), r13
+	subc    6(r1), r14
+	subc    8(r1), r15
+	
+	tst     r15		; c<0 ? return -1;
+	jge     .L2
+	
+	mov     #-1, r15	; yes, return -1
+	ret
+.L2:
+	bis     r12, r14	; check if zero
+	bis     r13, r15
+	bis     r14, r15
+	tst     r15
+	jeq     .L4		; test result or or'ing all nibbles
+	
+	mov     #1, r15		; no, positive, return 1
+	ret
+.L4:
+	mov     #0, r15		; return 0
+	ret
+.endfunc
+#endif
+
+#if defined (L_cmpsf2)
+	.global __cmpsf2
+	.func	__cmpsf2
+__cmpsf2:
+/* prologue: frame size = 0; addenum 0; alloca:0, varargs:0 , fpr:0*/
+.L__FrameSize___cmpsf2=0x0
+.L__FrameOffset___cmpsf2=0x4
+/* prologue end (size=2) */
+        cmp     r12, r14	;  11  cmpsi   [length = 3]
+        jne     .L2
+        cmp     r13, r15
+        jne     .L2      	;  12  bne     [length = 1]
+        mov     #llo(0), r15	;  15  *movhi3/7       [length = 1]
+	ret
+.L2:
+        tst     r15		;  20  tstsi   [length = 1]
+        jge     .L3		;  21  bge     [length = 1]
+        tst     r13		;  22  tstsi   [length = 1]
+        jge     .L3		;  23  bge     [length = 1]
+        xor     #lhi(-2147483648), r15		;  27  *xorsi3_3       [length = 2]
+        xor     #lhi(-2147483648), r13		;  29  *xorsi3_3       [length = 2]
+.L3:
+        sub     r14, r12	;  64  *subsi3_3       [length = 2]
+        subc    r15, r13
+        jge     .L4		;  33  bge     [length = 1]
+        mov     #llo(1), r15	;  36  *movhi3/7       [length = 1]
+	ret
+.L4:
+        mov     #llo(-1), r15	;  43  *movhi3/7       [length = 1]
+.L1:
+/* epilogue: frame size=0 */
+        ret
+/* epilogue end (size=3) */
+/* function __cmpsf2 size 25 (20) */
+
+.endfunc
+
+#endif
+
+
+
+/*******************************************************
+               Multiplication  8 x 8
+*******************************************************/
+#if defined (L_mulqi3)
+/* 
+	a = reg:qi 10	clobber
+	b = reg:qi 12	clobber
+	res = reg:qi 14
+*/
+
+	.global	__mulqi3
+	.func	__mulqi3
+__mulqi3:
+	clr	r14
+.L__mulqiloop:
+	tst.b	r10
+	jz	.L__mulqiexit
+	clrc
+	rrc.b	r12
+	jnc	+2
+	add.b	r10, r14
+	rla.b	r10
+	tst.b	r12
+	jne	.L__mulqiloop
+.L__mulqiexit:
+	ret
+	.endfunc
+#endif 	/* defined (L_mulqi3) */
+
+
+#if defined (L_mulqihi3)
+	.global	__mulqihi3
+	.func	__mulqihi3
+__mulqihi3:
+	sxt	r10
+	sxt	r12
+	br	#__mulhi3
+.endfunc
+#endif /* defined (L_mulqihi3) */
+
+#if defined (L_umulqihi3)
+	.global	__umulqihi3
+	.func	__umulqihi3
+__umulqihi3:
+	and.b	#-1, r10
+	and.b	#-1, r12
+	br	#__mulhi3
+	.endfunc
+#endif /* defined (L_umulqihi3) */
+
+/*******************************************************
+               Multiplication  16 x 16
+*******************************************************/
+#if defined (L_mulhi3)
+/* 
+	a = reg:hi 10	clobber
+	b = reg:hi 12	clobber
+	res = reg:hi 14
+*/
+
+	.global	__mulhi3
+	.func	__mulhi3
+__mulhi3:
+	clr	r14
+.L__mulhiloop:
+	tst	r10
+	jz	.L__mulhiexit
+	clrc
+	rrc	r12
+	jnc	+2
+	add	r10, r14
+	rla	r10
+	tst     r12
+	jne	.L__mulhiloop
+.L__mulhiexit:
+	ret
+	.endfunc
+#endif /* defined (L_mulhi3) */
+
+#if defined (L_mulhisi3)
+/* clobber r11, r13 */
+	.global	__mulhisi3
+	.func	__mulhisi3
+__mulhisi3:
+	br	#__mulsi3
+	.endfunc
+#endif /* defined (L_mulhisi3) */
+
+#if defined (L_umulhisi3)
+	.global	__umulhisi3
+	.func	__umulhisi3
+__umulhisi3:
+	br	#__mulsi3
+	.endfunc
+#endif /* defined (L_umulhisi3) */
+
+#if defined (L_mulsi3)
+/*******************************************************
+               Multiplication  32 x 32
+*******************************************************/
+/*
+res = a*b
+	a - reg:SI 10 clobber
+	b - reg:SI 12 clobber
+	res - reg: SI 14
+*/
+#ifndef MSP430_HAS_HW_MUL
+	.global	__mulsi3
+	.func	__mulsi3
+
+__mulsi3:
+	clr	r14
+	clr	r15
+	jmp	.L__mulsi3st
+.L__mulsi3loop:
+	clrc
+	rrc	r13		;	b >>= 1
+	rrc 	r12
+	jnc	+4		;	
+	add	r10, r14	;	res = res + a
+	addc	r11, r15
+	rla	r10
+	rlc	r11		;	a <<= 1
+.L__mulsi3st:
+	tst	r12		; if b ne 0 goto L__mulsi3loop
+	jne	.L__mulsi3loop
+	tst	r13
+	jne	.L__mulsi3loop
+	ret
+	.endfunc
+
+#else
+__MPY=0x130
+__MPYS=0x132
+__MAC=0x134
+__MACS=0x136
+__OP2=0x138
+__RESLO=0x13a
+__RESHI=0x13c
+__SUMEXT=0x13e
+
+	.global	__umulsi3hw
+	.func	__umulsi3hw
+__umulsi3hw:
+	mov	r12, &__MPY
+	mov	r10, &__OP2
+	mov	r12, &__MAC
+	mov	&__RESLO, r14
+	mov	&__RESHI, &__RESLO
+	mov	r11, &__OP2
+	mov	r13, &__MAC
+	mov	r10, &__OP2
+	mov	&__RESLO, r15
+	ret
+.endfunc
+
+/*
+	.global	__mulsi3hw
+	.func	__mulsi3hw
+__mulsi3hw:
+	mov	r12, &__MPYS
+	mov	r10, &__OP2
+	mov	r12, &__MACS
+	mov	&__RESLO, r14
+	mov	&__RESHI, &__RESLO
+	mov	r11, &__OP2
+	mov	r13, &__MACS
+	mov	r10, &__OP2
+	mov	&__RESLO, r15
+	ret
+.endfunc
+*/
+
+#endif
+
+#endif /* defined (L_mulsi3) */
+	
+/*******************************************************
+       Division 8 / 8 => (result + remainder)
+*******************************************************/
+
+#define r_rem   r14	/* remainder */
+#define r_arg1  r12	/* dividend, quotient */
+#define r_arg2  r10	/* divisor */
+#define r_cnt   r11	/* loop count */
+#define r_tmp	r13	/* save carry flag */
+
+
+#if defined (L_udivmodqi4)
+	.global	__udivmodqi4
+	.func	__udivmodqi4
+__udivmodqi4:
+	xor.b	r_rem, r_rem		; clear reminder and carry
+	mov.b	#9, r_cnt
+	jmp	.L__udivmodqi4_ep
+.L__udivmodqi4_loop:	
+	rrc	r_tmp			; restore carry bit
+	rlc.b	r_rem
+	cmp.b	r_arg2, r_rem
+	jlo	.L__udivmodqi4_ep
+	sub.b	r_arg2, r_rem		; FIXME: will this clobber carry ?
+.L__udivmodqi4_ep:
+	rlc.b	r_arg1			; shift divident
+	rlc	r_tmp			; save carry bit
+	dec.b	r_cnt			; this clobbers C bit.
+	jnz	.L__udivmodqi4_loop
+	ret
+	.endfunc
+#endif /* defined (L_udivmodqi4) */
+
+
+#if defined (L_divmodqi4)
+	.global	__divmodqi4
+	.func	__divmodqi4
+__divmodqi4:
+	clr	r_tmp
+	bit	#0x80, r_arg1		; save divident sign
+	jnc	.L__divmodqi4arg1pos
+	inv.b	r_arg1			; negate
+	inc.b	r_arg1
+	bis	#4, r_tmp
+
+.L__divmodqi4arg1pos:
+	bit	#0x80, r_arg2		; check divisor sign
+	jnc	.L__divmodqi4arg2pos
+	inv.b	r_arg2			; negate
+	inc.b	r_arg2
+	bis	#8, r_tmp
+
+.L__divmodqi4arg2pos:
+	
+	call	#__udivmodqi4		; do unsigned division
+	rrc	r_tmp			; restore carry and sign bits
+
+	bit	#4, r_tmp		; is divident < 0 ?
+	jnc	.L__divmodqi4rem	; no. skip
+	inv.b	r_rem			; negate remainder
+	inc.b	r_rem
+
+;;	bit	#8, r_tmp
+;;	jc	.L__divmodqi4end
+	inv.b	r_arg1			; negate quotient
+	inc.b	r_arg1
+
+.L__divmodqi4rem:
+	bit	#8, r_tmp
+	jnc	.L__divmodqi4end
+	inv.b	r_arg1
+	inc.b	r_arg1
+
+.L__divmodqi4end:
+	ret
+
+	.endfunc
+#endif /* defined (L_divmodqi4) */
+
+#undef r_rem
+#undef r_arg1
+#undef r_arg2
+#undef r_cnt 
+#undef r_tmp
+
+
+/*******************************************************
+       Division 16 / 16 => (result + remainder)
+*******************************************************/
+
+#define r_rem   r14	/* remainder */
+#define r_arg1  r12	/* dividend, quotient */
+#define r_arg2  r10	/* divisor */
+#define r_cnt   r11	/* loop count */
+#define r_tmp	r13
+
+
+#if defined (L_udivmodhi4)
+	.global	__udivmodhi4
+	.func	__udivmodhi4
+__udivmodhi4:
+	xor	r_rem, r_rem		; clear reminder and carry
+	mov	#17, r_cnt
+	jmp	.L__udivmodhi4_ep
+.L__udivmodhi4_loop:	
+	rrc	r_tmp			; restore carry bit
+	rlc	r_rem
+	cmp	r_arg2, r_rem
+	jlo	.L__udivmodhi4_ep
+	sub	r_arg2, r_rem
+.L__udivmodhi4_ep:
+	rlc	r_arg1
+	rlc	r_tmp			; save carry bit
+	dec	r_cnt			; this clobbers C bit.
+	jnz	.L__udivmodhi4_loop
+	ret
+	.endfunc
+#endif /* defined (L_udivmodhi4) */
+
+
+#if defined (L_divmodhi4)
+#define r_rem   r14     /* remainder */
+#define r_arg1  r12     /* dividend, quotient */
+#define r_arg2  r10     /* divisor */   
+#define r_cnt   r11     /* loop count */
+#define r_tmp   r13
+
+
+	.global	__divmodhi4
+	.func	__divmodhi4
+__divmodhi4:
+	clr	r_tmp			; clear reg is cheaper than clr 2 bits.
+	bit	#0x8000, r_arg1		; save divident sign
+	jnc	.L__divmodhi4arg1pos
+	inv	r_arg1			; negate
+	inc	r_arg1
+	bis	#4, r_tmp
+
+.L__divmodhi4arg1pos:
+	bit	#0x8000, r_arg2		; check divisor sign
+	jnc	.L__divmodhi4arg2pos
+	inv	r_arg2			; negate
+	inc	r_arg2
+	bis	#8, r_tmp
+
+.L__divmodhi4arg2pos:	
+	call	#__udivmodhi4		; do unsigned division
+	rrc	r_tmp			; restore carry and sign bits
+
+	bit	#4, r_tmp		; is divident < 0 ?
+	jnc	.L__divmodhi4rem	; no. skip
+	inv	r_rem			; negate remainder
+	inc	r_rem
+
+;;	bit	#8, r_tmp
+;;	jc	.L__divmodhi4end
+	inv	r_arg1			; negate quotient
+	inc	r_arg1
+
+.L__divmodhi4rem:
+	bit	#8, r_tmp
+	jnc	.L__divmodhi4end
+	inv	r_arg1
+	inc	r_arg1
+
+.L__divmodhi4end:
+	ret
+	.endfunc
+#endif /* defined (L_divmodhi4) */
+
+#undef r_rem
+#undef r_arg1
+#undef r_arg2
+#undef r_cnt 
+#undef r_tmp
+
+/*******************************************************
+       Division 32 / 32 => (result + remainder)
+*******************************************************/
+
+#if defined (L_udivmodsi4)
+
+#define r_remh  r15  
+#define r_reml  r14	/* remainder */
+#define r_arg1h r13
+#define r_arg1l r12	/* dividend, quotient */
+#define r_arg2h r11   
+#define r_arg2l r10	/* divisor */
+#define r_cnt   r9	/* loop count */
+#define r_tmp   r8
+
+	.global	__udivmodsi4
+	.func	__udivmodsi4
+__udivmodsi4:
+	xor	r_remh, r_remh		; clear reminder and carry
+	xor	r_reml, r_reml
+	mov	#33, r_cnt
+	jmp	.L__udivmodsi4_ep
+.L__udivmodsi4_loop:	
+	rrc	r_tmp			; restore carry bit
+	rlc	r_reml
+	rlc	r_remh
+
+	cmp	r_arg2h, r_remh		; is reminder < divisor ?
+	jlo	.L__udivmodsi4_ep	; yes, skip correction
+	jne	+4
+					; they equal. check LSBytes
+	cmp	r_arg2l, r_reml
+	jlo	.L__udivmodsi4_ep	; is reminder still < divisor ?
+
+	sub	r_arg2l, r_reml		; adjust reminder
+	subc	r_arg2h, r_remh
+
+.L__udivmodsi4_ep:
+	rlc	r_arg1l
+	rlc	r_arg1h
+	rlc	r_tmp
+	dec	r_cnt			; this clobbers C bit.
+	jnz	.L__udivmodsi4_loop
+	ret
+	.endfunc
+
+#undef r_remh
+#undef r_reml  
+#undef r_arg1h
+#undef r_arg1l
+#undef r_arg2h
+#undef r_arg2l
+
+#undef r_cnt
+#undef r_tmp
+
+#endif /* defined (L_udivmodsi4) */
+
+
+#if defined (L_divmodsi4)
+#define r_remh  r15  
+#define r_reml  r14     /* remainder */
+#define r_arg1h r13
+#define r_arg1l r12     /* dividend, quotient */
+#define r_arg2h r11   
+#define r_arg2l r10     /* divisor */   
+#define r_cnt   r9      /* loop count */
+#define r_tmp   r8
+
+	.global	__divmodsi4
+	.func	__divmodsi4
+__divmodsi4:
+	clr	r_tmp			; clear reg is cheaper than clr 2 bits.
+	bit	#0x8000, r_arg1h		; save divident sign
+	jz	.L__divmodsi4arg1pos
+	inv	r_arg1h			; negate
+	inv	r_arg1l
+	inc	r_arg1l
+	adc	r_arg1h
+	bis	#4, r_tmp
+
+.L__divmodsi4arg1pos:
+	bit	#0x8000, r_arg2h		; check divisor sign
+	jz	.L__divmodsi4arg2pos
+	inv	r_arg2h			; negate
+	inv	r_arg2l
+	inc	r_arg2l
+	adc	r_arg2h
+	bis	#8, r_tmp		; save divisor sign
+
+.L__divmodsi4arg2pos:
+	
+	call	#__udivmodsi4		; do unsigned division
+	rrc	r_tmp			; restore carry and sign bits
+
+	bit	#4, r_tmp		; is divident < 0 ?
+	jz	.L__divmodsi4rem	; no. skip
+	inv	r_reml			; negate remainder
+	inv	r_remh
+	inc	r_reml
+	adc	r_remh
+
+;;	bit	#8, r_tmp
+;;	jc	.L__divmodsi4end
+	inv	r_arg1l			; negate quotient
+	inv	r_arg1h
+	inc	r_arg1l
+	adc	r_arg1h
+
+.L__divmodsi4rem:
+	bit	#8, r_tmp
+	jz	.L__divmodsi4end
+	inv	r_arg1l
+	inv	r_arg1h
+	inc	r_arg1l
+	adc	r_arg1h
+
+.L__divmodsi4end:
+	ret
+	.endfunc
+
+#undef r_remh  
+#undef r_reml  
+#undef r_arg1h 
+#undef r_arg1l
+#undef r_arg2h
+#undef r_arg2l
+
+#undef r_cnt
+#undef r_tmp
+
+#endif /* defined (L_divmodsi4) */
+
+
+/******* CRT support functions *********/
+
+#if defined(L__stop_progExec__)
+
+	.section .fini9, "ax", @progbits
+	.global __stop_progExec__
+	.func  __stop_progExec__
+__stop_progExec__:
+	push 	r15
+
+	
+	.section .fini0, "ax", @progbits
+	
+	pop	r15
+__stop_progLoop:
+	bis	r15, r2
+	jmp	__stop_progLoop
+	.endfunc
+#endif	/* #if defined(L__stop_progExec__) */
+
+#if defined(L_reset_vector__)
+/*****************************************************************
+ * Initialize data: copy data from _etext to __data_start
+ * Can be overwritten.
+ *****************************************************************/
+	.extern _etext
+	.extern __data_start
+	.extern _edata
+	.extern __bss_start
+	.extern __bss_end
+	.extern __stack
+
+	.section .init0, "ax", @progbits
+
+	.global	_reset_vector__
+.func _reset_vector__
+_reset_vector__:
+	mov	#23168, &288	
+
+	.section .init2, "ax", @progbits
+	.global _copy_data_init__
+	.weak   _copy_data_init__
+
+_copy_data_init__:
+	mov     #_etext,	r15     ; load r15 with end of .text segment
+	mov     #__data_start,  r14     ; load ram start
+	mov     #_edata,	r13     ; end of data segment
+	cmp     r14,	    r13
+	jeq     .Lend_of_data_loop 
+.Lcopy_data_loop:  
+	/* copy data from @r15 to @r14 */
+	mov.b   @r15+,  @r14	    ; move one byte
+	inc     r14
+	cmp     r13,    r14	     ; check if end of data reached
+	jlo     .Lcopy_data_loop
+.Lend_of_data_loop:
+
+	.section .init4, "ax", @progbits
+	.global _clear_bss_init__
+	.weak   _clear_bss_init__
+	
+_clear_bss_init__:
+	mov     #__bss_start,   r15
+	mov     #__bss_end,     r13
+	cmp     r15,	    r13
+	jeq     .Lend_of_bss_loop  
+.Lzero_bss_loop:
+	clr.b   @r15
+	inc     r15 
+	cmp     r13,    r15     ; check if r15 < r13
+	jlo     .Lzero_bss_loop
+.Lend_of_bss_loop:
+	
+	.section .init9, "ax", @progbits
+	.global _end_of_init__
+	.weak   _end_of_init__
+	
+_end_of_init__:
+	br      #main	;	jump to main procedure
+.endfunc
+#endif
+
+
+#ifdef L_ctors
+	.section .init6,"ax",@progbits
+	.global __do_global_ctors
+	
+__do_global_ctors:
+	mov	#__stack, r1	; load stack... might be dangerous!!! 
+	mov	#__ctors_start,	r11
+	mov	#__ctors_end, r10
+	cmp	r10, r11
+	jeq	.L__ctors_end
+.L__ctors_loop:
+	call	@r11	; call constructor
+	incd	r11
+	cmp	r10, r11
+	jne	.L__ctors_loop
+.L__ctors_end:
+#endif
+
+#ifdef L_dtors
+	.section .fini6,"ax",@progbits
+	.global __do_global_dtors
+__do_global_dtors:
+	mov	#__dtors_start, r11
+	mov	#__dtors_end, r10
+	cmp	r10, r11
+	jeq	.L__dtors_end
+.L__dtors_loop:
+	call	@r11
+	incd	r11
+	cmp	r10, r11
+	jne	.L__dtors_loop
+.L__dtors_end:
+#endif
+
+			
+/********* PROLOGE / EPILOGUE aux routines ******************/
+#if defined (L__prologue_saver)
+	.global __prologue_saver
+	.func	__prologue_saver
+__prologue_saver:
+	mov	r4, 0(r1)
+	mov	r5, 2(r1)
+	mov	r6, 4(r1)
+	mov	r7, 6(r1)
+	mov	r8, 8(r1)
+	mov	r9, 10(r1)
+	mov	r10, 12(r1)
+	mov	r11, 14(r1)
+	br	r12	; now jump to the function body
+.endfunc
+
+#endif
+
+
+#if defined (L__epilogue_restorer)
+	.global __epilogue_restorer
+	.func	__epilogue_restorer
+__epilogue_restorer:
+	pop	r4
+	pop	r5
+	pop	r6
+	pop	r7
+	pop	r8
+	pop	r9
+	pop	r10
+	pop	r11
+	ret
+.endfunc
+
+#endif
+
+
+#if defined (L__epilogue_restorer_intr)
+	.global __epilogue_restorer_intr
+	.func	__epilogue_restorer_intr
+__epilogue_restorer_intr:
+	pop	r4
+	pop	r5
+	pop	r6
+	pop	r7
+	pop	r8
+	pop	r9
+	pop	r10
+	pop	r11
+	pop	r12
+	pop	r13
+	pop	r14
+	pop	r15
+	reti
+.endfunc
+
+#endif
+
+/******************************************
+ * quot/rem = 64/64
+ ******************************************/
+
+#if defined (L_udivmoddi3_parts) || defined (L_udivdi3) || defined (L_umoddi3) || defined (L_divdi3) || defined (L_moddi3)
+
+#define r_remhh  r11  	/* remainder */
+#define r_remhl  r10
+#define r_remlh	 r9
+#define r_remll	 r8
+
+#define r_arg1hh r15	/* dividend, quotient */
+#define r_arg1hl r14
+#define r_arg1lh r13
+#define r_arg1ll r12
+
+#define r_arg2hh r7	/* divisor */
+#define r_arg2hl r6
+#define r_arg2lh r5
+#define r_arg2ll r4
+
+#define r_cnt   2(r1)	/* loop count */
+#define r_tmp   0(r1)	/* we'll save carry and signs here */
+
+#endif
+
+
+#if defined (L_udivmoddi3_parts)
+
+	.global	__udivmoddi3_parts
+	.func	__udivmoddi3_parts
+__udivmoddi3_parts:
+	xor	r_remhh, r_remhh	; clear reminder and carry
+	xor	r_remhl, r_remhl 
+	xor	r_remlh, r_remlh
+	xor	r_remll, r_remll
+	
+	mov	#65, 2+r_cnt
+	jmp	.L__udivmoddi3_ep
+
+.L__udivmoddi3_loop:	
+	rrc	2+r_tmp			; restore carry bit
+	
+	rlc	r_remll			; shift carry in.
+	rlc	r_remlh
+	rlc	r_remhl
+	rlc	r_remhh
+	
+	cmp     r_arg2hh, r_remhh       ; is reminder < divisor ?
+	jlo     .L__udivmoddi3_ep       ; yes, skip correction
+	jne     .L_udmdcrt
+					; they equal. check LSBytes
+	cmp     r_arg2hl, r_remhl
+	jlo     .L__udivmoddi3_ep       ; is reminder still < divisor ?
+	jne     .L_udmdcrt
+
+	cmp     r_arg2lh, r_remlh
+	jlo     .L__udivmoddi3_ep
+	jne     .L_udmdcrt
+
+	cmp     r_arg2ll, r_remll
+	jlo     .L__udivmoddi3_ep
+	jne     .L_udmdcrt
+
+.L_udmdcrt:
+	sub	r_arg2ll, r_remll	; adjust reminder
+	subc	r_arg2lh, r_remlh
+	subc	r_arg2hl, r_remhl
+	subc	r_arg2hh, r_remhh
+	
+.L__udivmoddi3_ep:
+	rlc	r_arg1ll		; shift carry into arg1
+	rlc	r_arg1lh
+	rlc	r_arg1hl
+	rlc	r_arg1hh
+	
+	rlc	2+r_tmp			; save carry
+	dec	2+r_cnt			; this clobbers C bit.
+	jnz	.L__udivmoddi3_loop
+	
+	ret
+	.endfunc
+
+#endif /* defined (L_udivmoddi3_parts) */
+
+
+#if defined (L_udivdi3)
+
+;;  First arg will be in r15:r12 
+;;  next on stack
+;;	return in r15:r12
+;; rearrange them as:
+;;	r15:r12 	-> 	r_arg1hh:r_arg1ll
+;;	stack+8:stack+2 -> 	r_arg2hh:r_arg2ll
+
+	.global	__udivdi3
+	.func	__udivdi3
+__udivdi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	; 18 is a stack offset
+	mov	18+2(r1), r_arg2lh	; so move arg 2 in.
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+	
+	sub	#4, r1
+	call	#__udivmoddi3_parts
+	add	#4, r1
+	
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+#if defined (L_umoddi3)
+	.global	__umoddi3
+	.func	__umoddi3
+__umoddi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	
+	mov	18+2(r1), r_arg2lh
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+
+	sub	#4, r1
+	call    #__udivmoddi3_parts
+	add	#4, r1
+	
+	mov	r_remhh, r15	; move reminder to (reg:DI 12)
+	mov	r_remhl, r14
+	mov	r_remlh, r13
+	mov	r_remll, r12
+	
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+#if defined (L_divdi3)
+	.global	__divdi3
+	.func	__divdi3
+__divdi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	
+	mov	18+2(r1), r_arg2lh
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+	
+	sub	#4, r1
+	
+	clr	r_tmp
+	bit     #0x8000, r_arg1hh
+	jnc     .L__divdi3rempos
+	inv	r_arg1hh
+	inv     r_arg1hl
+	inv     r_arg1lh
+	inv     r_arg1ll
+	inc	r_arg1ll
+	adc     r_arg1lh
+	adc     r_arg1hl
+	adc     r_arg1hh
+	bis     #4, r_tmp
+	
+.L__divdi3rempos:
+	bit     #0x8000, r_arg2hh
+	jnc     .L__divdi3arg2pos	
+	inv	r_arg2hh
+	inv     r_arg2hl
+	inv     r_arg2lh
+	inv     r_arg2ll
+	inc	r_arg2ll
+	adc     r_arg2lh
+	adc     r_arg2hl
+	adc     r_arg2hh
+	xor     #4, r_tmp	; this is a trick - invert bit 4 =>
+				; do not perform double negation.
+.L__divdi3arg2pos:
+	call	#__udivmoddi3_parts
+	
+	rrc     r_tmp	; restore sign bits
+
+	bit     #4, r_tmp
+	jz      .L__divdi3end
+	inv     r_arg1hh
+	inv     r_arg1hl
+	inv     r_arg1lh
+	inv     r_arg1ll
+	inc	r_arg1ll
+	adc     r_arg1lh
+	adc     r_arg1hl
+	adc     r_arg1hh
+	
+.L__divdi3end:
+	add	#4, r1
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+#if defined (L_moddi3)
+	.global	__moddi3
+	.func	__moddi3
+__moddi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	
+	mov	18+2(r1), r_arg2lh
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+	
+	sub	#4, r1
+	
+	clr	r_tmp
+	bit     #0x8000, r_arg1hh
+	jnc     .L__moddi3rempos
+	inv	r_arg1hh
+	inv     r_arg1hl
+	inv     r_arg1lh
+	inv     r_arg1ll
+	inc	r_arg1ll
+	adc     r_arg1lh
+	adc     r_arg1hl
+	adc     r_arg1hh
+	bis     #4, r_tmp
+	
+.L__moddi3rempos:
+	bit     #0x8000, r_arg2hh
+	jnc     .L__moddi3arg2pos	
+	inv	r_arg2hh
+	inv     r_arg2hl
+	inv     r_arg2lh
+	inv     r_arg2ll
+	inc	r_arg2ll
+	adc     r_arg2lh
+	adc     r_arg2hl
+	adc     r_arg2hh
+
+.L__moddi3arg2pos:
+	call	#__udivmoddi3_parts
+	
+	rrc     r_tmp
+
+	bit     #4, r_tmp
+	jz      .L__moddi3rem
+	
+	inv	r_remhh
+	inv     r_remhl
+	inv     r_remlh
+	inv     r_remll
+	inc	r_remll
+	adc     r_remlh
+	adc     r_remhl
+	adc     r_remhh
+
+.L__moddi3rem:
+	mov	r_remhh, r15
+	mov	r_remhl, r14
+	mov	r_remlh, r13
+	mov	r_remll, r12
+
+	add	#4, r1
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+/**************************************************************
+ * Multiplication 64 = 64 x 64
+ **************************************************************/
+#if defined(L_muldi3) && !defined(MSP430_HAS_HW_MUL)
+
+#define r_reshh  r11  	/* res = arg1 * arg2 */
+#define r_reshl  r10
+#define r_reslh	 r9
+#define r_resll	 r8
+
+#define r_arg1hh r15	/* arg1 */
+#define r_arg1hl r14
+#define r_arg1lh r13
+#define r_arg1ll r12
+
+#define r_arg2hh r7	/* arg2 */
+#define r_arg2hl r6
+#define r_arg2lh r5
+#define r_arg2ll r4
+
+	.global	__muldi3
+	.func	__muldi3
+__muldi3:
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	r8
+	push	r9
+	push	r10
+	push	r11
+	
+	mov	18+0(r1), r_arg2ll	; 18 is a stack offset
+	mov	18+2(r1), r_arg2lh	; so move arg 2 in.
+	mov	18+4(r1), r_arg2hl
+	mov	18+6(r1), r_arg2hh
+
+	clr	r_reshh
+	clr	r_reshl
+	clr	r_reslh
+	clr	r_resll
+	
+.L_muldi3_loop:
+	clrc
+	rrc	r_arg2hh		; arg2 >>= 1 (shift LSB into carry)
+	rrc	r_arg2hl
+	rrc	r_arg2lh
+	rrc	r_arg2ll
+	
+	jnc	+8			; check if bit is set
+					; yes, it is.
+	add	r_arg1ll, r_resll	; res += arg1
+	addc	r_arg1lh, r_reslh
+	addc	r_arg1hl, r_reshl
+	addc	r_arg1hh, r_reshh
+	
+	rla	r_arg1ll		; arg1 <<= 1
+	rlc	r_arg1lh
+	rlc	r_arg1hl
+	rlc	r_arg1hh
+	
+	tst	r_arg2ll		; arg2 !=0 ?  loop again , exit otherwise.
+	jne	.L_muldi3_loop
+	tst	r_arg2lh
+	jne	.L_muldi3_loop
+	tst	r_arg2hl
+	jne	.L_muldi3_loop
+	tst	r_arg2hh
+	jne	.L_muldi3_loop
+
+	; move result to proper location
+	mov	r_resll, r12
+	mov	r_reslh, r13
+	mov	r_reshl, r14
+	mov	r_reshh, r15
+
+	pop	r11
+	pop	r10
+	pop	r9
+	pop	r8
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	ret
+	.endfunc
+#endif
+
+
+
+
+#if defined(L_muldi3) && defined(MSP430_HAS_HW_MUL)
+
+__MPY=0x130
+__MPYS=0x132
+__MAC=0x134
+__MACS=0x136
+__OP2=0x138
+__RESLO=0x13a
+__RESHI=0x13c
+__SUMEXT=0x13e
+
+#define r_reshh  r11    /* res = arg1 * arg2 */
+#define r_reshl  r10
+#define r_reslh  r9
+#define r_resll  r8
+
+#define r_arg1hh r15    /* arg1 */
+#define r_arg1hl r14
+#define r_arg1lh r13
+#define r_arg1ll r12
+
+#define r_arg2hh r7     /* arg2 */
+#define r_arg2hl r6
+#define r_arg2lh r5
+#define r_arg2ll r4
+
+          .global __muldi3
+          .func   __muldi3
+__muldi3:
+
+        push    r4
+        push    r5
+        push    r6
+        push    r7
+        push    r8
+        push    r9
+        push    r10
+        push    r11
+
+        mov     18+0(r1), r_arg2ll      ; 18 is a stack offset
+        mov     18+2(r1), r_arg2lh      ; so move arg 2 in.
+        mov     18+4(r1), r_arg2hl
+        mov     18+6(r1), r_arg2hh
+
+;;      r15:r14:r13:r12 * r7:r6:r5:r4 -> r11:r10:r9:r8
+;; actual code follows....
+
+        mov     r_arg1ll,&__MPY
+        mov     r_arg2ll,&__OP2           ;;                      LL1xLL2
+        mov     &__RESLO,r_resll
+        mov     &__RESHI,&__RESLO
+        mov     &__SUMEXT,&__RESHI
+
+        mov     r_arg1ll,&__MAC
+        mov     r_arg2lh,&__OP2           ;;                  LL1xLH2
+        mov     r_arg1lh,&__MAC
+        mov     r_arg2ll,&__OP2           ;;                  LH1xLL2
+        mov     &__RESLO,r_reslh
+        mov     &__RESHI,&__RESLO
+        mov     &__SUMEXT,&__RESHI
+
+        mov     r_arg2lh,&__OP2           ;;              LH1xLH2
+        mov     r_arg1ll,&__MAC
+        mov     r_arg2hl,&__OP2           ;;              LL1xHL2
+        mov     r_arg1hl,&__MAC
+        mov     r_arg2ll,&__OP2           ;;              HL1xLL2
+        mov     &__RESLO,r_reshl
+        mov     &__RESHI,&__RESLO
+
+        mov     r_arg2lh,&__OP2           ;;          HL1xLH2
+        mov     r_arg1ll,&__MAC
+        mov     r_arg2hh,&__OP2           ;;          LL1xHH2
+        mov     r_arg1lh,&__MAC
+        mov     r_arg2hl,&__OP2           ;;          LH1xHL2
+        mov     r_arg1hh,&__MAC
+        mov     r_arg2ll,&__OP2           ;;          HH1xLL2
+        mov     &__RESLO,r_reshh
+
+;; reload result
+        mov     r_resll, r12
+        mov     r_reslh, r13
+        mov     r_reshl, r14
+        mov     r_reshh, r15
+
+        pop     r11
+        pop     r10
+        pop     r9
+        pop     r8
+        pop     r7
+        pop     r6
+        pop     r5
+        pop     r4
+        ret
+.endfunc
+#endif
diff -Nru gcc-3.3-orig/gcc/config/msp430/msp430.c gcc-3.3/gcc/config/msp430/msp430.c
--- gcc-3.3-orig/gcc/config/msp430/msp430.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/msp430.c	2006-01-30 09:44:49.000000000 +0100
@@ -0,0 +1,9921 @@
+/* Subroutines for insn-output.c for Texas Instruments MSP430 MCU
+ Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+ Contributed by Dmitry Diky <diwil@mail.ru>
+ 
+ This file is part of GCC. 
+ GCC is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2, or (at your option)
+ any later version.
+ 
+ GNU CC is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with GCC; see the file COPYING.  If not, write to
+ the Free Software Foundation, 59 Temple Place - Suite 330,
+ Boston, MA 02111-1307, USA.  */
+
+#include "config.h"
+#include "system.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "reload.h"
+#include "tree.h"
+#include "output.h"
+#include "expr.h"
+#include "toplev.h"
+#include "obstack.h"
+#include "function.h"
+#include "recog.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+
+
+/* This holds the last insn address.  */
+static int last_insn_address = 0;
+
+/* Commands count in the compiled file */
+static int commands_in_file;
+
+/* Commands in the functions prologues in the compiled file */
+static int commands_in_prologues;
+
+/* Commands in the functions epilogues in the compiled file */
+static int commands_in_epilogues;
+
+/* Prologue/Epilogue size in words */
+static int prologue_size;
+static int epilogue_size;
+
+/* Size of all jump tables in the current function, in words.  */
+static int jump_tables_size;
+
+/* the size of the stack space freed during mdr pass */
+
+/* actual frame offset */
+static int msp430_current_frame_offset = 0;
+
+/* ret/reti issue indicator for _current_ function */
+static int return_issued = 0;
+
+/* registers used for incoming funct arguments */
+static char arg_register_used[16];
+
+/* max stack usage within a file */
+static int max_stack_usage;
+
+/* push helper */
+int self_push PARAMS ((rtx));
+
+
+/* aux functions */
+static int msp430_cc_source PARAMS ((rtx, enum rtx_code, rtx, rtx));
+static int msp430_func_num_saved_regs PARAMS ((void));
+static int hwmul_no_int_function_p PARAMS ((tree func));
+static int interrupt_function_p PARAMS ((tree func));
+static int msp430_naked_function_p PARAMS ((tree func));
+static int signal_function_p PARAMS ((tree func));
+static int wakeup_function_p PARAMS ((tree func));
+static int msp430_num_arg_regs PARAMS ((enum machine_mode mode, tree type));
+static int msp430_critical_function_p PARAMS ((tree func));
+static int msp430_reentrant_function_p PARAMS ((tree func));
+static int msp430_save_prologue_function_p PARAMS ((tree func));
+int msp430_address_costs PARAMS ((rtx));
+static bool msp430_rtx_costs PARAMS ((rtx, enum rtx_code, enum rtx_code, int *));
+static bool msp430_function_ok_for_sibcall PARAMS((tree, tree));
+
+static int msp430_saved_regs_frame PARAMS ((void));
+const char * msp430_emit_bltnoovfl PARAMS ((rtx *, int));
+
+
+
+static void   msp430_asm_out_ctor PARAMS ((rtx, int));
+static void   msp430_asm_out_dtor PARAMS ((rtx, int));
+
+static void msp430_function_prologue PARAMS ((FILE * file, HOST_WIDE_INT));
+static void msp430_function_epilogue PARAMS ((FILE * file, HOST_WIDE_INT));
+static void msp430_globalize_label PARAMS ((FILE *, const char *));
+
+void print_sub_operand PARAMS ((FILE *, rtx, int));
+
+const char *trim_array[] = { "llo", "lhi", "hlo", "hhi" };
+
+
+const char *msp430_init_stack = "__stack";
+const char *msp430_endup = "__stop_progExec__";
+
+int msp430_case_values_threshold = 30000;
+int msp430_has_hwmul = 0;
+
+struct rtx_def *msp430_compare_op0;
+struct rtx_def *msp430_compare_op1;
+
+
+const char *msp430_mcu_name = "msp430x110";
+
+enum msp430_arch
+{
+  MSP430_ISA_1 = 1,
+  MSP430_ISA_2 = 2,
+  MSP430_ISA_110 = 110,
+  MSP430_ISA_11 = 11,
+  MSP430_ISA_12 = 12,
+  MSP430_ISA_13 = 13,
+  MSP430_ISA_14 = 14,
+  MSP430_ISA_15 = 15,
+  MSP430_ISA_16 = 16,
+  MSP430_ISA_210 = 210,
+  MSP430_ISA_31 = 31,
+  MSP430_ISA_32 = 32,
+  MSP430_ISA_33 = 33,
+  MSP430_ISA_41 = 41,
+  MSP430_ISA_42 = 42,
+  MSP430_ISA_43 = 43,
+  MSP430_ISA_44 = 44
+};
+
+struct mcu_type_s
+{
+  const char *name;
+  enum msp430_arch arch;
+  int has_hwmul;
+};
+
+static struct mcu_type_s msp430_mcu_types[] = {
+  {"msp1", MSP430_ISA_1, 0},
+  {"msp2", MSP430_ISA_2, 1},
+
+  {"msp430x110", MSP430_ISA_11, 0},
+  {"msp430x112", MSP430_ISA_11, 0},
+
+  {"msp430x1101", MSP430_ISA_110, 0},
+  {"msp430x1111", MSP430_ISA_110, 0},
+  {"msp430x1121", MSP430_ISA_110, 0},
+  {"msp430x1122", MSP430_ISA_110, 0},
+  {"msp430x1132", MSP430_ISA_110, 0},
+
+  {"msp430x122", MSP430_ISA_12, 0},
+  {"msp430x123", MSP430_ISA_12, 0},
+  {"msp430x1222", MSP430_ISA_12, 0},
+  {"msp430x1232", MSP430_ISA_12, 0},
+
+  {"msp430x133", MSP430_ISA_13, 0},
+  {"msp430x135", MSP430_ISA_13, 0},
+  {"msp430x1331", MSP430_ISA_13, 0},
+  {"msp430x1351", MSP430_ISA_13, 0},
+
+  {"msp430x147", MSP430_ISA_14, 1},
+  {"msp430x148", MSP430_ISA_14, 1},
+  {"msp430x149", MSP430_ISA_14, 1},
+  {"msp430x1471", MSP430_ISA_14, 1},
+  {"msp430x1481", MSP430_ISA_14, 1},
+  {"msp430x1491", MSP430_ISA_14, 1},
+
+  {"msp430x155", MSP430_ISA_15, 0},
+  {"msp430x156", MSP430_ISA_15, 0},
+  {"msp430x157", MSP430_ISA_15, 0},
+
+  {"msp430x167", MSP430_ISA_16, 1},
+  {"msp430x168", MSP430_ISA_16, 1},
+  {"msp430x169", MSP430_ISA_16, 1},
+  {"msp430x1610", MSP430_ISA_16, 1},
+  {"msp430x1611", MSP430_ISA_16, 1},
+  {"msp430x1612", MSP430_ISA_16, 1},
+
+  {"msp430x2101", MSP430_ISA_210, 0},
+  {"msp430x2111", MSP430_ISA_210, 0},
+  {"msp430x2121", MSP430_ISA_210, 0},
+  {"msp430x2131", MSP430_ISA_210, 0},
+
+  {"msp430x311", MSP430_ISA_31, 0},
+  {"msp430x312", MSP430_ISA_31, 0},
+  {"msp430x313", MSP430_ISA_31, 0},
+  {"msp430x314", MSP430_ISA_31, 0},
+  {"msp430x315", MSP430_ISA_31, 0},
+
+  {"msp430x323", MSP430_ISA_32, 0},
+  {"msp430x325", MSP430_ISA_32, 0},
+
+  {"msp430x336", MSP430_ISA_33, 1},
+  {"msp430x337", MSP430_ISA_33, 1},
+
+  {"msp430x412", MSP430_ISA_41, 0},
+  {"msp430x413", MSP430_ISA_41, 0},
+  {"msp430x415", MSP430_ISA_41, 0},
+  {"msp430x417", MSP430_ISA_41, 0},
+
+  {"msp430x423", MSP430_ISA_42, 1},
+  {"msp430x425", MSP430_ISA_42, 1},
+  {"msp430x427", MSP430_ISA_42, 1},
+
+  {"msp430x4250", MSP430_ISA_42, 0},
+  {"msp430x4260", MSP430_ISA_42, 0},
+  {"msp430x4270", MSP430_ISA_42, 0},
+
+  {"msp430xE423", MSP430_ISA_42, 1},
+  {"msp430xE425", MSP430_ISA_42, 1},
+  {"msp430xE427", MSP430_ISA_42, 1},
+
+  {"msp430xW423", MSP430_ISA_42, 0},
+  {"msp430xW425", MSP430_ISA_42, 0},
+  {"msp430xW427", MSP430_ISA_42, 0},
+
+  {"msp430xG437", MSP430_ISA_43, 0},
+  {"msp430xG438", MSP430_ISA_43, 0},
+  {"msp430xG439", MSP430_ISA_43, 0},
+
+  {"msp430x435", MSP430_ISA_43, 0},
+  {"msp430x436", MSP430_ISA_43, 0},
+  {"msp430x437", MSP430_ISA_43, 0},
+
+  {"msp430x447", MSP430_ISA_44, 1},
+  {"msp430x448", MSP430_ISA_44, 1},
+  {"msp430x449", MSP430_ISA_44, 1},
+
+  {NULL, 0, 0}
+};
+
+
+
+const struct attribute_spec msp430_attribute_table[];
+static tree msp430_handle_fndecl_attribute
+PARAMS ((tree *, tree, tree, int, bool *));
+
+
+/* Initialize the GCC target structure.  */
+#undef TARGET_ASM_ALIGNED_HI_OP
+#define TARGET_ASM_ALIGNED_HI_OP "\t.word\t"
+
+#undef 	TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE msp430_function_prologue
+#undef 	TARGET_ASM_FUNCTION_EPILOGUE
+#define TARGET_ASM_FUNCTION_EPILOGUE msp430_function_epilogue
+#undef 	TARGET_ATTRIBUTE_TABLE
+#define TARGET_ATTRIBUTE_TABLE msp430_attribute_table
+#undef 	TARGET_SECTION_TYPE_FLAGS
+#define TARGET_SECTION_TYPE_FLAGS msp430_section_type_flags
+#undef 	TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS msp430_rtx_costs
+#undef	TARGET_ADDRESS_COST
+#define	TARGET_ADDRESS_COST msp430_address_costs
+#undef  TARGET_FUNCTION_OK_FOR_SIBCALL
+#define TARGET_FUNCTION_OK_FOR_SIBCALL msp430_function_ok_for_sibcall
+#undef  TARGET_ASM_GLOBALIZE_LABEL
+#define TARGET_ASM_GLOBALIZE_LABEL msp430_globalize_label
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+/****** ATTRIBUTES TO FUNCTION *************************************/
+const struct attribute_spec msp430_attribute_table[] = {
+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
+  {"reserve", 1, 1, false, false, false, msp430_handle_fndecl_attribute},
+  {"signal", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {"interrupt", 1, 1, true, false, false, msp430_handle_fndecl_attribute},
+  {"naked", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {"wakeup", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {"critical", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {"reentrant", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {"saveprologue", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {"hwmul_no_int", 0, 0, true, false, false, msp430_handle_fndecl_attribute},
+  {NULL, 0, 0, false, false, false, NULL}
+};
+
+unsigned int
+msp430_section_type_flags (decl, name, reloc)
+     tree decl;
+     const char *name;
+     int reloc;
+{
+  unsigned int flags = 0;
+
+  if (!strcmp (name, ".infomemnobits") || !strcmp (name, ".noinit"))
+    flags = SECTION_BSS;
+
+  flags |= default_section_type_flags (decl, name, reloc);
+  return flags;
+}
+
+/* Handle an attribute requiring a FUNCTION_DECL; arguments as in
+   struct attribute_spec.handler.  */
+static tree
+msp430_handle_fndecl_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning ("%s' attribute only applies to functions.",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+  return NULL_TREE;
+}
+
+
+static int
+msp430_naked_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("naked", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+static int
+msp430_save_prologue_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("saveprologue", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+static int
+interrupt_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("interrupt", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+static int
+msp430_critical_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("critical", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+
+}
+
+static int
+msp430_reentrant_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("reentrant", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+
+}
+
+static int
+hwmul_no_int_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("hwmul_no_int", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+int
+msp430_current_function_hwmul_no_int_function_p (void)
+{
+  int rval;
+  if (!current_function_decl)
+    return (TARGET_HWMUL_NO_INT);
+  rval = hwmul_no_int_function_p (current_function_decl);
+
+  return (TARGET_HWMUL_NO_INT || rval);
+}
+
+static int
+signal_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("signal", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+
+static int
+wakeup_function_p (func)
+     tree func;
+{
+  tree a;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    abort ();
+  a = lookup_attribute ("wakeup", DECL_ATTRIBUTES (func));
+  return a != NULL_TREE;
+}
+
+static bool
+msp430_function_ok_for_sibcall(decl, exp)
+tree decl ATTRIBUTE_UNUSED;
+tree exp ATTRIBUTE_UNUSED;
+{
+
+  int cfp = msp430_critical_function_p (current_function_decl);
+  int ree = msp430_reentrant_function_p (current_function_decl);
+  int nfp = msp430_naked_function_p (current_function_decl);
+  int ifp = interrupt_function_p (current_function_decl);
+  int wup = wakeup_function_p (current_function_decl);
+/*  int size = msp430_saved_regs_frame ();
+  int fs = get_frame_size ();
+*/
+  if(nfp || ifp || wup || ree || cfp )
+    return false;
+  return true;
+}
+
+
+void
+msp430_override_options ()
+{
+  const struct mcu_type_s *t;
+
+  for (t = msp430_mcu_types; t->name; t++)
+    {
+      if (strcmp (t->name, msp430_mcu_name) == 0)
+	break;
+    }
+
+  if (!t->name)
+    {
+      error ("MCU %s not supported", msp430_mcu_name);
+      fprintf (stderr, "Known MCU names:\n");
+      for (t = msp430_mcu_types; t->name; t++)
+	fprintf (stderr, "   %s\n", t->name);
+      abort ();
+      return;
+    }
+
+  msp430_has_hwmul = t->has_hwmul || TARGET_HW_MUL;
+
+  if (TARGET_NO_HW_MUL)
+    msp430_has_hwmul = 0;
+
+  msp430_case_values_threshold = 8;	/* ? or there is a better value ? */
+}
+
+rtx mpy_rtx, mpys_rtx, mac_rtx, macs_rtx, op2_rtx, reslo_rtx, reshi_rtx,
+    sumext_rtx, ressi_rtx;
+
+void
+msp430_init_once ()
+{
+/******************************
+
+  __MPY=0x130
+  __MPYS=0x132
+  __MAC=0x134
+  __MACS=0x136
+  __OP2=0x138
+  __RESLO=0x13a
+  __RESHI=0x13c
+  __SUMEXT=0x13e
+  __RESSI	<- not natural 
+ *****************************/
+
+  mpy_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__MPY"));
+  mpys_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__MPYS"));
+  mac_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__MAC"));
+  macs_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__MACS"));
+  op2_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__OP2"));
+  reslo_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__RESLO"));
+  reshi_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__RESHI"));
+  sumext_rtx = gen_rtx_MEM (HImode, gen_rtx_SYMBOL_REF (HImode, "__SUMEXT"));
+  ressi_rtx = gen_rtx_MEM (SImode, gen_rtx_SYMBOL_REF (SImode, "__RESLO"));
+  return;
+}
+
+static int reg_class_tab[16] = {
+  PC_REG, STACK_REGS, CG_REGS, CG_REGS,
+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+  GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+  GENERAL_REGS, GENERAL_REGS	/* r0 - r15 */
+};
+
+
+int
+msp430_regno_ok_for_base_p (r)
+     int r;
+{
+
+  if (r == 2)
+    return 0;
+  if (r == 3)
+    return 0;
+  if (r < FIRST_PSEUDO_REGISTER && r > 0)
+    return 1;
+  if (reg_renumber
+      && reg_renumber[r] < FIRST_PSEUDO_REGISTER
+      && reg_renumber[r] > 0 && reg_renumber[r] != 2 && reg_renumber[r] != 3)
+    return 1;
+
+  return 0;
+
+}
+
+enum reg_class
+msp430_regno_reg_class (r)
+     int r;
+{
+  if (r < FIRST_PSEUDO_REGISTER)
+    return reg_class_tab[r];
+
+  return NO_REGS;
+}
+
+enum reg_class
+msp430_reg_class_from_letter (c)
+     int c;
+{
+  switch (c)
+    {
+    case 'd':
+      return SP_REG;
+    default:
+      break;
+    }
+
+  return NO_REGS;
+}
+
+#define NOVECTOR	0xff
+
+void
+asm_declare_function_name (file, name, decl)
+     FILE *file;
+     const char *name;
+     tree decl ATTRIBUTE_UNUSED;
+{
+  int interrupt_func_p;
+  tree ss = 0;
+  int vector = -1;
+  int cfp = msp430_critical_function_p (current_function_decl);
+  int ree = msp430_reentrant_function_p (current_function_decl);
+
+  interrupt_func_p = interrupt_function_p (current_function_decl);
+
+  if (interrupt_func_p)
+    {
+      /*
+       * .global This_func1
+       * .set vector11, This_func1
+       * .type   This_func1,@function
+       *
+       */
+      ss = lookup_attribute ("interrupt",
+			     DECL_ATTRIBUTES (current_function_decl));
+      ss = TREE_VALUE (ss);
+      if (ss)
+	{
+	  ss = TREE_VALUE (ss);
+	  if (ss)
+	    vector = TREE_INT_CST_LOW (ss);
+
+	  if (vector != NOVECTOR)
+	    vector += 0xffe0ul;
+	}
+
+      if (vector == -1)
+	{
+	  warning ("No valid interrupt vector assigned to ISR `%s'.", name);
+	}
+
+      if ((vector < 0xffe0 || vector > 0xfffe || (vector & 1))
+	  && (vector != NOVECTOR && vector != -1))
+	{
+	  warning
+	      ("Interrupt vector 0x%x assigned to ISR `%s' is invalid.",
+	       vector, name);
+	}
+
+      if (vector != NOVECTOR)
+	{
+	  fprintf (file, ".global	vector_%04x\n", vector);
+	}
+      fprintf (file, "%s", TYPE_ASM_OP);
+      assemble_name (file, name);
+      putc (',', file);
+      fprintf (file, TYPE_OPERAND_FMT, "function");
+      putc ('\n', file);
+      fprintf (file, "/***********************\n");
+      fprintf (file, " * Interrupt %sRoutine `",
+	       (vector != NOVECTOR) ? "Service " : "Sub-");
+      assemble_name (file, name);
+      fprintf (file, "' at 0x%04x\n", vector);
+      fprintf (file, " ***********************/\n");
+
+      if (vector != NOVECTOR)
+	{
+	  fprintf (file, "vector_%04x:\n", vector);
+	}
+
+      ASM_OUTPUT_LABEL (file, name);
+    }
+  else
+    {
+      fprintf (file, "%s", TYPE_ASM_OP);
+      assemble_name (file, name);
+      putc (',', file);
+      fprintf (file, TYPE_OPERAND_FMT, "function");
+      putc ('\n', file);
+      fprintf (file, "/***********************\n");
+      fprintf (file, " * Function `");
+      assemble_name (file, name);
+      fprintf (file, "' %s\n ***********************/\n",
+	       cfp ? "(OS critical)" : ree ? "(reentrant)" : "");
+      ASM_OUTPUT_LABEL (file, name);
+    }
+}
+
+
+static int
+msp430_saved_regs_frame (void)
+{
+  int interrupt_func_p = interrupt_function_p (current_function_decl);
+  int cfp = msp430_critical_function_p (current_function_decl);
+  int leaf_func_p = leaf_function_p ();
+  int offset = interrupt_func_p ? 0 : (cfp ? 2 : 0);
+  int reg;
+
+  for (reg = 4; reg < 16; ++reg)
+    {
+      if ((!leaf_func_p && call_used_regs[reg] && (interrupt_func_p))
+	  || (regs_ever_live[reg]
+	      && (!call_used_regs[reg] || interrupt_func_p)))
+	{
+	  offset += 2;
+	}
+    }
+
+  return offset;
+}
+
+int
+msp430_empty_epilogue ()
+{
+  int cfp = msp430_critical_function_p (current_function_decl);
+  int ree = msp430_reentrant_function_p (current_function_decl);
+  int nfp = msp430_naked_function_p (current_function_decl);
+  int ifp = interrupt_function_p (current_function_decl);
+  int wup = wakeup_function_p (current_function_decl);
+  int size = msp430_saved_regs_frame ();
+  int fs = get_frame_size ();
+
+  if (cfp && ree)
+    ree = 0;
+
+  /* the following combination of attributes forces to issue
+     some commands in function epilogue */
+  if (ree
+      || nfp || fs || wup || MAIN_NAME_P (DECL_NAME (current_function_decl)))
+    return 0;
+
+  size += fs;
+
+  /* <= 2 necessary for first call */
+  if (size <= 2 && cfp)
+    return 2;
+  if (size == 0 && !cfp && !ifp)
+    return 1;
+  if (size == 0 && ifp)
+    return 2;
+
+  return 0;
+}
+
+/* Returns a number of pushed registers */
+static int
+msp430_func_num_saved_regs ()
+{
+  int i;
+  int saves = 0;
+  int interrupt_func_p = interrupt_function_p (current_function_decl);
+  int leaf_func_p = leaf_function_p ();
+
+  for (i = 4; i < 16; i++)
+    {
+      if ((regs_ever_live[i]
+	   && (!call_used_regs[i]
+	       || interrupt_func_p))
+	  || (!leaf_func_p && (call_used_regs[i] && interrupt_func_p)))
+	{
+	  saves += 1;
+	}
+    }
+
+  return saves;
+}
+
+
+/* Output function prologue */
+static void
+msp430_function_prologue (file, size)
+     FILE *file;
+     HOST_WIDE_INT size;
+{
+  int i;
+  int interrupt_func_p = interrupt_function_p (current_function_decl);
+  int signal_func_p = signal_function_p (current_function_decl);
+  int leaf_func_p = leaf_function_p ();
+  int main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));
+  int stack_reserve = 0;
+  tree ss = 0;
+  rtx x = DECL_RTL (current_function_decl);
+  const char *fnname = XSTR (XEXP (x, 0), 0);
+  int offset;
+  int cfp = msp430_critical_function_p (current_function_decl);
+  int ree = msp430_reentrant_function_p (current_function_decl);
+  int save_prologue_p =
+      msp430_save_prologue_function_p (current_function_decl);
+  int num_saved_regs;
+  int stack_usage = size + 2;
+
+  return_issued = 0;
+  last_insn_address = 0;
+  jump_tables_size = 0;
+  prologue_size = 0;
+
+  /* check attributes compatibility */
+
+  if ((cfp && ree) || (ree && interrupt_func_p))
+    {
+      warning ("attribute 'reentrant' ignored");
+      ree = 0;
+    }
+
+  if (cfp && interrupt_func_p)
+    {
+      warning ("attribute 'critical' ignored");
+      cfp = 0;
+    }
+
+  if (signal_func_p && !interrupt_func_p)
+    {
+      warning ("attribute 'signal' does not make sense.");
+      signal_func_p = 0;
+    }
+
+  /* chance to check stack usage */
+  if (stack_usage > max_stack_usage)
+    max_stack_usage = stack_usage;
+
+  /* naked function discards everything */
+  if (msp430_naked_function_p (current_function_decl))
+    {
+      fprintf (file, "/* prologue: naked */\n");
+      fprintf (file, ".L__FrameSize_%s=0x%x\n", fnname, size);
+      return;
+    }
+
+  ss = lookup_attribute ("reserve", DECL_ATTRIBUTES (current_function_decl));
+  if (ss)
+    {
+      ss = TREE_VALUE (ss);
+      if (ss)
+	{
+	  ss = TREE_VALUE (ss);
+	  if (ss)
+	    stack_reserve = TREE_INT_CST_LOW (ss);
+	  stack_reserve++;
+	  stack_reserve &= ~1;
+	}
+    }
+
+  fprintf (file, "/* prologue: frame size = %d */\n", size);
+  fprintf (file, ".L__FrameSize_%s=0x%x\n", fnname, size);
+
+
+  offset = initial_elimination_offset (0, 0) - 2;
+
+  msp430_current_frame_offset = offset;
+
+  fprintf (file, ".L__FrameOffset_%s=0x%x\n", fnname, offset);
+
+  if (signal_func_p && interrupt_func_p)
+    {
+      prologue_size += 1;
+      fprintf (file, "\teint\t; enable nested interrupt\n");
+    }
+
+  if (main_p)
+    {
+      if (TARGET_NSI)
+	{
+	  if (size || stack_reserve)
+	    fprintf (file, "\tsub\t#%d, r1\t", size + stack_reserve);
+	  if (frame_pointer_needed)
+	    {
+	      fprintf (file, "\tmov\tr1,r%d\n", FRAME_POINTER_REGNUM);
+	      prologue_size += 1;
+	    }
+
+	  if (size)
+	    prologue_size += 2;
+	  if (size == 1 || size == 2 || size == 4 || size == 8)
+	    prologue_size--;
+	}
+      else
+	{
+	  fprintf (file, "\tmov\t#(%s-%d), r1\n", msp430_init_stack,
+		   size + stack_reserve);
+
+	  if (frame_pointer_needed)
+	    {
+	      fprintf (file, "\tmov\tr1,r%d\n", FRAME_POINTER_REGNUM);
+	      prologue_size += 1;
+	    }
+	  prologue_size += 2;
+	}
+    }
+  else
+    {
+      /* Here, we've got a chance to jump to prologue saver */
+      num_saved_regs = msp430_func_num_saved_regs ();
+
+      if ((TARGET_SAVE_PROLOGUE || save_prologue_p)
+	  && !interrupt_func_p && !arg_register_used[12] && num_saved_regs > 4)
+	{
+	  fprintf (file, "\tsub\t#16, r1\n");
+	  fprintf (file, "\tmov\tr0, r12\n");
+	  fprintf (file, "\tadd\t#8, r12\n");
+	  fprintf (file, "\tbr\t#__prologue_saver+%d\n",
+		   (8 - num_saved_regs) * 4);
+	  stack_usage += 16;
+
+	  if (cfp && 8 - num_saved_regs)
+	    {
+	      int n = 16 - num_saved_regs * 2;
+	      fprintf (file, "\tadd\t#%d, r1\n", n);
+	      if (n != 0 && n != 1 && n != 2 && n != 4 && n != 8)
+		prologue_size += 1;
+	    }
+	  else
+	    size -= 16 - num_saved_regs * 2;
+
+	  prologue_size += 7;
+	}
+      else
+	{
+	  for (i = 15; i >= 4; i--)
+	    {
+	      if ((regs_ever_live[i]
+		   && (!call_used_regs[i]
+		       || interrupt_func_p))
+		  || (!leaf_func_p && (call_used_regs[i]
+				       && (interrupt_func_p))))
+		{
+		  fprintf (file, "\tpush\tr%d\n", i);
+		  stack_usage += 2;
+		  prologue_size += 1;
+		}
+	    }
+	}
+
+      if (!interrupt_func_p && cfp)
+	{
+	  prologue_size += 3;
+	  fprintf (file, "\tpush\tr2\n");
+	  stack_usage += 2;
+	  fprintf (file, "\tdint\n");
+	  if (!size)
+	    fprintf (file, "\tnop\n");
+	}
+
+      if (size)
+	{
+	  /* The next is a hack... I do not undestand why, but if there
+	     ARG_POINTER_REGNUM and FRAME/STACK are different, 
+	     the compiler fails to compute corresponding
+	     displacement */
+	  if (!optimize && !optimize_size
+	      && regs_ever_live[ARG_POINTER_REGNUM])
+	    {
+	      int o = initial_elimination_offset (0, 0) - size;
+	      fprintf (file, "\tmov\tr1, r%d\n", ARG_POINTER_REGNUM);
+	      fprintf (file, "\tadd\t#%d, r%d\n", o, ARG_POINTER_REGNUM);
+	      prologue_size += 2;
+	      if (o != 0 && o != 1 && o != 2 && o != 4 && o != 8)
+		prologue_size += 1;
+	    }
+
+	  /* adjust frame ptr... */
+	  if (size > 0)
+	    fprintf (file, "\tsub\t#%d, r1\n", (size + 1) & ~1);
+	  else
+	    {
+	      size = -size;
+	      fprintf (file, "\tadd\t#%d, r1\n", (size + 1) & ~1);
+	    }
+
+	  if (frame_pointer_needed)
+	    {
+	      fprintf (file, "\tmov\tr1,r%d\n", FRAME_POINTER_REGNUM);
+	      prologue_size += 1;
+	    }
+
+	  if (size == 1 || size == 2 || size == 4 || size == 8)
+	    prologue_size += 1;
+	  else
+	    prologue_size += 2;
+	}
+
+      /* disable interrupt for reentrant function */
+      if (!interrupt_func_p && ree)
+	{
+	  prologue_size += 1;
+	  fprintf (file, "\tdint\n");
+	}
+    }
+
+  if (interrupt_func_p)
+    stack_usage += 2;		/* status register slot */
+
+  if (stack_usage > max_stack_usage)
+    max_stack_usage = stack_usage;
+
+  fprintf (file, "/* prologue end (size=%d) */\n", prologue_size);
+}
+
+
+/* Output function epilogue */
+
+static void
+msp430_function_epilogue (file, size)
+     FILE *file;
+     HOST_WIDE_INT size;
+{
+  int i;
+  int interrupt_func_p = interrupt_function_p (current_function_decl);
+  int leaf_func_p = leaf_function_p ();
+  int main_p = MAIN_NAME_P (DECL_NAME (current_function_decl));
+  int wakeup_func_p = wakeup_function_p (current_function_decl);
+  int cfp = msp430_critical_function_p (current_function_decl);
+  int ree = msp430_reentrant_function_p (current_function_decl);
+  int save_prologue_p =
+      msp430_save_prologue_function_p (current_function_decl);
+  int still_return = 1;
+  int function_size;
+  rtx last = get_last_nonnote_insn ();
+
+
+  last_insn_address = 0;
+  function_size = jump_tables_size;
+  epilogue_size = 0;
+
+  if (last)
+    {
+      rtx first = get_first_nonnote_insn ();
+      function_size += (INSN_ADDRESSES (INSN_UID (last)) -
+			INSN_ADDRESSES (INSN_UID (first)));
+      function_size += get_attr_length (last);
+    }
+
+  if (msp430_naked_function_p (current_function_decl))
+    {
+      fprintf (file, "/* epilogue: naked */\n");
+      return;
+    }
+
+  if (msp430_empty_epilogue ())
+    {
+      if (!return_issued)
+	{
+	  fprintf (file, "\t%s\n", msp430_emit_return (NULL, NULL, NULL));
+	  epilogue_size++;
+	}
+      fprintf (file, "/* epilogue: not required */\n");
+      goto done_epilogue;
+    }
+
+  if ((cfp || interrupt_func_p) && ree)
+    ree = 0;
+  if (cfp && interrupt_func_p)
+    cfp = 0;
+
+  fprintf (file, "/* epilogue: frame size=%d */\n", size);
+
+  if (main_p)
+    {
+      if (size)
+	fprintf (file, "\tadd\t#%d, r1\n", (size + 1) & ~1);
+      fprintf (file, "\tbr\t#%s\n", msp430_endup);
+      epilogue_size += 4;
+      if (size == 1 || size == 2 || size == 4 || size == 8)
+	epilogue_size--;
+    }
+  else
+    {
+      if (ree)
+	{
+	  fprintf (file, "\teint\n");
+	  epilogue_size += 1;
+	}
+
+      if (size)
+	{
+	  fprintf (file, "\tadd\t#%d, r1\n", (size + 1) & ~1);
+	  if (size == 1 || size == 2 || size == 4 || size == 8)
+	    epilogue_size += 1;
+	  else
+	    epilogue_size += 2;
+	}
+
+      if (!interrupt_func_p && cfp)
+	{
+	  epilogue_size += 1;
+	  if (msp430_saved_regs_frame () == 2)
+	    {
+	      fprintf (file, "\treti\n");
+	      still_return = 0;
+	    }
+	  else
+	    fprintf (file, "\tpop\tr2\n");
+	}
+
+      if ((TARGET_SAVE_PROLOGUE || save_prologue_p)
+	  && !interrupt_func_p && msp430_func_num_saved_regs () > 2)
+	{
+	  fprintf (file, "\tbr\t#__epilogue_restorer+%d\n",
+		   (8 - msp430_func_num_saved_regs ()) * 2);
+	  epilogue_size += 2;
+	}
+      else if ((TARGET_SAVE_PROLOGUE || save_prologue_p) && interrupt_func_p)
+	{
+	  fprintf (file, "\tbr\t#__epilogue_restorer_intr+%d\n",
+		   (12 - msp430_func_num_saved_regs ()) * 2);
+	}
+      else
+	{
+	  for (i = 4; i < 16; i++)
+	    {
+	      if ((regs_ever_live[i]
+		   && (!call_used_regs[i]
+		       || interrupt_func_p))
+		  || (!leaf_func_p && (call_used_regs[i] && interrupt_func_p)))
+		{
+		  fprintf (file, "\tpop\tr%d\n", i);
+		  epilogue_size += 1;
+		}
+	    }
+
+	  if (interrupt_func_p)
+	    {
+	      if (wakeup_func_p)
+		{
+		  fprintf (file, "\tbic\t#0xf0,0(r1)\n");
+		  epilogue_size += 3;
+		}
+
+	      fprintf (file, "\treti\n");
+	      epilogue_size += 1;
+	    }
+	  else
+	    {
+	      if (still_return)
+		fprintf (file, "\tret\n");
+	      epilogue_size += 1;
+	    }
+	}
+    }
+
+  fprintf (file, "/* epilogue end (size=%d) */\n", epilogue_size);
+done_epilogue:
+  fprintf (file, "/* function %s size %d (%d) */\n", current_function_name,
+	   prologue_size + function_size + epilogue_size, function_size);
+
+  commands_in_file += prologue_size + function_size + epilogue_size;
+  commands_in_prologues += prologue_size;
+  commands_in_epilogues += epilogue_size;
+}
+
+
+/* Attempts to replace X with a valid
+   memory address for an operand of mode MODE  */
+/* FIXME: broken call */
+rtx
+legitimize_address (x, oldx, mode)
+     rtx x;
+     rtx oldx ATTRIBUTE_UNUSED;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  /*    if (GET_CODE (oldx) == MEM
+     && GET_CODE (XEXP(oldx,0)) == PLUS
+     && GET_CODE (XEXP(XEXP(oldx,0),0)) == MEM)
+     {
+     x = force_operand (oldx,0);
+     return x;
+     }
+
+     return oldx;
+   */
+  return x;
+}
+
+int
+legitimate_address_p (mode, operand, strict)
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+     rtx operand;
+     int strict;
+{
+  rtx xfoob, x = operand;
+
+  xfoob = XEXP (operand, 0);
+
+  /* accept @Rn (Rn points to operand address ) */
+  if (GET_CODE (operand) == REG
+      && (strict ? REG_OK_FOR_BASE_STRICT_P (x)
+	  : REG_OK_FOR_BASE_NOSTRICT_P (x)))
+    goto granted;
+
+  /* accept address */
+  if (CONSTANT_P (operand))
+    goto granted;
+
+  /* accept X(Rn) Rn + X points to operand address */
+  if (GET_CODE (operand) == PLUS
+      && GET_CODE (XEXP (operand, 0)) == REG
+      && CONSTANT_P (XEXP (operand, 1))
+      && (strict ? (REG_OK_FOR_BASE_STRICT_P (xfoob))
+	  : (REG_OK_FOR_BASE_NOSTRICT_P (xfoob))))
+    goto granted;
+
+  if (TARGET_ALL_DEBUG)
+    fprintf (stderr, "Address Failed\n");
+  return 0;
+
+granted:
+  if (TARGET_ALL_DEBUG)
+    fprintf (stderr, "Address granted\n");
+  return 1;
+}
+
+
+void
+print_operand_address (file, addr)
+     FILE *file;
+     rtx addr;
+{
+  /* hopefully will be never entered. */
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      fprintf (file, "r%d", REGNO (addr));
+      return;
+    case POST_INC:
+      fprintf (file, "@r%d+", REGNO (XEXP(addr,0)));
+      return;
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST:
+      fprintf (file, "#");
+      break;
+    case CODE_LABEL:
+      break;
+    default:
+      abort ();
+      fprintf (file, "&");
+    }
+  output_addr_const (file, addr);
+}
+
+
+void
+print_sub_operand (file, x, code)
+     FILE *file;
+     rtx x;
+     int code;
+{
+
+  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)
+    {
+      output_addr_const (file, x);
+      return;
+    }
+  else if (GET_CODE (x) == CONST)
+    {
+      print_sub_operand (file, XEXP (x, 0), code);
+      return;
+    }
+  else if (GET_CODE (x) == PLUS)
+    {
+      print_sub_operand (file, XEXP (x, 0), code);
+      fprintf (file, "+");
+      print_sub_operand (file, XEXP (x, 1), code);
+      return;
+    }
+  else if (GET_CODE (x) == CONST_INT)
+    {
+      fprintf (file, "%d", INTVAL (x));
+      return;
+    }
+  else
+    abort ();
+}
+
+void
+print_operand (file, x, code)
+     FILE *file;
+     rtx x;
+     int code;
+{
+  int shift = 0;
+  int ml = GET_MODE_SIZE (x->mode);
+  int source_reg = 0;
+
+
+  if (ml > 1)
+    ml = 2;
+
+  if (code >= 'A' && code <= 'D')
+    shift = code - 'A';
+
+  if (code >= 'E' && code <= 'H')
+    {
+      shift = code - 'E';
+      source_reg = 1;
+    }
+
+  if (code >= 'I' && code <= 'L')
+    {
+      ml = 1;
+      shift = code - 'I';
+    }
+
+  if (GET_CODE (x) == PLUS)
+    {
+      fprintf (file, "add%s", shift ? "c" : "");
+    }
+  else if (GET_CODE (x) == MINUS)
+    {
+      fprintf (file, "sub%s", shift ? "c" : "");
+    }
+  else if (GET_CODE (x) == AND)
+    {
+      fprintf (file, "and");
+    }
+  else if (GET_CODE (x) == IOR)
+    {
+      fprintf (file, "bis");
+    }
+  else if (GET_CODE (x) == XOR)
+    {
+      fprintf (file, "xor");
+    }
+  else if (REG_P (x))
+    {
+      fprintf (file, reg_names[true_regnum (x) + shift]);
+    }
+  else if (GET_CODE (x) == CONST_INT)
+    {
+      if (code != 'F')
+	fprintf (file, "#%s(%d)", trim_array[shift], INTVAL (x));
+      else
+	fprintf (file, "%d", INTVAL (x));
+    }
+  else if (GET_CODE (x) == MEM)
+    {
+      rtx addr = XEXP (x, 0);
+
+      if (GET_CODE (addr) == POST_INC)
+	{
+	  fprintf (file, "@r%d+", REGNO (XEXP(addr,0)));
+	}
+      else if (GET_CODE (addr) == REG)
+	{			/* for X(Rn) */
+	  if (shift || !source_reg)
+	    {
+	      if (shift)
+		fprintf (file, "%d(r%d)", shift * ml, REGNO (addr));
+	      else
+		fprintf (file, "@r%d", REGNO (addr));
+	    }
+	  else if (source_reg)
+	    {
+	      fprintf (file, "r%d", REGNO (addr) + shift);
+	    }
+	  else
+	    {
+	      fprintf (file, "@r%d", REGNO (addr));
+	    }
+	}
+      else if (GET_CODE (addr) == SYMBOL_REF)
+	{
+	  fprintf (file, "&");
+	  output_addr_const (file, addr);
+	  if (shift)
+	    fprintf (file, "+%d", shift * ml);
+	}
+      else if (GET_CODE (addr) == CONST || GET_CODE (addr) == CONST_INT)
+	{
+	  fputc ('&', file);
+	  output_addr_const (file, addr);
+	  if (shift)
+	    fprintf (file, "+%d", shift * ml);
+	}
+      else if (GET_CODE (addr) == PLUS)
+	{
+
+	  print_sub_operand (file, XEXP (addr, 1), code);
+
+	  if (shift)
+	    fprintf (file, "+%d", shift * ml);
+
+	  if (REG_P (XEXP (addr, 0)))
+	    fprintf (file, "(r%d)", REGNO (XEXP (addr, 0)));
+	  else
+	    abort ();
+	}
+      else if (GET_CODE (addr) == MEM)
+	{
+	  fprintf (file, "@(Invalid addressing mode)");
+	  print_operand (file, addr, code);
+	}
+      else
+	{
+	  fprintf (file, "Unknown operand. Please check.");
+	}
+    }
+  else if (GET_CODE (x) == SYMBOL_REF)
+    {
+      fprintf (file, "#");
+      output_addr_const (file, x);
+      if (shift)
+	fprintf (file, "+%d", shift * ml);
+    }
+  else if (GET_CODE (x) == CONST_DOUBLE)
+    {
+      if (GET_MODE (x) == VOIDmode)	/* FIXME: may be long long?? */
+	{
+	  if (shift < 2)
+	    fprintf (file, "#%s(%d)", trim_array[shift],
+		     CONST_DOUBLE_LOW (x));
+	  else
+	    fprintf (file, "#%s(%d)", trim_array[shift - 2],
+		     CONST_DOUBLE_HIGH (x));
+	}
+      else if (GET_MODE (x) == SFmode || GET_MODE (x) == SImode)
+	{
+	  long val;
+	  REAL_VALUE_TYPE rv;
+	  REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+	  REAL_VALUE_TO_TARGET_SINGLE (rv, val);
+	  asm_fprintf (file, "#%s(0x%lx)", trim_array[shift], val);
+	}
+      else
+	{
+	  fatal_insn ("Internal compiler bug. Unknown mode:", x);
+	}
+    }
+  else
+    print_operand_address (file, x);
+}
+
+/* mode for branch instruction */
+int
+msp430_jump_dist (x, insn)
+     rtx x;
+     rtx insn;
+{
+  if(insn_addresses_)
+  {
+  int dest_addr = INSN_ADDRESSES (INSN_UID (GET_CODE (x) == LABEL_REF
+					    ? XEXP (x, 0) : x));
+  int cur_addr = INSN_ADDRESSES (INSN_UID (insn));
+  int jump_distance = dest_addr - cur_addr;
+
+  return jump_distance;
+  }
+  else
+    return 1024;
+}
+
+
+
+#define FIRST_CUM_REG 16
+static CUMULATIVE_ARGS *cum_incoming = 0;
+
+/* Initializing the variable cum for the state at the beginning
+   of the argument list.  */
+void
+init_cumulative_args (cum, fntype, libname, indirect)
+     CUMULATIVE_ARGS *cum;
+     tree fntype;
+     rtx libname;
+     int indirect ATTRIBUTE_UNUSED;
+{
+  cum->nregs = 4;
+  cum->regno = FIRST_CUM_REG;
+  if (!libname)
+    {
+      int stdarg = (TYPE_ARG_TYPES (fntype) != 0
+		    && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+			!= void_type_node));
+      if (stdarg)
+	cum->nregs = 0;
+    }
+}
+
+/* the same in scope of the cum.args., buf usefull for a
+   function call */
+void
+init_cumulative_incoming_args (cum, fntype, libname)
+     CUMULATIVE_ARGS *cum;
+     tree fntype;
+     rtx libname;
+{
+  int i;
+  cum->nregs = 4;
+  cum->regno = FIRST_CUM_REG;
+  if (!libname)
+    {
+      int stdarg = (TYPE_ARG_TYPES (fntype) != 0
+		    && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))
+			!= void_type_node));
+      if (stdarg)
+	cum->nregs = 0;
+    }
+
+  for (i = 0; i < 16; i++)
+    arg_register_used[i] = 0;
+
+  cum_incoming = cum;
+}
+
+rtx
+msp430_libcall_value (mode)
+     enum machine_mode mode;
+{
+  int offs = GET_MODE_SIZE (mode);
+  offs >>= 1;
+  if (offs < 1)
+    offs = 1;
+  return gen_rtx (REG, mode, (RET_REGISTER + 1 - offs));
+}
+
+rtx
+msp430_function_value (type, func)
+     tree type;
+     tree func ATTRIBUTE_UNUSED;
+{
+  int offs;
+  if (TYPE_MODE (type) != BLKmode)
+    return msp430_libcall_value (TYPE_MODE (type));
+
+  offs = int_size_in_bytes (type);
+  offs >>= 1;
+  if (offs < 1)
+    offs = 1;
+  if (offs > 1 && offs < (GET_MODE_SIZE (SImode) >> 1))
+    offs = GET_MODE_SIZE (SImode) >> 1;
+  else if (offs > (GET_MODE_SIZE (SImode) >> 1)
+	   && offs < (GET_MODE_SIZE (DImode) >> 1))
+    offs = GET_MODE_SIZE (DImode) >> 1;
+
+  return gen_rtx (REG, BLKmode, (RET_REGISTER + 1 - offs));
+}
+
+/* Returns the number of registers to allocate for a function argument.  */
+static int
+msp430_num_arg_regs (mode, type)
+     enum machine_mode mode;
+     tree type;
+{
+  int size;
+
+  if (mode == BLKmode)
+    size = int_size_in_bytes (type);
+  else
+    size = GET_MODE_SIZE (mode);
+
+  if (size < 2)
+    size = 2;
+
+  /* we do not care if argument is passed in odd register
+     so, do not align the size ...
+     BUT!!! even char argument passed in 16 bit register
+     so, align the size */
+  return ((size + 1) & ~1) >> 1;
+}
+
+/* Controls whether a function argument is passed
+   in a register, and which register. */
+rtx
+function_arg (cum, mode, type, named)
+     CUMULATIVE_ARGS *cum;
+     enum machine_mode mode;
+     tree type;
+     int named ATTRIBUTE_UNUSED;
+{
+  int regs = msp430_num_arg_regs (mode, type);
+
+  if (cum->nregs && regs <= cum->nregs)
+    {
+      int regnum = cum->regno - regs;
+
+      if (cum == cum_incoming)
+	{
+	  arg_register_used[regnum] = 1;
+	  if (regs >= 2)
+	    arg_register_used[regnum + 1] = 1;
+	  if (regs >= 3)
+	    arg_register_used[regnum + 2] = 1;
+	  if (regs >= 4)
+	    arg_register_used[regnum + 3] = 1;
+	}
+
+      return gen_rtx (REG, mode, regnum);
+    }
+  return NULL_RTX;
+}
+
+
+/* Update the summarizer variable CUM to advance past an argument
+   in the argument list.  */
+void
+function_arg_advance (cum, mode, type, named)
+     CUMULATIVE_ARGS *cum;
+     enum machine_mode mode;
+     tree type;
+     int named ATTRIBUTE_UNUSED;
+{
+  int regs = msp430_num_arg_regs (mode, type);
+
+  cum->nregs -= regs;
+  cum->regno -= regs;
+
+  if (cum->nregs <= 0)
+    {
+      cum->nregs = 0;
+      cum->regno = FIRST_CUM_REG;
+    }
+}
+
+/* Workaround for volatile variables */
+int
+nonimmediate_operand_msp430 (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int save_volatile_ok = volatile_ok;
+  int niop = 0;
+
+  if (!TARGET_NVWA)
+    volatile_ok = 1;
+  niop = nonimmediate_operand (op, mode);
+  volatile_ok = save_volatile_ok;
+
+  return niop;
+}
+
+int
+memory_operand_msp430 (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int save_volatile_ok = volatile_ok;
+  int mop = 0;
+
+  if (!TARGET_NVWA)
+    volatile_ok = 1;
+  mop = memory_operand (op, mode);
+  volatile_ok = save_volatile_ok;
+  return mop;
+}
+
+int
+general_operand_msp430 (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int save_volatile_ok = volatile_ok;
+  int gop = 0;
+
+  if (!TARGET_NVWA)
+    volatile_ok = 1;
+  gop = general_operand (op, mode);
+  volatile_ok = save_volatile_ok;
+  return gop;
+}
+
+
+int
+halfnibble_integer (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int hi, lo;
+  int val;
+
+  if (!const_int_operand (op, mode))
+    return 0;
+
+  /* this integer is the one of form:
+     0xXXXX0000 or 0x0000XXXX,
+     where XXXX not one of -1,1,2,4,8 
+   */
+  val = INTVAL (op);
+  hi = ((val & 0xffff0000ul) >> 16) & 0xffff;
+  lo = (val & 0xffff);
+
+  if (hi && lo)
+    return 0;
+
+  if (hi && hi != 0xffff && hi != 1 && hi != 2 && hi != 4 && hi != 8)
+    return 1;
+  if (lo && lo != 0xffff && lo != 1 && lo != 2 && lo != 4 && lo != 8)
+    return 1;
+
+  return 0;
+}
+
+
+int
+halfnibble_constant (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int hi, lo;
+  int val;
+
+  if (!const_int_operand (op, mode))
+    return 0;
+
+  /* this integer is the one of form:
+     0xXXXX0000 or 0x0000XXXX,
+     where XXXX one of -1,1,2,4,8 
+   */
+  val = INTVAL (op);
+  hi = ((val & 0xffff0000ul) >> 16) & 0x0000ffff;
+  lo = (val & 0x0000ffff);
+
+  if ((hi && lo) || (!hi && !lo))
+    return 0;
+
+  if (hi == 0xffff || hi == 1 || hi == 2 || hi == 4 || hi == 8)
+    return 1;
+  if (lo == 0xffff || lo == 1 || lo == 2 || lo == 4 || lo == 8)
+    return 1;
+
+  if (!(hi && lo))
+    return 1;
+
+  return 0;
+}
+
+
+int
+halfnibble_integer_shift (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int hi, lo;
+  int val;
+
+  if (!immediate_operand (op, mode))
+    return 0;
+
+  /* this integer is the one of form:
+     0xXXXX0000 or 0x0000XXXX,
+     where XXXX not one of -1,1,2,4,8 
+   */
+  val = 1 << INTVAL (op);
+  hi = ((val & 0xffff0000ul) >> 16) & 0x0000ffff;
+  lo = (val & 0x0000ffff);
+
+  if (hi && lo)
+    return 0;
+
+  if (hi && hi != 0xffff && hi != 1 && hi != 2 && hi != 4 && hi != 8)
+    return 1;
+  if (lo && lo != 0xffff && lo != 1 && lo != 2 && lo != 4 && lo != 8)
+    return 1;
+
+  return 0;
+}
+
+
+int
+halfnibble_constant_shift (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  int hi, lo;
+  int val;
+
+  if (!immediate_operand (op, mode))
+    return 0;
+
+  /* this integer is the one of form:
+     0xXXXX0000 or 0x0000XXXX,
+     where XXXX one of -1,1,2,4,8 
+   */
+  val = 1 << INTVAL (op);
+  hi = ((val & 0xffff0000ul) >> 16) & 0x0000ffff;
+  lo = (val & 0x0000ffff);
+
+  if (hi && lo)
+    return 0;
+
+  if (hi && hi == 0xffff && hi == 1 && hi == 2 && hi == 4 && hi == 8)
+    return 1;
+  if (lo && lo == 0xffff && lo == 1 && lo == 2 && lo == 4 && lo == 8)
+    return 1;
+
+  return 0;
+}
+
+int
+which_nibble (val)
+     int val;
+{
+  if (val & 0xffff0000ul)
+    return 1;
+  return 0;
+}
+
+int
+which_nibble_shift (val)
+     int val;
+{
+  if (val & 0xffff0000ul)
+    return 1;
+  return 0;
+}
+
+int
+extra_constraint (x, c)
+     rtx x;
+     int c;
+{
+
+  if (c == 'R')
+    {
+      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == REG)
+	{
+	  rtx xx = XEXP (x, 0);
+	  int regno = REGNO (xx);
+	  if (regno >= 4 || regno == 1)
+	    return 1;
+	}
+    }
+  else if (c == 'Q')
+    {
+      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == REG)
+	{
+	  rtx xx = XEXP (x, 0);
+	  int regno = REGNO (xx);
+	  if (regno >= 4 || regno == 1)
+	    return 1;
+	}
+
+      if (GET_CODE (x) == MEM
+	  && GET_CODE (XEXP (x, 0)) == PLUS
+	  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)
+	{
+	  rtx xx = XEXP (XEXP (x, 0), 0);
+	  int regno = REGNO (xx);
+	  if (regno >= 4 || regno == 1)
+	    return 1;
+	}
+
+      if (GET_CODE (x) == MEM
+	  && GET_CODE (XEXP (x, 0)) == PLUS && REG_P (XEXP (XEXP (x, 0), 0)))
+	{
+	  return 1;
+	}
+
+    }
+  else if (c == 'S')
+    {
+      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == SYMBOL_REF)
+	{
+	  return 1;
+	}
+    }
+
+  return 0;
+}
+
+int
+indexed_location (x)
+     rtx x;
+{
+  int r = 0;
+
+  if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == REG)
+    {
+      r = 1;
+    }
+
+  if (TARGET_ALL_DEBUG)
+    {
+      fprintf (stderr, "indexed_location %s: %s  \n",
+	       r ? "granted" : "failed",
+	       reload_completed ? "reload completed" : "reload in progress");
+      debug_rtx (x);
+    }
+
+  return r;
+}
+
+int
+zero_shifted (x)
+     rtx x;
+{
+  int r = 0;
+
+  if (GET_CODE (x) == MEM &&
+      GET_CODE (XEXP (x, 0)) == REG
+      && REGNO (XEXP (x, 0)) != STACK_POINTER_REGNUM
+      && REGNO (XEXP (x, 0)) != FRAME_POINTER_REGNUM
+      /* the following is Ok, cause we do not corrupt r4 within ISR */
+      /*&& REGNO(XEXP (x,0)) != ARG_POINTER_REGNUM */ )
+    {
+      r = 1;
+    }
+  return r;
+}
+
+/* assume dst costs as much as src */
+int
+msp430_address_costs (x)
+     rtx x;
+{
+  enum rtx_code code = GET_CODE (x);
+  rtx op0, op1;
+
+  switch (code)
+    {
+    case PLUS:			/* X(rn), addr + X */
+      op0 = XEXP (x, 0);
+      op1 = XEXP (x, 1);
+      if (REG_P (op0))
+	{
+	  if (INTVAL (op1) == 0)
+	    return COSTS_N_INSNS (2);
+	  else
+	    return COSTS_N_INSNS (3);
+	}
+      break;
+    case REG:
+      return COSTS_N_INSNS (2);
+      break;
+    default:
+      break;
+    }
+  return COSTS_N_INSNS (3);
+}
+
+static bool
+msp430_rtx_costs (x, code, outer_code, total)
+     rtx x;
+     enum rtx_code code, outer_code;
+     int *total;
+{
+  int cst;
+  rtx op0, op1;
+/***
+  [(outer:mode1 (inner:mode (op1) (op2))]
+
+  
+  inner		outer	mode1	op1   op2
+  --------------------------
+  CONST_INT	UNKNOWN	VOID
+  PLUS		SET	HI	reg + reg
+  ASHIFT	SET	HI	reg << 1
+  ASHIFT	SET	HI	reg << 15
+  NEG		SET	HI	reg
+  DIV		SET	HI	reg / 32
+  MOD		SET	HI	reg % 32
+  UDIV		SET	QI	reg / reg
+  MULT		SET	QI	reg * reg
+  MULT		SET	HI	0<-reg * 0<-reg
+  TRUNCATE	SET	QI	HI -> QI
+  UDIV		SET	HI	reg / reg
+  MULT		SET	HI	reg * reg
+  MULT		SET	SI	0<-reg * 0<-reg
+  TRUNCATE	SET	HI	SI -> HI
+  UDIV		SET	SI	reg / reg
+  MULT		SET	SI	reg * reg
+  MULT		SET	DI	0<-reg * 0<-reg
+  TRUNCATE	SET	SI	DI -> SI
+  UDIV		SET	DI	reg / reg
+  MULT		SET	DI	reg * reg
+  MULT		SET	TI	0<-reg * 0<-reg
+  TRUNCATE	SET	DI	TI -> DI
+  UDIV		SET	TI	reg / reg
+  MULT		SET	TI	reg * reg
+  MULT		SET	OI	reg * reg
+  TRUNCATE	SET	TI	OI -> TI
+  UDIV		SET	OI	reg / reg
+  MULT		SET	OI	reg * reg
+  CONST_INT	COMPARE	VOID	
+  ...
+  CONST_INT	PLUS	HI	reg + const
+  PLUS		MEM	HI	X(rn)
+  PLUS		CONST_INT	???????? ?????
+  MEM		SET	any
+  PLUS		MEM	HI	reg + const
+  
+***/
+  cst = COSTS_N_INSNS (5);
+  if (outer_code == SET)
+    {
+      op0 = XEXP (x, 0);
+      op1 = XEXP (x, 1);
+      switch (code)
+	{
+	case CONST_INT:	/* source only !!! */
+	  {
+	    int i = INTVAL (x);
+	    if (i == -1 || i == 0 || i == 2 || i == 4 || i == 8)
+	      cst = COSTS_N_INSNS (1);
+	    else
+	      cst = COSTS_N_INSNS (2);
+	  }
+	  break;
+	case PLUS:
+	case MINUS:
+	case AND:
+	case IOR:
+	case XOR:
+	case UNSPEC:
+	case UNSPEC_VOLATILE:
+	  cst = COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  break;
+	case ASHIFT:
+	case LSHIFTRT:
+	case ASHIFTRT:
+	  if (CONSTANT_P (op1) && INTVAL (op1) == 1)
+	    cst =
+		COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 15)
+	    cst =
+		3 *
+		COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 8)
+	    cst =
+		2 *
+		COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 16)
+	    cst =
+		COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 24)
+	    cst =
+		4 *
+		COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  else if (CONSTANT_P (op1) && INTVAL (op1) == 31)
+	    cst =
+		3 *
+		COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  if (code == ASHIFTRT)
+	    cst += COSTS_N_INSNS (1);
+	  break;
+
+	case NEG:
+	  cst =
+	      2 *
+	      COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  break;
+	case DIV:
+	case MOD:
+	case MULT:
+	case UDIV:
+	  cst = COSTS_N_INSNS (64);
+	  break;
+	case TRUNCATE:
+	  cst = COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  break;
+	case ZERO_EXTEND:
+	  cst =
+	      2 *
+	      COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  break;
+	case SIGN_EXTEND:
+	case ABS:
+	  cst =
+	      2 *
+	      COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+	  cst += COSTS_N_INSNS (2);
+	  break;
+	default:
+	  cst = 0;
+	}
+    }
+  else if (outer_code == COMPARE)
+    {
+      cst = COSTS_N_INSNS (((GET_MODE_SIZE (GET_MODE (x)) + 1) & ~1) >> 1);
+      cst += COSTS_N_INSNS (2);
+    }
+  else if (outer_code == JUMP_INSN)
+    {
+      cst = COSTS_N_INSNS (2);
+    }
+  else if (outer_code == CALL_INSN)
+    {
+      cst = COSTS_N_INSNS (4);
+    }
+  else
+    return false;
+
+  *total = cst;
+  if (cst)
+    return true;
+  return false;
+}
+
+int
+default_rtx_costs (X, code, outer_code)
+     rtx X ATTRIBUTE_UNUSED;
+     enum rtx_code code;
+     enum rtx_code outer_code ATTRIBUTE_UNUSED;
+{
+  int cost = 4;
+
+  switch (code)
+    {
+    case SYMBOL_REF:
+      cost += 2;
+      break;
+    case LABEL_REF:
+      cost += 2;
+      break;
+    case MEM:
+      cost += 2;
+      break;
+    case CONST_INT:
+      cost += 2;
+      break;
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
+      cost += 2;
+      break;
+    default:
+      break;
+    }
+  return cost;
+}
+
+void
+order_regs_for_local_alloc ()
+{
+  unsigned int i;
+
+  if (TARGET_REORDER)
+    {
+      reg_alloc_order[0] = 12;
+      reg_alloc_order[1] = 13;
+      reg_alloc_order[2] = 14;
+      reg_alloc_order[3] = 15;
+      for (i = 4; i < 16; i++)
+	reg_alloc_order[i] = 15 - i;
+    }
+  else
+    {
+      for (i = 0; i < 16; i++)
+	reg_alloc_order[i] = 15 - i;
+    }
+
+  return;
+}
+
+static void 
+msp430_globalize_label(stream,name)
+    FILE *stream;
+    const char *name;
+{
+  if(*name == '*' || *name == '@') name++;
+  if(*name >='0' && *name <='9') return;
+  fputs (GLOBAL_ASM_OP, stream);
+  assemble_name (stream, name);
+  putc ('\n', stream);
+}
+
+/* Output rtx VALUE as .byte to file FILE */
+void
+asm_output_char (file, value)
+     FILE *file;
+     rtx value;
+{
+  fprintf (file, "\t.byte\t");
+  output_addr_const (file, value);
+  fprintf (file, "\n");
+}
+
+/* Output VALUE as .byte to file FILE */
+void
+asm_output_byte (file, value)
+     FILE *file;
+     int value;
+{
+  fprintf (file, "\t.byte 0x%x\n", value & 0xff);
+}
+
+/* Output rtx VALUE as .word to file FILE */
+void
+asm_output_short (file, value)
+     FILE *file;
+     rtx value;
+{
+  fprintf (file, "\t.word ");
+  output_addr_const (file, (value));
+  fprintf (file, "\n");
+}
+
+
+/* Output section name to file FILE
+   We make the section read-only and executable for a function decl,
+   read-only for a const data decl, and writable for a non-const data decl.  */
+
+void
+asm_output_section_name (file, decl, name, reloc)
+     FILE *file;
+     tree decl;
+     const char *name;
+     int reloc ATTRIBUTE_UNUSED;
+{
+  fprintf (file, ".section %s, \"%s\", @progbits\n", name,
+	   decl && TREE_CODE (decl) == FUNCTION_DECL ? "ax" :
+	   decl && TREE_READONLY (decl) ? "a" : "aw");
+}
+
+
+/* The routine used to output NUL terminated strings.  We use a special
+   version of this for most svr4 targets because doing so makes the
+   generated assembly code more compact (and thus faster to assemble)
+   as well as more readable, especially for targets like the i386
+   (where the only alternative is to output character sequences as
+   comma separated lists of numbers).   */
+
+void
+gas_output_limited_string (file, str)
+     FILE *file;
+     const char *str;
+{
+  const unsigned char *_limited_str = (unsigned char *) str;
+  unsigned ch;
+  fprintf (file, "%s\"", STRING_ASM_OP);
+  for (; (ch = *_limited_str); _limited_str++)
+    {
+      int escape;
+      switch (escape = ESCAPES[ch])
+	{
+	case 0:
+	  putc (ch, file);
+	  break;
+	case 1:
+	  fprintf (file, "\\%03o", ch);
+	  break;
+	default:
+	  putc ('\\', file);
+	  putc (escape, file);
+	  break;
+	}
+    }
+  fprintf (file, "\"\n");
+}
+
+/* The routine used to output sequences of byte values.  We use a special
+   version of this for most svr4 targets because doing so makes the
+   generated assembly code more compact (and thus faster to assemble)
+   as well as more readable.  Note that if we find subparts of the
+   character sequence which end with NUL (and which are shorter than
+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */
+void
+gas_output_ascii (file, str, length)
+     FILE *file;
+     const char *str;
+     size_t length;
+{
+  const unsigned char *_ascii_bytes = (const unsigned char *) str;
+  const unsigned char *limit = _ascii_bytes + length;
+  unsigned bytes_in_chunk = 0;
+  for (; _ascii_bytes < limit; _ascii_bytes++)
+    {
+      const unsigned char *p;
+      if (bytes_in_chunk >= 60)
+	{
+	  fprintf (file, "\"\n");
+	  bytes_in_chunk = 0;
+	}
+      for (p = _ascii_bytes; p < limit && *p != '\0'; p++)
+	continue;
+      if (p < limit && (p - _ascii_bytes) <= (signed) STRING_LIMIT)
+	{
+	  if (bytes_in_chunk > 0)
+	    {
+	      fprintf (file, "\"\n");
+	      bytes_in_chunk = 0;
+	    }
+	  gas_output_limited_string (file, (char *) _ascii_bytes);
+	  _ascii_bytes = p;
+	}
+      else
+	{
+	  int escape;
+	  unsigned ch;
+	  if (bytes_in_chunk == 0)
+	    fprintf (file, "\t.ascii\t\"");
+	  switch (escape = ESCAPES[ch = *_ascii_bytes])
+	    {
+	    case 0:
+	      putc (ch, file);
+	      bytes_in_chunk++;
+	      break;
+	    case 1:
+	      fprintf (file, "\\%03o", ch);
+	      bytes_in_chunk += 4;
+	      break;
+	    default:
+	      putc ('\\', file);
+	      putc (escape, file);
+	      bytes_in_chunk += 2;
+	      break;
+	    }
+	}
+    }
+  if (bytes_in_chunk > 0)
+    fprintf (file, "\"\n");
+}
+
+/* Outputs to the stdio stream FILE some
+   appropriate text to go at the start of an assembler file.  */
+
+void
+asm_file_start (file)
+     FILE *file;
+{
+  output_file_directive (file, main_input_filename);
+  fprintf (file, "\t.arch %s\n\n", msp430_mcu_name);
+
+  if (msp430_has_hwmul)
+    {
+      fprintf (file, "/* Hardware multiplier registers: */\n"
+	       "__MPY=0x130\n"
+	       "__MPYS=0x132\n"
+	       "__MAC=0x134\n"
+	       "__MACS=0x136\n"
+	       "__OP2=0x138\n"
+	       "__RESLO=0x13a\n" "__RESHI=0x13c\n" "__SUMEXT=0x13e\n" "\n");
+
+    }
+
+  commands_in_file = 0;
+  commands_in_prologues = 0;
+  commands_in_epilogues = 0;
+  max_stack_usage = 0;
+}
+
+/* Outputs to the stdio stream FILE some
+   appropriate text to go at the end of an assembler file.  */
+
+void
+asm_file_end (file)
+     FILE *file;
+{
+  fprintf (file,
+	   "\n"
+	   "/*********************************************************************\n"
+	   " * File %s: code size: %d words (0x%x)\n"
+	   " * incl. words in prologues: %d, epilogues: %d\n"
+	   " * max stack usage: %d (functions start only)\n"
+	   " *********************************************************************/\n",
+	   main_input_filename,
+	   commands_in_file,
+	   commands_in_file,
+	   commands_in_prologues, commands_in_epilogues, max_stack_usage);
+}
+
+int
+msp430_hard_regno_mode_ok (regno, mode)
+     int regno ATTRIBUTE_UNUSED;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return 1;
+}
+
+int
+frame_pointer_required_p ()
+{
+  return (current_function_calls_alloca
+	  /*            || current_function_args_info.nregs == 0 */
+	  /* || current_function_varargs */ );
+
+  /* || get_frame_size () > 0); */
+}
+
+enum reg_class
+preferred_reload_class (x, class)
+     rtx x ATTRIBUTE_UNUSED;
+     enum reg_class class;
+{
+  return class;
+}
+
+/* cfp minds the fact that the function may save r2 */
+int
+initial_elimination_offset (from, to)
+     int from;
+     int to;
+{
+  int reg;
+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+    return 0;
+  else
+    {
+      int interrupt_func_p = interrupt_function_p (current_function_decl);
+      int cfp = msp430_critical_function_p (current_function_decl);
+      int leaf_func_p = leaf_function_p ();
+      int offset = interrupt_func_p ? 0 : (cfp ? 2 : 0);
+
+      for (reg = 4; reg < 16; ++reg)
+	{
+	  if ((!leaf_func_p && call_used_regs[reg] && (interrupt_func_p))
+	      || (regs_ever_live[reg]
+		  && (!call_used_regs[reg] || interrupt_func_p)))
+	    {
+	      offset += 2;
+	    }
+	}
+      return get_frame_size () + offset + 2;
+    }
+  return 0;
+}
+
+int
+adjust_insn_length (insn, len)
+     rtx insn;
+     int len;
+{
+
+  rtx patt = PATTERN (insn);
+  rtx set;
+
+  set = single_set (insn);
+
+  if (GET_CODE (patt) == SET)
+    {
+      rtx op[10];
+      op[1] = SET_SRC (patt);
+      op[0] = SET_DEST (patt);
+
+      if (general_operand (op[1], VOIDmode)
+	  && general_operand (op[0], VOIDmode))
+	{
+	  op[2] = SET_SRC (patt);
+	  switch (GET_MODE (op[0]))
+	    {
+	    case QImode:
+	    case HImode:
+	      if (indexed_location (op[1]))
+		len--;
+	      break;
+
+	    case SImode:
+	    case SFmode:
+	      /* get length first */
+	      msp430_movesi_code (insn, op, &len);
+
+	      if (zero_shifted (op[1]) && regsi_ok_safe (op))
+		{
+		  rtx reg = XEXP (op[1], 0);
+		  if (dead_or_set_p (insn, reg))
+		    len -= 1;
+		}
+	      else if (!zero_shifted (op[1]) && indexed_location (op[1]))
+		{
+		  len -= 1;
+		}
+	      break;
+	    case DImode:
+	      msp430_movedi_code (insn, op, &len);
+	      if (zero_shifted (op[1]) && regdi_ok_safe (op))
+		{
+		  rtx reg = XEXP (op[1], 0);
+		  if (dead_or_set_p (insn, reg))
+		    len -= 1;
+		}
+	      else if (!zero_shifted (op[1]) && indexed_location (op[1]))
+		{
+		  len -= 1;
+		}
+	      break;
+
+	    default:
+	      break;
+	    }
+
+	  if (GET_CODE (op[2]) == CONST_INT)
+	    {
+	      if (GET_MODE (op[0]) == DImode)
+		{
+		  int x = INTVAL (op[2]);
+		  int y = (x & 0xffff0000ul) >> 16;
+		  x = x & 0xffff;
+
+		  len -= 2;
+
+		  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+		      || x == 0xffff)
+		    len--;
+		  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+		      || y == 0xffff)
+		    len--;
+		}
+	      else if (GET_MODE (op[0]) == SImode)
+		{
+		  int x = INTVAL (op[2]);
+		  int y = (x & 0xffff0000ul) >> 16;
+		  x = x & 0xffff;
+
+		  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+		      || x == 0xffff)
+		    len--;
+		  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+		      || y == 0xffff)
+		    len--;
+		}
+	      else
+		{
+		  /* mighr be hi or qi modes */
+		  int x = INTVAL (op[2]);
+		  x = x & 0xffff;
+		  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+		      || x == 0xffff)
+		    len--;
+		}
+	    }
+
+	  if (GET_CODE (op[2]) == CONST_DOUBLE)
+	    {
+	      if (GET_MODE (op[0]) == SFmode)
+		{
+		  long val;
+		  int y, x;
+		  REAL_VALUE_TYPE rv;
+		  REAL_VALUE_FROM_CONST_DOUBLE (rv, op[2]);
+		  REAL_VALUE_TO_TARGET_SINGLE (rv, val);
+
+		  y = (val & 0xffff0000ul) >> 16;
+		  x = val & 0xffff;
+		  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+		      || x == 0xffff)
+		    len--;
+		  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+		      || y == 0xffff)
+		    len--;
+		}
+	      else
+		{
+		  int hi = CONST_DOUBLE_HIGH (op[2]);
+		  int lo = CONST_DOUBLE_LOW (op[2]);
+		  int x, y, z;
+
+		  x = (hi & 0xffff0000ul) >> 16;
+		  y = hi & 0xffff;
+		  z = (lo & 0xffff0000ul) >> 16;
+		  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+		      || x == 0xffff)
+		    len--;
+		  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+		      || y == 0xffff)
+		    len--;
+		  if (z == 0 || z == 1 || z == 2 || z == 4 || z == 8
+		      || z == 0xffff)
+		    len--;
+		  z = lo & 0xffff;
+		  if (z == 0 || z == 1 || z == 2 || z == 4 || z == 8
+		      || z == 0xffff)
+		    len--;
+		}
+	    }
+
+	  return len;
+	}
+      else if (GET_CODE (op[1]) == MULT)
+	{
+	  rtx ops[10];
+	  ops[0] = op[0];
+	  ops[1] = XEXP (op[1], 0);
+	  ops[2] = XEXP (op[1], 1);
+
+	  if (GET_MODE (ops[0]) != SImode
+	      && GET_MODE (ops[0]) != SFmode && GET_MODE (ops[0]) != DImode)
+	    {
+	      if (indexed_location (ops[1]))
+		len--;
+	      if (indexed_location (ops[2]))
+		len--;
+	    }
+	}
+      else if (GET_CODE (op[1]) == ASHIFT
+	       || GET_CODE (op[1]) == ASHIFTRT || GET_CODE (op[1]) == LSHIFTRT)
+	{
+	  rtx ops[10];
+	  ops[0] = op[0];
+	  ops[1] = XEXP (op[1], 0);
+	  ops[2] = XEXP (op[1], 1);
+
+	  switch (GET_CODE (op[1]))
+	    {
+	    case ASHIFT:
+	      switch (GET_MODE (op[0]))
+		{
+		case QImode:
+		  msp430_emit_ashlqi3 (insn, ops, &len);
+		  break;
+		case HImode:
+		  msp430_emit_ashlhi3 (insn, ops, &len);
+		  break;
+		case SImode:
+		  msp430_emit_ashlsi3 (insn, ops, &len);
+		  break;
+		case DImode:
+		  msp430_emit_ashldi3 (insn, ops, &len);
+		  break;
+		default:
+		  break;
+		}
+	      break;
+
+	    case ASHIFTRT:
+	      switch (GET_MODE (op[0]))
+		{
+		case QImode:
+		  msp430_emit_ashrqi3 (insn, ops, &len);
+		  break;
+		case HImode:
+		  msp430_emit_ashrhi3 (insn, ops, &len);
+		  break;
+		case SImode:
+		  msp430_emit_ashrsi3 (insn, ops, &len);
+		  break;
+		case DImode:
+		  msp430_emit_ashrdi3 (insn, ops, &len);
+		  break;
+		default:
+		  break;
+		}
+	      break;
+
+	    case LSHIFTRT:
+	      switch (GET_MODE (op[0]))
+		{
+		case QImode:
+		  msp430_emit_lshrqi3 (insn, ops, &len);
+		  break;
+		case HImode:
+		  msp430_emit_lshrhi3 (insn, ops, &len);
+		  break;
+		case SImode:
+		  msp430_emit_lshrsi3 (insn, ops, &len);
+		  break;
+		case DImode:
+		  msp430_emit_lshrdi3 (insn, ops, &len);
+		  break;
+		default:
+		  break;
+		}
+	      break;
+
+	    default:
+	      break;
+	    }
+	}
+      else if (GET_CODE (op[1]) == PLUS
+	       || GET_CODE (op[1]) == MINUS
+	       || GET_CODE (op[1]) == AND
+	       || GET_CODE (op[1]) == IOR || GET_CODE (op[1]) == XOR)
+	{
+	  rtx ops[10];
+	  ops[0] = op[0];
+	  ops[1] = XEXP (op[1], 0);
+	  ops[2] = XEXP (op[1], 1);
+
+	  if (GET_CODE (op[1]) == AND && !general_operand (ops[1], VOIDmode))
+	    return len;
+
+	  switch (GET_MODE (ops[0]))
+	    {
+	    case QImode:
+	    case HImode:
+	      if (indexed_location (ops[2]))
+		len--;
+	      break;
+	    case SImode:
+	    case SFmode:
+
+	      if (GET_CODE (op[1]) == PLUS)
+		msp430_addsi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == MINUS)
+		msp430_subsi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == AND)
+		msp430_andsi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == IOR)
+		msp430_iorsi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == XOR)
+		msp430_xorsi_code (insn, ops, &len);
+
+	      if (zero_shifted (ops[2]) && regsi_ok_safe (ops))
+		{
+		  rtx reg = XEXP (ops[2], 0);
+		  if (dead_or_set_p (insn, reg))
+		    len -= 1;
+		}
+	      else if (!zero_shifted (ops[2]) && indexed_location (ops[2]))
+		{
+		  len -= 1;
+		}
+	      break;
+	    case DImode:
+
+	      if (GET_CODE (op[1]) == PLUS)
+		msp430_adddi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == MINUS)
+		msp430_subdi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == AND)
+		msp430_anddi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == IOR)
+		msp430_iordi_code (insn, ops, &len);
+	      if (GET_CODE (op[1]) == XOR)
+		msp430_xordi_code (insn, ops, &len);
+
+	      if (zero_shifted (ops[2]) && regdi_ok_safe (ops))
+		{
+		  rtx reg = XEXP (ops[2], 0);
+		  if (dead_or_set_p (insn, reg))
+		    len -= 1;
+		}
+	      else if (!zero_shifted (ops[2]) && indexed_location (ops[2]))
+		{
+		  len -= 1;
+		}
+	      break;
+
+	    default:
+	      break;
+	    }
+
+	  if (GET_MODE (ops[0]) == SImode)
+	    {
+	      if (GET_CODE (ops[2]) == CONST_INT)
+		{
+		  if (GET_CODE (op[1]) == AND)
+		    {
+		      msp430_emit_immediate_and2 (insn, ops, &len);
+		    }
+		  else if (GET_CODE (op[1]) == IOR)
+		    {
+		      msp430_emit_immediate_ior2 (insn, ops, &len);
+		    }
+		  else
+		    {
+		      if (GET_MODE (ops[0]) == SImode)
+			{
+			  int x = INTVAL (ops[2]);
+			  int y = (x & 0xffff0000ul) >> 16;
+			  x = x & 0xffff;
+
+			  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+			      || x == 0xffff)
+			    len--;
+			  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+			      || y == 0xffff)
+			    len--;
+			}
+		    }
+		}
+	    }
+
+	  if (GET_MODE (ops[0]) == SFmode || GET_MODE (ops[0]) == DImode)
+	    {
+	      if (GET_CODE (ops[2]) == CONST_DOUBLE)
+		{
+
+		  if (GET_CODE (op[1]) == AND)
+		    {
+		      msp430_emit_immediate_and4 (insn, ops, &len);
+		    }
+		  else if (GET_CODE (op[1]) == IOR)
+		    {
+		      msp430_emit_immediate_ior4 (insn, ops, &len);
+		    }
+		  else if (GET_MODE (ops[0]) == SFmode)
+		    {
+		      long val;
+		      int y, x;
+		      REAL_VALUE_TYPE rv;
+		      REAL_VALUE_FROM_CONST_DOUBLE (rv, ops[2]);
+		      REAL_VALUE_TO_TARGET_SINGLE (rv, val);
+
+		      y = (val & 0xffff0000ul) >> 16;
+		      x = val & 0xffff;
+		      if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+			  || x == 0xffff)
+			len--;
+		      if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+			  || y == 0xffff)
+			len--;
+		    }
+		  else
+		    {
+		      int hi = CONST_DOUBLE_HIGH (ops[2]);
+		      int lo = CONST_DOUBLE_LOW (ops[2]);
+		      int x, y, z;
+
+		      x = (hi & 0xffff0000ul) >> 16;
+		      y = hi & 0xffff;
+		      z = (lo & 0xffff0000ul) >> 16;
+		      if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8
+			  || x == 0xffff)
+			len--;
+		      if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8
+			  || y == 0xffff)
+			len--;
+		      if (z == 0 || z == 1 || z == 2 || z == 4 || z == 8
+			  || z == 0xffff)
+			len--;
+		    }
+		}
+	    }
+
+	  return len;
+	}
+      else if (GET_CODE (op[1]) == NOT
+	       || GET_CODE (op[1]) == ABS || GET_CODE (op[1]) == NEG)
+	{
+	  if (GET_MODE (op[0]) == HImode || GET_MODE (op[0]) == QImode)
+	    if (indexed_location (XEXP (op[1], 0)))
+	      len--;
+	  /* consts handled by cpp */
+	  /* nothing... */
+	}
+      else if (GET_CODE (op[1]) == ZERO_EXTEND)
+	{
+	  rtx ops[10];
+	  ops[0] = op[0];
+	  ops[1] = XEXP (op[1], 0);
+
+	  if (GET_MODE (ops[1]) == QImode)
+	    {
+	      if (GET_MODE (ops[0]) == HImode)
+		zeroextendqihi (insn, ops, &len);
+	      else if (GET_MODE (ops[0]) == SImode)
+		zeroextendqisi (insn, ops, &len);
+	      else if (GET_MODE (ops[0]) == DImode)
+		zeroextendqidi (insn, ops, &len);
+	    }
+	  else if (GET_MODE (ops[1]) == HImode)
+	    {
+	      if (GET_MODE (ops[0]) == SImode)
+		zeroextendhisi (insn, ops, &len);
+	      else if (GET_MODE (ops[0]) == DImode)
+		zeroextendhidi (insn, ops, &len);
+	    }
+	  else if (GET_MODE (ops[1]) == SImode)
+	    {
+	      if (GET_MODE (ops[1]) == DImode)
+		zeroextendsidi (insn, ops, &len);
+	    }
+	}
+      else if (GET_CODE (op[1]) == SIGN_EXTEND)
+	{
+	  rtx ops[10];
+	  ops[0] = op[0];	/* dest */
+	  ops[1] = XEXP (op[1], 0);	/* src */
+
+	  if (GET_MODE (ops[1]) == QImode)
+	    {
+	      if (GET_MODE (ops[0]) == HImode)
+		signextendqihi (insn, ops, &len);
+	      else if (GET_MODE (ops[0]) == SImode)
+		signextendqisi (insn, ops, &len);
+	      else if (GET_MODE (ops[0]) == DImode)
+		signextendqidi (insn, ops, &len);
+	    }
+	  else if (GET_MODE (ops[1]) == HImode)
+	    {
+	      if (GET_MODE (ops[0]) == SImode)
+		signextendhisi (insn, ops, &len);
+	      else if (GET_MODE (ops[0]) == DImode)
+		signextendhidi (insn, ops, &len);
+	    }
+	  else if (GET_MODE (ops[1]) == SImode)
+	    {
+	      if (GET_MODE (ops[0]) == DImode)
+		signextendsidi (insn, ops, &len);
+	    }
+	}
+      else if (GET_CODE (op[1]) == IF_THEN_ELSE)
+	{
+	  if (GET_CODE (op[0]) == PC)
+	    {
+	      rtx ops[5];
+	      ops[0] = XEXP (op[1], 1);
+	      ops[1] = XEXP (op[1], 0);
+	      ops[2] = XEXP (ops[1], 0);
+	      ops[3] = XEXP (ops[1], 1);
+	      msp430_cbranch (insn, ops, &len);
+	    }
+	}
+      else if (GET_CODE (op[0]) == MEM
+	       && GET_CODE (XEXP (op[0], 0)) == POST_DEC)
+	{
+	  rtx ops[4];
+	  ops[0] = op[1];
+	  if (GET_MODE (op[0]) == QImode)
+	    msp430_pushqi (insn, ops, &len);
+	  if (GET_MODE (op[0]) == HImode)
+	    msp430_pushhi (insn, ops, &len);
+	  if (GET_MODE (op[0]) == SImode)
+	    msp430_pushsisf (insn, ops, &len);
+	  if (GET_MODE (op[0]) == DImode)
+	    msp430_pushdi (insn, ops, &len);
+	}
+    }
+
+  if (set)
+    {
+      rtx op[10];
+      op[1] = SET_SRC (set);
+      op[0] = SET_DEST (set);
+
+      if (GET_CODE (patt) == PARALLEL)
+	{
+	  if (GET_CODE (op[0]) == PC && GET_CODE (op[1]) == IF_THEN_ELSE)
+	    {
+	      rtx ops[5];
+	      ops[0] = XEXP (op[1], 1);
+	      ops[1] = XEXP (op[1], 0);
+	      ops[2] = XEXP (ops[1], 0);
+	      ops[3] = XEXP (ops[1], 1);
+	      msp430_cbranch (insn, ops, &len);
+	    }
+
+	  if (GET_CODE (op[1]) == ASHIFT
+	      || GET_CODE (op[1]) == ASHIFTRT || GET_CODE (op[1]) == LSHIFTRT)
+	    {
+	      rtx ops[10];
+	      ops[0] = op[0];
+	      ops[1] = XEXP (op[1], 0);
+	      ops[2] = XEXP (op[1], 1);
+
+	      switch (GET_CODE (op[1]))
+		{
+		case ASHIFT:
+		  switch (GET_MODE (op[0]))
+		    {
+		    case QImode:
+		      msp430_emit_ashlqi3 (insn, ops, &len);
+		      break;
+		    case HImode:
+		      msp430_emit_ashlhi3 (insn, ops, &len);
+		      break;
+		    case SImode:
+		      msp430_emit_ashlsi3 (insn, ops, &len);
+		      break;
+		    case DImode:
+		      msp430_emit_ashldi3 (insn, ops, &len);
+		      break;
+		    default:
+		      break;
+		    }
+		  break;
+
+		case ASHIFTRT:
+		  switch (GET_MODE (op[0]))
+		    {
+		    case QImode:
+		      msp430_emit_ashrqi3 (insn, ops, &len);
+		      break;
+		    case HImode:
+		      msp430_emit_ashrhi3 (insn, ops, &len);
+		      break;
+		    case SImode:
+		      msp430_emit_ashrsi3 (insn, ops, &len);
+		      break;
+		    case DImode:
+		      msp430_emit_ashrdi3 (insn, ops, &len);
+		      break;
+		    default:
+		      break;
+		    }
+		  break;
+
+		case LSHIFTRT:
+		  switch (GET_MODE (op[0]))
+		    {
+		    case QImode:
+		      msp430_emit_lshrqi3 (insn, ops, &len);
+		      break;
+		    case HImode:
+		      msp430_emit_lshrhi3 (insn, ops, &len);
+		      break;
+		    case SImode:
+		      msp430_emit_lshrsi3 (insn, ops, &len);
+		      break;
+		    case DImode:
+		      msp430_emit_lshrdi3 (insn, ops, &len);
+		      break;
+		    default:
+		      break;
+		    }
+		  break;
+
+		default:
+		  break;
+		}
+	    }
+	}
+    }
+
+  return len;
+}
+
+
+/* Output all insn addresses and their sizes into the assembly language
+   output file.  This is helpful for debugging whether the length attributes
+      in the md file are correct.
+         Output insn cost for next insn.  */
+
+void
+final_prescan_insn (insn, operand, num_operands)
+     rtx insn, *operand ATTRIBUTE_UNUSED;
+     int num_operands ATTRIBUTE_UNUSED;
+{
+  int uid = INSN_UID (insn);
+
+  if (TARGET_ALL_DEBUG)
+    {
+      fprintf (asm_out_file, "/*DEBUG: 0x%x\t\t%d\t%d */\n",
+	       INSN_ADDRESSES (uid),
+	       INSN_ADDRESSES (uid) - last_insn_address,
+	       rtx_cost (PATTERN (insn), INSN));
+    }
+  last_insn_address = INSN_ADDRESSES (uid);
+}
+
+void
+msp430_output_addr_vec_elt (stream, value)
+     FILE *stream;
+     int value;
+{
+  fprintf (stream, "\t.word	.L%d\n", value);
+  jump_tables_size++;
+}
+
+
+void
+machine_dependent_reorg (first_insn)
+     rtx first_insn ATTRIBUTE_UNUSED;
+{
+  /* nothing to be done here this time */
+  return;
+}
+
+int
+test_hard_reg_class (class, x)
+     enum reg_class class;
+     rtx x;
+{
+  int regno = true_regnum (x);
+  if (regno < 0)
+    return 0;
+  return TEST_HARD_REG_CLASS (class, regno);
+}
+
+
+/* Returns 1 if SCRATCH are safe to be allocated as a scratch
+   registers (for a define_peephole2) in the current function.  */
+/* UNUSED ... yet... */
+int
+msp430_peep2_scratch_safe (scratch)
+     rtx scratch;
+{
+  if ((interrupt_function_p (current_function_decl)
+       || signal_function_p (current_function_decl)) && leaf_function_p ())
+    {
+      int first_reg = true_regnum (scratch);
+      int last_reg;
+      int size = GET_MODE_SIZE (GET_MODE (scratch));
+      int reg;
+
+      size >>= 1;
+      if (!size)
+	size = 1;
+
+      last_reg = first_reg + size - 1;
+
+      for (reg = first_reg; reg <= last_reg; reg++)
+	{
+	  if (!regs_ever_live[reg])
+	    return 0;
+	}
+    }
+
+  return 1;
+}
+
+/* Update the condition code in the INSN.  */
+
+void
+notice_update_cc (body, insn)
+     rtx body ATTRIBUTE_UNUSED;
+     rtx insn ATTRIBUTE_UNUSED;
+{
+  CC_STATUS_INIT;
+}
+
+
+/*********************************************************************/
+
+/*
+     Next two return non zero for rtx as
+     (set (reg:xx)
+     	  (mem:xx (reg:xx))
+ 
+*/
+
+int
+regsi_ok_safe (operands)
+     rtx operands[];
+{
+  rtx dest = operands[0];
+  rtx areg;
+  int src_reg;
+  int dst_reg;
+
+  if (operands[2])
+    areg = XEXP (operands[2], 0);
+  else
+    areg = XEXP (operands[1], 0);
+
+  if (GET_CODE (dest) == MEM)
+    {
+      dest = XEXP (operands[0], 0);
+      if (GET_CODE (dest) == PLUS && GET_CODE (XEXP (dest, 0)) == REG)
+	{
+	  dest = XEXP (dest, 0);
+	}
+      else if (GET_CODE (dest) == REG)
+	{
+	  ;			/* register */
+	}
+      else
+	return 1;
+    }
+
+  if (REGNO (dest) >= FIRST_PSEUDO_REGISTER
+      || REGNO (areg) >= FIRST_PSEUDO_REGISTER)
+    return 1;
+
+  dst_reg = true_regnum (dest);
+  src_reg = true_regnum (areg);
+  if (dst_reg > src_reg || dst_reg + 1 < src_reg)
+    {
+      return 1;
+    }
+  return 0;
+}
+
+int
+regsi_ok_clobber (operands)
+     rtx operands[];
+{
+  rtx dest = operands[0];
+  rtx areg = XEXP (operands[2], 0);
+  int src_reg;
+  int dst_reg;
+  int regno = REGNO (dest);
+
+
+  if (GET_CODE (dest) == MEM)
+    {
+      dest = XEXP (operands[0], 0);
+      if (GET_CODE (dest) == PLUS && GET_CODE (XEXP (dest, 0)) == REG)
+	{
+	  dest = XEXP (dest, 0);
+	}
+      else if (GET_CODE (dest) == REG)
+	{
+	  ;			/* register */
+	}
+      else
+	return 1;
+    }
+
+  if (regno >= FIRST_PSEUDO_REGISTER || REGNO (areg) >= FIRST_PSEUDO_REGISTER)
+    return 1;
+
+  dst_reg = true_regnum (dest);
+  src_reg = true_regnum (areg);
+  if (dst_reg + 1 == src_reg)
+    return 1;
+  return 0;
+}
+
+int
+regdi_ok_safe (operands)
+     rtx operands[];
+{
+  rtx dest = operands[0];
+  rtx areg = XEXP (operands[2], 0);
+  int src_reg;
+  int dst_reg;
+
+
+  if (GET_CODE (dest) == MEM)
+    {
+      dest = XEXP (operands[0], 0);
+      if (GET_CODE (dest) == PLUS && GET_CODE (XEXP (dest, 0)) == REG)
+	{
+	  dest = XEXP (dest, 0);
+	}
+      else if (GET_CODE (dest) == REG)
+	{
+	  ;			/* register */
+	}
+      else
+	return 1;
+    }
+
+  if (REGNO (dest) >= FIRST_PSEUDO_REGISTER
+      || REGNO (areg) >= FIRST_PSEUDO_REGISTER)
+    return 1;
+
+  dst_reg = true_regnum (dest);
+  src_reg = true_regnum (areg);
+  if (dst_reg > src_reg || dst_reg + 3 < src_reg)
+    {
+      return 1;
+    }
+
+  return 0;
+}
+
+int
+regdi_ok_clobber (operands)
+     rtx operands[];
+{
+  rtx dest = operands[0];
+  rtx areg = XEXP (operands[2], 0);
+  int src_reg;
+  int dst_reg;
+  int regno = REGNO (dest);
+
+  if (GET_CODE (dest) == MEM)
+    {
+      dest = XEXP (operands[0], 0);
+      if (GET_CODE (dest) == PLUS && GET_CODE (XEXP (dest, 0)) == REG)
+	{
+	  dest = XEXP (dest, 0);
+	}
+      else if (GET_CODE (dest) == REG)
+	{
+	  ;			/* register */
+	}
+      else
+	return 1;
+    }
+
+  if (regno >= FIRST_PSEUDO_REGISTER || REGNO (areg) >= FIRST_PSEUDO_REGISTER)
+    return 1;
+
+  dst_reg = true_regnum (dest);
+  src_reg = true_regnum (areg);
+  if (dst_reg + 3 == src_reg)
+    return 1;
+  return 0;
+}
+
+
+/***************** ARITHMETIC *******************/
+
+int
+emit_indexed_arith (insn, operands, m, cmd, iscarry)
+     rtx insn;
+     rtx operands[];
+     int m;
+     const char *cmd;
+     int iscarry;
+{
+  char template[256];
+  register int i = 0;
+  char *p;
+  rtx reg = NULL;
+  int len = m * 2;
+  rtx x = operands[0];
+  int havestop = 0;
+  rtx pattern;
+  rtx next = next_real_insn (insn);
+
+
+  pattern = PATTERN (next);
+
+  if (pattern && GET_CODE (pattern) == PARALLEL)
+    {
+      pattern = XVECEXP (pattern, 0, 0);
+    }
+
+  if (followed_compare_condition (insn) != UNKNOWN
+      || (pattern
+	  && GET_CODE (pattern) == SET
+	  && SET_DEST (pattern) == cc0_rtx)
+      || (pattern && GET_CODE (pattern) == SET
+	  && SET_DEST (pattern) == pc_rtx))
+    {
+      /* very exotic case */
+
+      snprintf (template, 255, "%s\t" "%%A%d, %%A0", cmd, operands[2] ? 2 : 1);
+      output_asm_insn (template, operands);
+      snprintf (template, 255, "%s%s\t" "%%B%d, %%B0", cmd, iscarry ? "c" : "",
+		operands[2] ? 2 : 1);
+      output_asm_insn (template, operands);
+
+      if (m == 2)
+	return len;
+
+      snprintf (template, 255, "%s%s\t" "%%C%d, %%C0", cmd, iscarry ? "c" : "",
+		operands[2] ? 2 : 1);
+      output_asm_insn (template, operands);
+      snprintf (template, 255, "%s%s\t" "%%D%d, %%D0", cmd, iscarry ? "c" : "",
+		operands[2] ? 2 : 1);
+      output_asm_insn (template, operands);
+
+      return len;
+    }
+
+  if (operands[2])
+    reg = XEXP (operands[2], 0);
+  else
+    reg = XEXP (operands[1], 0);
+
+  if (GET_CODE (x) == REG)
+    {
+      int src;
+      int dst = REGNO (x);
+
+      if (!reg)
+	{
+	  reg = XEXP (operands[1], 0);
+	}
+
+      src = REGNO (reg);
+
+      /* check if registers overlap */
+      if (dst > src || (dst + m - 1) < src)
+	{
+	  ;			/* fine ! */
+	}
+      else if ((dst + m - 1) == src)
+	{
+	  havestop = 1;		/* worse */
+	}
+      else
+	{
+	  /* cannot do reverse assigment */
+	  while (i < m)
+	    {
+	      p = (char *) (template + strlen (cmd));
+	      p += (i && iscarry) ? 3 : 2;
+	      strcpy (template, cmd);
+	      strcat (template, (i && iscarry) ? "c\t%" : "\t%");
+	      *p = 'A' + i;
+	      p++;
+	      *p = 0;
+	      strcat (template, "0, %");
+	      p += 2;
+	      *p = 'A' + i;
+	      p++;
+	      *p = 0;
+	      strcat (template, operands[2] ? "2" : "1");
+	      output_asm_insn (template, operands);
+	      i++;
+	    }
+	  return m * 3;
+	}
+    }
+
+  while (i < (m - havestop))
+    {
+      p = template + strlen (cmd);
+
+      strcpy (template, cmd);
+
+      if (i && iscarry)
+	{
+	  strcat (template, "c\t");
+	  p += 2;
+	}
+      else
+	{
+	  strcat (template, "\t");
+	  p += 1;
+	}
+      strcat (template, operands[2] ? "@%E2+, %" : "@%E1+, %");
+      p += 8;
+      *p = 'A' + i;
+      p++;
+      *p = 0;
+      strcat (template, "0");
+      p++;
+      output_asm_insn (template, operands);
+      i++;
+    }
+
+  if (havestop)
+    {
+      len++;
+      p = template + strlen (cmd);
+      strcpy (template, cmd);
+      if (i && iscarry)
+	{
+	  strcat (template, "c\t");
+	  p += 2;
+	}
+      else
+	{
+	  strcat (template, "\t");
+	  p += 1;
+	}
+      strcat (template, operands[2] ? "@%E2, %" : "@%E1, %");
+      p += 8;
+      *p = 'A' + i;
+      p++;
+      *p = 0;
+      strcat (template, "0	;	register won't die");
+      p += 1;
+      output_asm_insn (template, operands);
+    }
+
+  if (!dead_or_set_p (insn, reg) && !havestop)
+    {
+      len++;
+      p = template + 3;
+      strcpy (template, "sub");
+      strcat (template, "\t#");
+      p += 2;
+      *p = '0' + m * 2;
+      p++;
+      *p = 0;
+
+      if (operands[2])
+	strcat (template, ",    %E2	;	restore %E2");
+      else
+	strcat (template, ",    %E1	;	restore %E1");
+      output_asm_insn (template, operands);
+    }
+
+  return len;
+}
+
+static int sameoperand_p PARAMS ((rtx, rtx));
+
+int
+sameoperand (operands, i)
+     rtx operands[];
+     int i;
+{
+  rtx dst = operands[0];
+  rtx src = operands[i];
+
+  return sameoperand_p (src, dst);
+}
+
+static int
+sameoperand_p (src, dst)
+     rtx src;
+     rtx dst;
+{
+  enum rtx_code scode = GET_CODE (src);
+  enum rtx_code dcode = GET_CODE (dst);
+  /* cannot use standard functions here 
+     cause operands have different modes:
+   */
+
+  if (scode != dcode)
+    return 0;
+
+  switch (scode)
+    {
+    case REG:
+      return REGNO (src) == REGNO (dst);
+      break;
+    case MEM:
+      return sameoperand_p (XEXP (src, 0), XEXP (dst, 0));
+      break;
+    case PLUS:
+      return sameoperand_p (XEXP (src, 0), XEXP (dst, 0))
+	  && sameoperand_p (XEXP (src, 1), XEXP (dst, 1));
+      break;
+    case CONST_INT:
+      return INTVAL (src) == INTVAL (dst);
+      break;
+    case SYMBOL_REF:
+      return XSTR (src, 0) == XSTR (dst, 0);
+      break;
+    default:
+      break;
+    }
+  return 0;
+
+}
+
+#define OUT_INSN(x,p,o) \
+do {                            \
+if(!x) output_asm_insn (p,o);   \
+} while(0)
+
+
+
+/************** MOV CODE *********************************/
+
+const char *
+movstrsi_insn (insn, operands, l)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+
+  /* operands 0 and 1 are registers !!! */
+  /* operand 2 is a cnt and not zero */
+  output_asm_insn ("\n.Lmsn%=:", operands);
+  output_asm_insn ("mov.b\t@%1+,0(%0)", operands);
+  output_asm_insn ("inc\t%0", operands);
+  output_asm_insn ("dec\t%2", operands);
+  output_asm_insn ("jnz\t.Lmsn%=", operands);
+
+  return "";
+}
+
+
+const char *
+clrstrsi_insn (insn, operands, l)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+
+  /* operand 0 is a register !!! */
+  /* operand 1 is a cnt and not zero */
+  output_asm_insn ("\n.Lcsn%=:", operands);
+  output_asm_insn ("clr.b\t0(%0)	;	clr does not support @rn+",
+		   operands);
+  output_asm_insn ("inc\t%0", operands);
+  output_asm_insn ("dec\t%1", operands);
+  output_asm_insn ("jnz\t.Lcsn%=", operands);
+  return "";
+}
+
+const char *
+movstrhi_insn (insn, operands, l)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+
+  /* operands 0 and 1 are registers !!! */
+  /* operand 2 is a cnt and not zero */
+  output_asm_insn ("\n.Lmsn%=:", operands);
+  output_asm_insn ("mov.b\t@%1+,0(%0)", operands);
+  output_asm_insn ("inc\t%0", operands);
+  output_asm_insn ("dec\t%2", operands);
+  output_asm_insn ("jnz\t.Lmsn%=", operands);
+  return "";
+}
+
+const char *
+clrstrhi_insn (insn, operands, l)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+
+  /* operand 0 is a register !!! */
+  /* operand 1 is a cnt and not zero */
+  output_asm_insn ("\n.Lcsn%=:", operands);
+  output_asm_insn ("clr.b\t0(%0)", operands);
+  output_asm_insn ("inc\t%0", operands);
+  output_asm_insn ("dec\t%1", operands);
+  output_asm_insn ("jnz\t.Lcsn%=", operands);
+  return "";
+}
+
+int
+msp430_emit_indexed_mov (insn, operands, m, cmd)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int m;
+     const char *cmd;
+{
+  char template[256];
+  register int i = 0;
+  char *p;
+  rtx reg = XEXP (operands[1], 0);
+  int len = m * 2;
+
+  while (i < m)
+    {
+      p = template + strlen (cmd);
+
+      strcpy (template, cmd);
+      strcat (template, "\t");
+      p += 1;
+      strcat (template, "@%E1+, %");
+      p += 8;
+      *p = 'A' + i;
+      p++;
+      *p = 0;
+      strcat (template, "0");
+      p += 1;
+      output_asm_insn (template, operands);
+      i++;
+    }
+
+  if (!dead_or_set_p (insn, reg))
+    {
+      len++;
+      p = template + 3;
+      strcpy (template, "sub");
+      strcat (template, "\t#");
+      p += 2;
+      *p = '0' + m * 2;
+      p++;
+      *p = 0;
+      strcat (template, ",    %E1	;	restore %E1");
+      output_asm_insn (template, operands);
+    }
+
+  return len;
+}
+
+const char *
+msp430_emit_indexed_mov2 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  msp430_emit_indexed_mov (insn, operands, 2, "mov");
+  return "";
+}
+
+const char *
+msp430_emit_indexed_mov4 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  msp430_emit_indexed_mov (insn, operands, 4, "mov");
+  return "";
+}
+
+const char *
+movsisf_regmode (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  rtx dest = operands[0];
+  rtx src = operands[1];
+  rtx areg = XEXP (src, 0);
+  int src_reg = true_regnum (areg);
+  int dst_reg = true_regnum (dest);
+
+
+  if (dst_reg > src_reg || dst_reg + 1 < src_reg)
+    {
+      output_asm_insn ("mov\t@%E1+, %A0", operands);
+      output_asm_insn ("mov\t@%E1+, %B0", operands);
+      if (!dead_or_set_p (insn, areg))
+	{
+	  output_asm_insn ("sub\t#4, %E1\t;\trestore %E1", operands);
+	}
+      return "";
+    }
+  else if (dst_reg + 1 == src_reg)
+    {
+      output_asm_insn ("mov\t@%E1+, %A0", operands);
+      output_asm_insn ("mov\t@%E1, %B0", operands);
+      return "";
+    }
+  else
+    {
+      /* destination overlaps with source.
+         so, update destination in reverse way */
+      output_asm_insn ("mov\t%B1, %B0", operands);
+      output_asm_insn ("mov\t@%E1, %A0", operands);
+    }
+
+  return "";			/* make compiler happy */
+}
+
+
+/* From Max Behensky <maxb@twinlanes.com>  
+   This function tells you what the index register in an operand is.  It
+   returns the register number, or -1 if it is not an indexed operand */
+static int get_indexed_reg PARAMS ((rtx));
+static int
+get_indexed_reg (x)
+     rtx x;
+{
+  int code;
+
+  code = GET_CODE (x);
+
+  if (code != MEM)
+    return (-1);
+
+  x = XEXP (x, 0);
+  code = GET_CODE (x);
+  if (code == REG)
+    return (REGNO (x));
+
+  if (code != PLUS)
+    return (-1);
+
+  x = XEXP (x, 0);
+  code = GET_CODE (x);
+  if (code != REG)
+    return (-1);
+
+  return (REGNO (x));
+}
+
+
+const char *
+msp430_movesi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+
+
+  if (memory_operand (op0, VOIDmode)
+      && memory_operand (op1, VOIDmode) && zero_shifted (op1))
+    {
+      if (!len)
+	msp430_emit_indexed_mov2 (insn, operands, NULL);
+      else
+	*len = 5;
+      return "";
+    }
+  else if (register_operand (op0, VOIDmode)
+	   && memory_operand (op1, VOIDmode) && zero_shifted (op1))
+    {
+      if (!len)
+	movsisf_regmode (insn, operands, NULL);
+      else
+	*len = 3;
+      return "";
+    }
+
+  if (!len)
+    {
+      if ((register_operand (op0, VOIDmode)
+	   && register_operand (op1, VOIDmode)
+	   && REGNO (op1) + 1 == REGNO (op0))
+	  || (register_operand (op0, VOIDmode)
+	      && memory_operand (op1, VOIDmode)
+	      && get_indexed_reg (op1) == true_regnum (op0)))
+	{
+	  output_asm_insn ("mov\t%B1, %B0", operands);
+	  output_asm_insn ("mov\t%A1, %A0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov\t%A1, %A0", operands);
+	  output_asm_insn ("mov\t%B1, %B0", operands);
+	}
+    }
+  else
+    {
+      *len = 2;			/* base length */
+
+      if (register_operand (op0, VOIDmode))
+	*len += 0;
+      else if (memory_operand (op0, VOIDmode))
+	*len += 2;
+
+      if (register_operand (op1, VOIDmode))
+	*len += 0;
+      else if (memory_operand (op1, VOIDmode))
+	*len += 2;
+      else if (immediate_operand (op1, VOIDmode))
+	*len += 2;
+    }
+
+  return "";
+}
+
+
+const char *
+movdidf_regmode (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  rtx dest = operands[0];
+  rtx src = operands[1];
+  rtx areg = XEXP (src, 0);
+
+  int src_reg = true_regnum (areg);
+  int dst_reg = true_regnum (dest);
+
+
+  if (dst_reg > src_reg || dst_reg + 3 < src_reg)
+    {
+      output_asm_insn ("mov\t@%E1+, %A0", operands);
+      output_asm_insn ("mov\t@%E1+, %B0", operands);
+      output_asm_insn ("mov\t@%E1+, %C0", operands);
+      output_asm_insn ("mov\t@%E1+, %D0", operands);
+      if (!dead_or_set_p (insn, areg))
+	{
+	  output_asm_insn ("sub\t#8, %E1\t;\trestore %E1", operands);
+	}
+    }
+  else if (dst_reg + 3 == src_reg)
+    {
+      output_asm_insn ("mov\t@%E1+, %A0", operands);
+      output_asm_insn ("mov\t@%E1+, %B0", operands);
+      output_asm_insn ("mov\t@%E1+, %C0", operands);
+      output_asm_insn ("mov\t@%E1,  %D0	;	%E1 == %D0", operands);
+    }
+  else
+    {
+      /* destination overlaps source.
+         so, update destination in reverse way */
+      output_asm_insn ("mov\t%D1, %D0	; %E1 overlaps wit one of %A0 - %D0",
+		       operands);
+      output_asm_insn ("mov\t%C1, %C0", operands);
+      output_asm_insn ("mov\t%B1, %B0", operands);
+      output_asm_insn ("mov\t@%E1, %A0", operands);
+    }
+
+  return "";
+}
+
+const char *
+msp430_movedi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+
+  if (memory_operand (op0, DImode)
+      && memory_operand (op1, DImode) && zero_shifted (op1))
+    {
+      if (!len)
+	msp430_emit_indexed_mov4 (insn, operands, NULL);
+      else
+	*len = 9;
+      return "";
+    }
+  else if (register_operand (op0, DImode)
+	   && memory_operand (op1, DImode) && zero_shifted (op1))
+    {
+      if (!len)
+	movdidf_regmode (insn, operands, NULL);
+      else
+	*len = 5;
+      return "";
+    }
+
+  if (!len)
+    {
+      if (register_operand (op0, SImode)
+	  && register_operand (op1, SImode) && REGNO (op1) + 3 == REGNO (op0))
+	{
+	  output_asm_insn ("mov\t%D1, %D0", operands);
+	  output_asm_insn ("mov\t%C1, %C0", operands);
+	  output_asm_insn ("mov\t%B1, %B0", operands);
+	  output_asm_insn ("mov\t%A1, %A0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("mov\t%A1, %A0", operands);
+	  output_asm_insn ("mov\t%B1, %B0", operands);
+	  output_asm_insn ("mov\t%C1, %C0", operands);
+	  output_asm_insn ("mov\t%D1, %D0", operands);
+	}
+    }
+  else
+    {
+      *len = 4;			/* base length */
+
+      if (register_operand (op0, DImode))
+	*len += 0;
+      else if (memory_operand (op0, DImode))
+	*len += 4;
+
+      if (register_operand (op1, DImode))
+	*len += 0;
+      else if (memory_operand (op1, DImode))
+	*len += 4;
+      else if (immediate_operand (op1, DImode))
+	*len += 4;
+    }
+
+  return "";
+}
+
+
+
+
+/**************	ADD CODE *********************************/
+
+
+const char *
+msp430_emit_indexed_add2 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 2, "add", 1);
+  return "";
+}
+
+const char *
+msp430_emit_indexed_add4 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 4, "add", 1);
+  return "";
+}
+
+const char *
+msp430_addsi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+  rtx ops[4];
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_add2 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, SImode))
+	    *len = 5;
+	  else if (register_operand (op0, SImode))
+	    *len = 3;
+	}
+      return "";
+    }
+  else if (memory_operand (op2, SImode)
+	   && zero_shifted (operands[2]) && regsi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("add\t@%E2+, %A0", operands);
+	  output_asm_insn ("addc\t@%E2+, %B0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, SImode))
+	    *len = 2;
+	  else if (memory_operand (op0, SImode))
+	    *len = 4;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  ops[0] = operands[0];
+  ops[2] = operands[2];
+
+  if (!len)
+    {
+      output_asm_insn ("add\t%A2, %A0", ops);
+      output_asm_insn ("addc\t%B2, %B0", ops);
+    }
+
+  if (len)
+    {
+      *len = 2;			/* base length */
+
+      if (register_operand (ops[0], SImode))
+	*len += 0;
+      else if (memory_operand (ops[0], SImode))
+	*len += 2;
+
+      if (register_operand (ops[2], SImode))
+	*len += 0;
+      else if (memory_operand (ops[2], SImode))
+	*len += 2;
+      else if (immediate_operand (ops[2], SImode))
+	{
+	  int x = INTVAL (ops[2]);
+	  if (x == -2 || x == -4 || x == -8)
+	    {
+	      *len += 1;
+	    }
+	  else
+	    *len += 2;
+	}
+    }
+  return "";
+}
+
+const char *
+msp430_adddi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (memory_operand (op2, DImode)
+      && zero_shifted (operands[2]) && regdi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_add4 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, DImode))
+	    *len = 9;
+	  else if (register_operand (op0, DImode))
+	    *len = 5;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, DImode)
+	   && zero_shifted (operands[2]) && regdi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("add\t@%E2+, %A0", operands);
+	  output_asm_insn ("addc\t@%E2+, %B0", operands);
+	  output_asm_insn ("addc\t@%E2+, %C0", operands);
+	  output_asm_insn ("addc\t@%E2+, %D0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, DImode))
+	    *len = 4;
+	  else if (memory_operand (op0, DImode))
+	    *len = 8;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("add\t%A2, %A0", operands);
+      output_asm_insn ("addc\t%B2, %B0", operands);
+      output_asm_insn ("addc\t%C2, %C0", operands);
+      output_asm_insn ("addc\t%D2, %D0", operands);
+    }
+  else
+    {
+      *len = 4;			/* base length */
+
+      if (register_operand (op0, DImode))
+	*len += 0;
+      else if (memory_operand (op0, DImode))
+	*len += 4;
+
+      if (register_operand (op2, DImode))
+	*len += 0;
+      else if (memory_operand (op2, DImode))
+	*len += 4;
+      else if (immediate_operand (op2, DImode))
+	{
+	  int x = INTVAL (op2);
+
+	  if (x == -2 || x == -4 || x == -8)
+	    *len += 0;
+	  else
+	    *len += 4;
+	}
+      else
+	abort ();
+    }
+
+  return "";
+}
+
+
+/**************	SUB CODE *********************************/
+
+const char *
+msp430_emit_indexed_sub2 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 2, "sub", 1);
+  return "";
+}
+
+const char *
+msp430_emit_indexed_sub4 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 4, "sub", 1);
+  return "";
+}
+
+const char *
+msp430_subsi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_sub2 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, SImode))
+	    *len = 5;
+	  else if (register_operand (op0, SImode))
+	    *len = 3;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, SImode)
+	   && zero_shifted (operands[2]) && regsi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("sub\t@%E2+, %A0", operands);
+	  output_asm_insn ("subc\t@%E2+, %B0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, SImode))
+	    *len = 2;
+	  else if (memory_operand (op0, SImode))
+	    *len = 4;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("sub\t%A2, %A0", operands);
+      output_asm_insn ("subc\t%B2, %B0", operands);
+    }
+  else
+    {
+      *len = 2;			/* base length */
+
+      if (register_operand (op0, SImode))
+	*len += 0;
+      else if (memory_operand (op0, SImode))
+	*len += 2;
+
+      if (register_operand (op2, SImode))
+	*len += 0;
+      else if (memory_operand (op2, SImode))
+	*len += 2;
+      else if (immediate_operand (op2, SImode))
+	*len += 2;
+    }
+
+  return "";
+}
+
+
+const char *
+msp430_subdi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (memory_operand (op2, DImode)
+      && zero_shifted (operands[2]) && regdi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_sub4 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, DImode))
+	    *len = 9;
+	  else if (register_operand (op0, DImode))
+	    *len = 5;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, DImode)
+	   && zero_shifted (operands[2]) && regdi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("sub\t@%E2+, %A0", operands);
+	  output_asm_insn ("subc\t@%E2+, %B0", operands);
+	  output_asm_insn ("subc\t@%E2+, %C0", operands);
+	  output_asm_insn ("subc\t@%E2+, %D0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, DImode))
+	    *len = 4;
+	  else if (memory_operand (op0, DImode))
+	    *len = 8;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("sub\t%A2, %A0", operands);
+      output_asm_insn ("subc\t%B2, %B0", operands);
+      output_asm_insn ("subc\t%C2, %C0", operands);
+      output_asm_insn ("subc\t%D2, %D0", operands);
+    }
+  else
+    {
+      *len = 4;			/* base length */
+
+      if (register_operand (op0, DImode))
+	*len += 0;
+      else if (memory_operand (op0, DImode))
+	*len += 4;
+
+      if (register_operand (op2, DImode))
+	*len += 0;
+      else if (memory_operand (op2, DImode))
+	*len += 4;
+      else if (immediate_operand (op2, DImode))
+	*len += 4;
+      else
+	abort ();
+    }
+
+  return "";
+}
+
+
+/**************	AND CODE *********************************/
+
+const char *
+msp430_emit_indexed_and2 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 2, "and", 0);
+  return "";
+}
+
+const char *
+msp430_emit_indexed_and4 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 4, "and", 0);
+  return "";
+}
+
+const char *
+msp430_emit_immediate_and2 (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int v;
+  int l = INTVAL (operands[2]);
+  int r = REG_P (operands[0]);
+  int list1 = ((~1) & 0xffff);
+  int list2 = ((~2) & 0xffff);
+  int list4 = ((~4) & 0xffff);
+  int list8 = ((~8) & 0xffff);
+
+  rtx op[4];
+
+  op[0] = operands[0];
+  op[1] = operands[1];
+  op[2] = operands[2];
+
+  /* check nibbles */
+
+  v = (l) & 0xffff;
+  if (v != 0xffff)
+    {
+      if (v == list1 || v == list2 || v == list4 || v == list8)
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, ~v);
+	  OUT_INSN (len, "bic\t%A2, %A0", op);
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	}
+      else
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, v);
+	  OUT_INSN (len, "and\t%A2, %A0", op);
+	  dummy++;
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	  if (v == 0 || v == 1 || v == 2 || v == 4 || v == 8)
+	    dummy--;
+	}
+    }
+
+  v = (l >> 16) & 0xffff;
+  if (v != 0xffff)
+    {
+      if (v == list1 || v == list2 || v == list4 || v == list8)
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, ~v);
+	  OUT_INSN (len, "bic\t%A2, %B0", op);
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	}
+      else
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, v);
+	  OUT_INSN (len, "and\t%A2, %B0", op);
+	  dummy++;
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	  if (v == 0 || v == 1 || v == 2 || v == 4 || v == 8)
+	    dummy--;
+	}
+    }
+
+  if (len)
+    *len = dummy;
+  return "";
+}
+
+const char *
+msp430_emit_immediate_and4 (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int v;
+  int l = CONST_DOUBLE_LOW (operands[2]);
+  int h = CONST_DOUBLE_HIGH (operands[2]);
+  int r = REG_P (operands[0]);
+  int list1 = ((~1) & 0xffff);
+  int list2 = ((~2) & 0xffff);
+  int list4 = ((~4) & 0xffff);
+  int list8 = ((~8) & 0xffff);
+  rtx op[4];
+
+  op[0] = operands[0];
+  op[1] = operands[1];
+  op[2] = operands[2];
+
+  /* check if operand 2 is really const_double */
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      l = INTVAL (operands[2]);
+      h = 0;
+    }
+
+  /* check nibbles */
+  v = (l) & 0xffff;
+  if (v != 0xffff)
+    {
+      if (v == list1 || v == list2 || v == list4 || v == list8)
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, ~v);
+	  OUT_INSN (len, "bic\t%A2, %A0", op);
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	}
+      else
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, v);
+	  OUT_INSN (len, "and\t%A2, %A0", op);
+	  dummy++;
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	  if (v == 0 || v == 1 || v == 2 || v == 4 || v == 8)
+	    dummy--;
+	}
+    }
+
+  v = (l >> 16) & 0xffff;
+  if (v != 0xffff)
+    {
+      if (v == list1 || v == list2 || v == list4 || v == list8)
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, ~v);
+	  OUT_INSN (len, "bic\t%A2, %B0", op);
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	}
+      else
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, v);
+	  OUT_INSN (len, "and\t%A2, %B0", op);
+	  dummy++;
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	  if (v == 0 || v == 1 || v == 2 || v == 4 || v == 8)
+	    dummy--;
+	}
+    }
+
+  v = (h) & 0xffff;
+  if (v != 0xffff)
+    {
+      if (v == list1 || v == list2 || v == list4 || v == list8)
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, ~v);
+	  OUT_INSN (len, "bic\t%A2, %C0", op);
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	}
+      else
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, v);
+	  OUT_INSN (len, "and\t%A2, %C0", op);
+	  dummy++;
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	  if (v == 0 || v == 1 || v == 2 || v == 4 || v == 8)
+	    dummy--;
+	}
+    }
+
+  v = (h >> 16) & 0xffff;
+  if (v != 0xffff)
+    {
+      if (v == list1 || v == list2 || v == list4 || v == list8)
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, ~v);
+	  OUT_INSN (len, "bic\t%A2, %D0", op);
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	}
+      else
+	{
+	  op[2] = gen_rtx_CONST_INT (SImode, v);
+	  OUT_INSN (len, "and\t%A2, %D0", op);
+	  dummy++;
+	  dummy++;
+	  if (!r)
+	    dummy++;
+	  if (v == 0 || v == 1 || v == 2 || v == 4 || v == 8)
+	    dummy--;
+	}
+    }
+
+  if (len)
+    *len = dummy;
+  return "";
+}
+
+const char *
+msp430_andsi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (nonimmediate_operand (op0, SImode) && immediate_operand (op2, SImode))
+    {
+      if (!len)
+	msp430_emit_immediate_and2 (insn, operands, NULL);
+      return "";
+    }
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_and2 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, SImode))
+	    *len = 5;
+	  else if (register_operand (op0, SImode))
+	    *len = 3;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, SImode)
+	   && zero_shifted (operands[2]) && regsi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("and\t@%E2+, %A0", operands);
+	  output_asm_insn ("and\t@%E2+, %B0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, SImode))
+	    *len = 2;
+	  else if (memory_operand (op0, SImode))
+	    *len = 4;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("and\t%A2, %A0", operands);
+      output_asm_insn ("and\t%B2, %B0", operands);
+    }
+  else
+    {
+      *len = 2;			/* base length */
+
+      if (register_operand (op0, SImode))
+	*len += 0;
+      else if (memory_operand (op0, SImode))
+	*len += 2;
+
+      if (register_operand (op2, SImode))
+	*len += 0;
+      else if (memory_operand (op2, SImode))
+	*len += 2;
+      else if (immediate_operand (op2, SImode))
+	*len += 2;
+    }
+
+  return "";
+}
+
+
+const char *
+msp430_anddi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (nonimmediate_operand (op0, DImode) && immediate_operand (op2, DImode))
+    {
+      if (!len)
+	msp430_emit_immediate_and4 (insn, operands, NULL);
+      return "";
+    }
+
+  if (memory_operand (op2, DImode)
+      && zero_shifted (operands[2]) && regdi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_and4 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, DImode))
+	    *len = 9;
+	  else if (register_operand (op0, DImode))
+	    *len = 5;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, DImode)
+	   && zero_shifted (operands[2]) && regdi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("and\t@%E2+, %A0", operands);
+	  output_asm_insn ("and\t@%E2+, %B0", operands);
+	  output_asm_insn ("and\t@%E2+, %C0", operands);
+	  output_asm_insn ("and\t@%E2+, %D0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, DImode))
+	    *len = 4;
+	  else if (memory_operand (op0, DImode))
+	    *len = 8;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("and\t%A2, %A0", operands);
+      output_asm_insn ("and\t%B2, %B0", operands);
+      output_asm_insn ("and\t%C2, %C0", operands);
+      output_asm_insn ("and\t%D2, %D0", operands);
+    }
+  else
+    {
+      *len = 4;			/* base length */
+
+      if (register_operand (op0, DImode))
+	*len += 0;
+      else if (memory_operand (op0, DImode))
+	*len += 4;
+
+      if (register_operand (op2, DImode))
+	*len += 0;
+      else if (memory_operand (op2, DImode))
+	*len += 4;
+      else if (immediate_operand (op2, DImode))
+	*len += 4;
+      else
+	abort ();
+    }
+
+  return "";
+}
+
+/**************	IOR CODE *********************************/
+
+const char *
+msp430_emit_indexed_ior2 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 2, "bis", 0);
+  return "";
+}
+
+const char *
+msp430_emit_indexed_ior4 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  emit_indexed_arith (insn, operands, 4, "bis", 0);
+  return "";
+}
+
+const char *
+msp430_emit_immediate_ior2 (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int l = INTVAL (operands[2]);
+  int r = REG_P (operands[0]);
+  int v;
+
+
+  v = l & 0xffff;
+
+  if (v)
+    {
+      OUT_INSN (len, "bis\t%A2,%A0", operands);
+      dummy++;
+      dummy++;
+      if (v == 0xffff || v == 1 || v == 2 || v == 4 || v == 8)
+	dummy--;
+      if (!r)
+	dummy++;
+    }
+
+  v = (l >> 16) & 0xffff;
+
+  if (v)
+    {
+      OUT_INSN (len, "bis\t%B2,%B0", operands);
+      dummy++;
+      dummy++;
+      if (v == 0xffff || v == 1 || v == 2 || v == 4 || v == 8)
+	dummy--;
+      if (!r)
+	dummy++;
+    }
+
+  if (len)
+    *len = dummy;
+  return "";
+}
+
+const char *
+msp430_emit_immediate_ior4 (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int l = CONST_DOUBLE_LOW (operands[2]);
+  int h = CONST_DOUBLE_HIGH (operands[2]);
+  int r = REG_P (operands[0]);
+  int v;
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      l = INTVAL (operands[2]);
+      h = 0;
+    }
+
+  v = l & 0xffff;
+
+  if (v)
+    {
+      OUT_INSN (len, "bis\t%A2,%A0", operands);
+      dummy++;
+      dummy++;
+      if (v == 0xffff || v == 1 || v == 2 || v == 4 || v == 8)
+	dummy--;
+      if (!r)
+	dummy++;
+    }
+
+  v = (l >> 16) & 0xffff;
+
+  if (v)
+    {
+      OUT_INSN (len, "bis\t%B2,%B0", operands);
+      dummy++;
+      dummy++;
+      if (v == 0xffff || v == 1 || v == 2 || v == 4 || v == 8)
+	dummy--;
+      if (!r)
+	dummy++;
+    }
+
+  l = h;
+  v = l & 0xffff;
+
+  if (v)
+    {
+      OUT_INSN (len, "bis\t%C2,%C0", operands);
+      dummy++;
+      dummy++;
+      if (v == 0xffff || v == 1 || v == 2 || v == 4 || v == 8)
+	dummy--;
+      if (!r)
+	dummy++;
+    }
+
+  v = (l >> 16) & 0xffff;
+
+  if (v)
+    {
+      OUT_INSN (len, "bis\t%D2,%D0", operands);
+      dummy++;
+      dummy++;
+      if (v == 0xffff || v == 1 || v == 2 || v == 4 || v == 8)
+	dummy--;
+      if (!r)
+	dummy++;
+    }
+
+  if (len)
+    *len = dummy;
+  return "";
+}
+
+const char *
+msp430_iorsi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (nonimmediate_operand (op0, SImode) && immediate_operand (op2, SImode))
+    {
+      if (!len)
+	msp430_emit_immediate_ior2 (insn, operands, NULL);
+      return "";
+    }
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_ior2 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, SImode))
+	    *len = 5;
+	  else if (register_operand (op0, SImode))
+	    *len = 3;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, SImode)
+	   && zero_shifted (operands[2]) && regsi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("bis\t@%E2+, %A0", operands);
+	  output_asm_insn ("bis\t@%E2+, %B0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, SImode))
+	    *len = 2;
+	  else if (memory_operand (op0, SImode))
+	    *len = 4;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("bis\t%A2, %A0", operands);
+      output_asm_insn ("bis\t%B2, %B0", operands);
+    }
+  else
+    {
+      *len = 2;			/* base length */
+
+      if (register_operand (op0, SImode))
+	*len += 0;
+      else if (memory_operand (op0, SImode))
+	*len += 2;
+
+      if (register_operand (op2, SImode))
+	*len += 0;
+      else if (memory_operand (op2, SImode))
+	*len += 2;
+      else if (immediate_operand (op2, SImode))
+	*len += 2;
+    }
+
+  return "";
+}
+
+const char *
+msp430_iordi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (nonimmediate_operand (op0, DImode) && immediate_operand (op2, DImode))
+    {
+      if (!len)
+	msp430_emit_immediate_ior4 (insn, operands, NULL);
+      return "";
+    }
+
+  if (memory_operand (op2, DImode)
+      && zero_shifted (operands[2]) && regdi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_ior4 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, DImode))
+	    *len = 9;
+	  else if (register_operand (op0, DImode))
+	    *len = 5;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, DImode)
+	   && zero_shifted (operands[2]) && regdi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("bis\t@%E2+, %A0", operands);
+	  output_asm_insn ("bis\t@%E2+, %B0", operands);
+	  output_asm_insn ("bis\t@%E2+, %C0", operands);
+	  output_asm_insn ("bis\t@%E2+, %D0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, DImode))
+	    *len = 4;
+	  else if (memory_operand (op0, DImode))
+	    *len = 8;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("bis\t%A2, %A0", operands);
+      output_asm_insn ("bis\t%B2, %B0", operands);
+      output_asm_insn ("bis\t%C2, %C0", operands);
+      output_asm_insn ("bis\t%D2, %D0", operands);
+    }
+  else
+    {
+      *len = 4;			/* base length */
+
+      if (register_operand (op0, DImode))
+	*len += 0;
+      else if (memory_operand (op0, DImode))
+	*len += 4;
+
+      if (register_operand (op2, DImode))
+	*len += 0;
+      else if (memory_operand (op2, DImode))
+	*len += 4;
+      else if (immediate_operand (op2, DImode))
+	*len += 4;
+      else
+	abort ();
+    }
+
+  return "";
+}
+
+
+/************************* XOR CODE *****************/
+
+const char *
+msp430_emit_indexed_xor2 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l;
+{
+  int dummy = emit_indexed_arith (insn, operands, 2, "xor", 0);
+  if (!l)
+    l = &dummy;
+  *l = dummy;
+  return "";
+}
+
+const char *
+msp430_emit_indexed_xor4 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l;
+{
+  int dummy = emit_indexed_arith (insn, operands, 4, "xor", 0);
+  if (!l)
+    l = &dummy;
+  *l = dummy;
+  return "";
+}
+
+
+const char *
+msp430_emit_indexed_xor2_3 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l;
+{
+  int dummy;
+  rtx x = operands[2];
+  if (zero_shifted (x))
+    {
+      dummy = emit_indexed_arith (insn, operands, 2, "xor", 0);
+    }
+  else
+    {
+      dummy = 6;
+      output_asm_insn ("xor\t%A2, %A0", operands);
+      output_asm_insn ("xor\t%B2, %B0", operands);
+    }
+
+  if (!l)
+    l = &dummy;
+  *l = dummy;
+  return "";
+}
+
+const char *
+msp430_emit_indexed_xor4_3 (insn, operands, l)
+     rtx insn;
+     rtx operands[];
+     int *l;
+{
+
+  int dummy;
+  rtx x = operands[2];
+  if (zero_shifted (x))
+    {
+      dummy = emit_indexed_arith (insn, operands, 4, "xor", 0);
+    }
+  else
+    {
+      dummy = 8;
+      output_asm_insn ("xor\t%A2, %A0", operands);
+      output_asm_insn ("xor\t%B2, %B0", operands);
+      output_asm_insn ("xor\t%C2, %C0", operands);
+      output_asm_insn ("xor\t%D2, %D0", operands);
+    }
+
+  if (!l)
+    l = &dummy;
+  *l = dummy;
+  return "";
+}
+
+const char *
+msp430_xorsi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (memory_operand (op2, SImode)
+      && zero_shifted (operands[2]) && regsi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_xor2 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, SImode))
+	    *len = 5;
+	  else if (register_operand (op0, SImode))
+	    *len = 3;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, SImode)
+	   && zero_shifted (operands[2]) && regsi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("xor\t@%E2+, %A0", operands);
+	  output_asm_insn ("xor\t@%E2+, %B0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, SImode))
+	    *len = 2;
+	  else if (memory_operand (op0, SImode))
+	    *len = 4;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+
+      if (immediate_operand (op2, SImode))
+	{
+	  if (INTVAL (op2) & 0xfffful)
+	    output_asm_insn ("xor\t%A2, %A0", operands);
+
+	  if (INTVAL (op2) & 0xffff0000ul)
+	    output_asm_insn ("xor\t%B2, %B0", operands);
+	}
+      else
+	{
+	  output_asm_insn ("xor\t%A2, %A0", operands);
+	  output_asm_insn ("xor\t%B2, %B0", operands);
+	}
+
+    }
+  else
+    {
+      *len = 2;			/* base length */
+
+      if (register_operand (op0, SImode))
+	*len += 0;
+      else if (memory_operand (op0, SImode))
+	*len += 2;
+
+      if (register_operand (op2, SImode))
+	*len += 0;
+      else if (memory_operand (op2, SImode))
+	*len += 2;
+      else if (immediate_operand (op2, SImode))
+	{
+	  if (INTVAL (op2) & 0xfffful)
+	    *len += 1;
+	  if (INTVAL (op2) & 0xffff0000ul)
+	    *len += 1;
+	}
+    }
+
+  return "";
+}
+
+const char *
+msp430_xordi_code (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx op0 = operands[0];
+  rtx op2 = operands[2];
+
+  if (memory_operand (op2, DImode)
+      && zero_shifted (operands[2]) && regdi_ok_safe (operands))
+    {
+      if (!len)
+	msp430_emit_indexed_xor4 (insn, operands, NULL);
+      else
+	{
+	  if (memory_operand (op0, DImode))
+	    *len = 9;
+	  else if (register_operand (op0, DImode))
+	    *len = 5;
+	}
+
+      return "";
+    }
+  else if (memory_operand (op2, DImode)
+	   && zero_shifted (operands[2]) && regdi_ok_clobber (operands))
+    {
+      if (!len)
+	{
+	  output_asm_insn ("xor\t@%E2+, %A0", operands);
+	  output_asm_insn ("xor\t@%E2+, %B0", operands);
+	  output_asm_insn ("xor\t@%E2+, %C0", operands);
+	  output_asm_insn ("xor\t@%E2+, %D0", operands);
+	}
+      else
+	{
+	  if (register_operand (op0, DImode))
+	    *len = 4;
+	  else if (memory_operand (op0, DImode))
+	    *len = 8;
+	  else
+	    abort ();
+	}
+      return "";
+    }
+
+  if (!len)
+    {
+      output_asm_insn ("xor\t%A2, %A0", operands);
+      output_asm_insn ("xor\t%B2, %B0", operands);
+      output_asm_insn ("xor\t%C2, %C0", operands);
+      output_asm_insn ("xor\t%D2, %D0", operands);
+    }
+  else
+    {
+      *len = 4;			/* base length */
+
+      if (register_operand (op0, DImode))
+	*len += 0;
+      else if (memory_operand (op0, DImode))
+	*len += 4;
+
+      if (register_operand (op2, DImode))
+	*len += 0;
+      else if (memory_operand (op2, DImode))
+	*len += 4;
+      else if (immediate_operand (op2, DImode))
+	*len += 4;
+      else
+	abort ();
+    }
+
+  return "";
+}
+
+
+/********* ABS CODE ***************************************/
+const char *
+msp430_emit_abssi (insn, operands, l)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  output_asm_insn ("tst\t%B0", operands);
+  output_asm_insn ("jge\t.Laes%=", operands);
+  output_asm_insn ("inv\t%A0", operands);
+  output_asm_insn ("inv\t%B0", operands);
+  output_asm_insn ("inc\t%A0", operands);
+  output_asm_insn ("adc\t%B0", operands);
+  output_asm_insn (".Laes%=:", operands);
+  return "";
+}
+
+const char *
+msp430_emit_absdi (insn, operands, l)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *l ATTRIBUTE_UNUSED;
+{
+  output_asm_insn ("tst\t%D0", operands);
+  output_asm_insn ("jge\t.Laed%=", operands);
+  output_asm_insn ("inv\t%A0", operands);
+  output_asm_insn ("inv\t%B0", operands);
+  output_asm_insn ("inv\t%C0", operands);
+  output_asm_insn ("inv\t%D0", operands);
+  output_asm_insn ("inc\t%A0", operands);
+  output_asm_insn ("adc\t%B0", operands);
+  output_asm_insn ("adc\t%C0", operands);
+  output_asm_insn ("adc\t%D0", operands);
+  output_asm_insn (".Laed%=:", operands);
+  return "";
+}
+
+
+/***** SIGN EXTEND *********/
+const char *
+signextendqihi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov.b\t%A1, %A0", operands);
+      dummy = 3;
+      if (indexed_location (operands[1]))
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  OUT_INSN (len, "sxt\t%A0", operands);
+  dummy += 2;
+
+  if (zs || GET_CODE (operands[0]) == REG)
+    dummy -= 1;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+signextendqisi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov.b\t%A1, %A0", operands);
+      dummy = 3;
+      if (indexed_location (operands[1]))
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  OUT_INSN (len, "sxt\t%A0", operands);
+  OUT_INSN (len, "mov\t%A0, %B0", operands);
+  OUT_INSN (len, "rla\t%B0", operands);
+  OUT_INSN (len, "subc\t%B0, %B0", operands);
+  OUT_INSN (len, "inv\t%B0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy += 5;
+  else if (zs)
+    dummy += 10;
+  else
+    dummy += 12;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+signextendqidi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov.b\t%A1, %A0", operands);
+      dummy = 3;
+      if (indexed_location (operands[1]))
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  OUT_INSN (len, "sxt\t%A0", operands);
+  OUT_INSN (len, "mov\t%A0, %B0", operands);
+  OUT_INSN (len, "rla\t%B0", operands);
+  OUT_INSN (len, "subc\t%B0, %B0", operands);
+  OUT_INSN (len, "inv\t%B0", operands);
+  OUT_INSN (len, "mov\t%B0, %C0", operands);
+  OUT_INSN (len, "mov\t%C0, %D0", operands);
+
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy += 7;
+  else if (zs)
+    dummy += 16;
+  else
+    dummy += 18;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+signextendhisi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov\t%A1, %A0", operands);
+      dummy = 3;
+      if (indexed_location (operands[1]))
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  OUT_INSN (len, "mov\t%A0, %B0", operands);
+  OUT_INSN (len, "rla\t%B0", operands);
+  OUT_INSN (len, "subc\t%B0, %B0", operands);
+  OUT_INSN (len, "inv\t%B0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy += 4;
+  else if (zs)
+    dummy += 9;
+  else
+    dummy += 11;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+signextendhidi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov\t%A1, %A0", operands);
+      dummy = 3;
+      if (indexed_location (operands[1]))
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  OUT_INSN (len, "mov\t%A0, %B0", operands);
+  OUT_INSN (len, "rla\t%B0", operands);
+  OUT_INSN (len, "subc\t%B0, %B0", operands);
+  OUT_INSN (len, "inv\t%B0", operands);
+  OUT_INSN (len, "mov\t%B0, %C0", operands);
+  OUT_INSN (len, "mov\t%C0, %D0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy += 6;
+  else if (zs)
+    dummy += 13;
+  else
+    dummy += 14;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+signextendsidi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov\t%A1, %A0", operands);
+      OUT_INSN (len, "mov\t%B1, %B0", operands);
+      dummy = 6;
+      if (indexed_location (operands[1]))
+	dummy = 4;
+      if (GET_CODE (operands[0]) == REG)
+	dummy -= 2;
+      if (GET_CODE (operands[1]) == REG)
+	dummy -= 2;
+    }
+
+  OUT_INSN (len, "mov\t%B0, %C0", operands);
+  OUT_INSN (len, "rla\t%C0", operands);
+  OUT_INSN (len, "subc\t%C0, %C0", operands);
+  OUT_INSN (len, "inv\t%C0", operands);
+  OUT_INSN (len, "mov\t%C0, %D0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy += 5;
+  else
+    dummy += 13;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+
+/**** ZERO EXTEND *****/
+
+const char *
+zeroextendqihi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[1]) || indexed_location (operands[1]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov.b\t%A1, %A0", operands);
+      dummy = 3;
+      if (zs)
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  if (!REG_P (operands[0]))
+    {
+      OUT_INSN (len, "clr.b\t%J0", operands);
+      dummy += 2;
+    }
+  else if (sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "and.b\t#-1,%0", operands);
+      dummy++;
+    }
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+zeroextendqisi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[1]) || indexed_location (operands[1]);
+
+  if (!sameoperand (operands, 1) || REG_P (operands[0]))
+    {
+      OUT_INSN (len, "mov.b\t%A1, %A0", operands);
+      dummy = 3;
+      if (zs)
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+
+  if (!REG_P (operands[0]))
+    {
+      OUT_INSN (len, "clr.b\t%J0", operands);
+    }
+  else if (sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "and.b\t#-1,%0", operands);
+      dummy++;
+    }
+  OUT_INSN (len, "clr\t%B0", operands);
+  dummy += 2;
+  if (GET_CODE (operands[0]) == REG)
+    dummy--;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+
+const char *
+zeroextendqidi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[1]) || indexed_location (operands[1]);
+
+  if (!sameoperand (operands, 1) || REG_P (operands[0]))
+    {
+      OUT_INSN (len, "mov.b\t%A1, %A0", operands);
+      dummy = 3;
+      if (zs)
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  if (!REG_P (operands[0]))
+    {
+      OUT_INSN (len, "clr.b\t%J0", operands);
+      dummy += 2;
+    }
+  else if (sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "and.b\t#-1,%0", operands);
+      dummy++;
+    }
+  dummy += 6;
+  OUT_INSN (len, "clr\t%B0", operands);
+  OUT_INSN (len, "clr\t%C0", operands);
+  OUT_INSN (len, "clr\t%D0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy -= 3;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+zeroextendhisi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[1]) || indexed_location (operands[1]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov\t%A1, %A0", operands);
+      dummy = 3;
+      if (zs)
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  OUT_INSN (len, "clr\t%B0", operands);
+  dummy += 2;
+  if (GET_CODE (operands[0]) == REG)
+    dummy--;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+
+}
+
+const char *
+zeroextendhidi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[1]) || indexed_location (operands[1]);
+
+  if (!sameoperand (operands, 1))
+    {
+      OUT_INSN (len, "mov\t%A1, %A0", operands);
+      dummy = 3;
+      if (zs)
+	dummy = 2;
+      if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      if (GET_CODE (operands[1]) == REG)
+	dummy--;
+    }
+
+  dummy += 6;
+  OUT_INSN (len, "clr\t%B0", operands);
+  OUT_INSN (len, "clr\t%C0", operands);
+  OUT_INSN (len, "clr\t%D0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy -= 3;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+const char *
+zeroextendsidi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+
+  if (!sameoperand (operands, 1))
+    {
+      if (zero_shifted (operands[1]))
+	{
+	  rtx reg = XEXP (operands[1], 0);
+
+	  OUT_INSN (len, "mov\t@%E1+, %A0", operands);
+	  OUT_INSN (len, "mov\t@%E1+, %B0", operands);
+	  dummy = 4;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy -= 2;
+
+	  if (!dead_or_set_p (insn, reg))
+	    {
+	      OUT_INSN (len, "sub\t#4, %E1", operands);
+	      dummy += 1;
+	    }
+	}
+      else
+	{
+	  OUT_INSN (len, "mov\t%A1, %A0", operands);
+	  OUT_INSN (len, "mov\t%B1, %B0", operands);
+	  dummy = 6;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy -= 2;
+	  if (GET_CODE (operands[1]) == REG)
+	    dummy -= 2;
+	  if (indexed_location (operands[1]))
+	    dummy--;
+	}
+    }
+
+  dummy += 4;
+  OUT_INSN (len, "clr\t%C0", operands);
+  OUT_INSN (len, "clr\t%D0", operands);
+
+  if (GET_CODE (operands[0]) == REG)
+    dummy -= 2;
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+/******************* TESTS AND JUMPS *********************/
+
+RTX_CODE
+msp430_canonicalize_comparison (code, op0, op1)
+     RTX_CODE code;
+     rtx *op0;
+     rtx *op1;
+{
+  RTX_CODE rc = code;
+
+  if ( CONSTANT_P(*op1) ) 
+    {
+      ;				/* nothing to be done */
+    }
+  else
+    {
+      switch (code)
+	{
+	case GT:
+	case LE:
+	case GTU:
+	case LEU:
+	  {
+	    rtx x;
+	    rc = swap_condition (code);
+	    x = *op0;
+	    *op0 = *op1;
+	    *op1 = x;
+	  }
+	  break;
+	default:
+	  break;
+	}
+    }
+  return rc;
+}
+
+
+void
+msp430_emit_cbranch (code, loc)
+     enum rtx_code code;
+     rtx loc;
+{
+  rtx op0 = msp430_compare_op0;
+  rtx op1 = msp430_compare_op1;
+  rtx condition_rtx, loc_ref, branch;
+  enum machine_mode mode;
+
+  if (!msp430_compare_op0 && !msp430_compare_op1)
+    {
+      /* this is a branch upon previous insn issued */
+      loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);
+      condition_rtx = gen_rtx (code, VOIDmode, cc0_rtx, const0_rtx);
+
+      branch = gen_rtx_SET (VOIDmode,
+			    pc_rtx,
+			    gen_rtx_IF_THEN_ELSE (VOIDmode,
+						  condition_rtx,
+						  loc_ref, pc_rtx));
+      emit_jump_insn (branch);
+      return;
+    }
+
+  mode = GET_MODE (op0);
+  if (mode != SImode && mode != HImode && mode != QImode)
+    abort ();
+
+
+  /* now convert codes */
+  code = msp430_canonicalize_comparison (code, &op0, &op1);
+
+  /* for HI and QI modes everything is simple.
+     Also, if code is eq or ne in SI mode, no clobbers required. */
+
+  if (mode == SImode && !(code == EQ || code == NE))
+    {
+      /* check if only high nibbles required */
+      if (GET_CODE (op1) == CONST_INT
+	  && INTVAL (op1) == 0 && (code == LT || code == GE))
+	{
+	  op0 = gen_highpart (HImode, op0);
+	  mode = HImode;
+	  PUT_MODE (op1, VOIDmode);	/* paranoia ? */
+	}
+      else if (GET_CODE (op1) == CONST_INT
+	       && ((INTVAL (op1) + 1) & 0xffff) == 0
+	       && (code == GT || code == GTU || code == LE || code == LEU))
+	{
+	  /* check if this can be done simple. 
+	     we will not clobber const operand. */
+	  int x = INTVAL (op1);
+	  x++;
+	  x >>= 16;
+	  op0 = gen_highpart (HImode, op0);
+
+	  mode = HImode;
+	  op1 = GEN_INT (trunc_int_for_mode (x, HImode));
+
+	  if (code == GT)
+	    code = GE;
+	  else if (code == GTU)
+	    code = GEU;
+	  else if (code == LEU)
+	    code = LTU;
+	  else if (code == LE)
+	    code = LT;
+	}
+      else
+	{
+	  rtvec vec;
+	  /* the redudant move will be deleted */
+	  op0 = copy_to_mode_reg (SImode, op0);
+	  condition_rtx = gen_rtx (code, mode, op0, op1);
+	  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);
+	  branch = gen_rtx_SET (VOIDmode, pc_rtx,
+				gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,
+						      loc_ref, pc_rtx));
+	  vec = gen_rtvec (2, branch, gen_rtx_CLOBBER (SImode, op0));
+	  emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, vec));
+	  msp430_compare_op0 = 0;
+	  msp430_compare_op1 = 0;
+	  return;
+	}
+    }
+  else if (mode == SImode && code == NE
+	   && GET_CODE (op1) != CONST_INT && op1 != const0_rtx)
+    {
+      rtx op0lo = gen_lowpart (HImode, op0);
+      rtx op0hi = gen_highpart (HImode, op0);
+      rtx op1lo = gen_lowpart (HImode, op1);
+      rtx op1hi = gen_highpart (HImode, op1);
+
+      condition_rtx = gen_rtx (NE, HImode, op0lo, op1lo);
+      loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);
+      branch = gen_rtx_SET (VOIDmode, pc_rtx,
+			    gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,
+						  loc_ref, pc_rtx));
+      emit_jump_insn (branch);
+      condition_rtx = gen_rtx (NE, HImode, op0hi, op1hi);
+      branch = gen_rtx_SET (VOIDmode, pc_rtx,
+			    gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,
+						  loc_ref, pc_rtx));
+      emit_jump_insn (branch);
+      msp430_compare_op0 = 0;
+      msp430_compare_op1 = 0;
+      return;
+    }
+  else if (mode == SImode && code == EQ && GET_CODE (op1) != CONST_INT)
+    {
+      rtx op0lo = gen_lowpart (HImode, op0);
+      rtx op0hi = gen_highpart (HImode, op0);
+      rtx op1lo = gen_lowpart (HImode, op1);
+      rtx op1hi = gen_highpart (HImode, op1);
+      rtx tlabel = gen_label_rtx ();
+      rtx tloc_ref;
+
+      condition_rtx = gen_rtx (NE, HImode, op0lo, op1lo);
+      tloc_ref = gen_rtx_LABEL_REF (VOIDmode, tlabel);
+      branch = gen_rtx_SET (VOIDmode, pc_rtx,
+			    gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,
+						  tloc_ref, pc_rtx));
+      emit_jump_insn (branch);
+
+      condition_rtx = gen_rtx (EQ, HImode, op0hi, op1hi);
+      loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);
+      branch = gen_rtx_SET (VOIDmode, pc_rtx,
+			    gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,
+						  loc_ref, pc_rtx));
+      emit_jump_insn (branch);
+      emit_label (tlabel);
+      msp430_compare_op0 = 0;
+      msp430_compare_op1 = 0;
+      return;
+    }
+
+  condition_rtx = gen_rtx (code, mode, op0, op1);
+  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);
+  branch = gen_rtx_SET (VOIDmode, pc_rtx,
+			gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,
+					      loc_ref, pc_rtx));
+
+  emit_jump_insn (branch);
+
+  msp430_compare_op0 = 0;
+  msp430_compare_op1 = 0;
+  return;
+}
+
+/*  x - dst
+    y - src */
+static int
+msp430_cc_source (insn, code, x, y)
+     rtx insn;
+     enum rtx_code code ATTRIBUTE_UNUSED;
+     rtx x;
+     rtx y;
+{
+  rtx prev = insn;
+  enum attr_cc cc;
+  rtx set;
+  rtx src, dst;
+
+
+  while (0 != (prev = PREV_INSN (prev)))
+    {
+      if (GET_CODE (prev) == CODE_LABEL
+	  || GET_CODE (prev) == BARRIER || GET_CODE (prev) == CALL_INSN)
+	return 0;
+
+      if (GET_CODE (prev) == INSN)
+	{
+	  set = single_set (prev);
+	  
+	  if(!set)
+	    return 0;
+
+	  cc = get_attr_cc (prev);
+
+	  if (cc == CC_NONE)	/* does not change CC */
+	    {
+	      dst = SET_DEST (set);
+	      if(dst && rtx_equal_p (x, dst))
+		return 0;
+	      else
+		continue;
+	    }
+
+	  if (cc == CC_CLOBBER)	/* clobber */
+	    return 0;
+
+	  if (cc == CC_OPER)	/* post-incremental stuff */
+	    {
+	      src = SET_SRC (set);
+	      if (GET_CODE (set) == IOR)	/* does not change CC */
+		{
+		  dst = SET_DEST (set);
+		  if(dst && rtx_equal_p (x, dst))
+		    return 0;
+		  else
+		    continue;
+		}
+	    }
+
+	  /* all other attributes are bit messy.
+	     So, we'll record destination and check if
+	     this matches 'x' and compare is against zero */
+	  dst = SET_DEST (set);
+	  if (rtx_equal_p (x, dst) && rtx_equal_p (y, const0_rtx))
+	    return 1;
+	  else
+	    return 0;
+	}
+      else if (GET_CODE (prev) == JUMP_INSN)
+	{
+#if 0
+	  set = single_set (prev);
+	  cc = get_attr_cc (prev);
+
+	  if (cc == CC_CBRANCH)
+	    {
+	      rtx t = XEXP (SET_SRC (set), 0);
+	      src = XEXP (t, 1);
+	      dst = XEXP (t, 0);
+
+	      if (rtx_equal_p (x, dst) && rtx_equal_p (y, src))
+		return 1;	/* both operands must be equial */
+	      else
+		return 0;
+	    }
+	  else
+#endif
+	    return 0;		/* is not valid branch insn */
+	}
+    }
+  return 0;
+}
+
+const char *
+msp430_cbranch (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  rtx ops[3];
+  enum rtx_code code;
+  rtx loc = operands[0];
+  int dummy = 0;
+  enum machine_mode mode;
+  int quater = 0;
+  int distance = msp430_jump_dist (loc, insn);
+  int predist; // = get_attr_length (insn);
+  rtx labels[4];
+  int nooverflow = 0;
+  
+  labels[0] = operands[0];
+
+#define ECOND(f,x) do{if(!len)msp430_emit_b##f(labels,predist + x);dummy+=(predist + x);}while(0)
+
+  ops[0] = operands[2];
+  ops[1] = operands[3];
+
+  mode = HImode;
+
+  if (ops[1] && ops[0])
+    {
+      mode = GET_MODE (operands[2]);
+      code = GET_CODE (operands[1]);
+      quater = (mode == QImode);
+    }
+  else
+    {
+      code = GET_CODE (operands[1]);
+    }
+
+  /* here check wiered conditions */
+  if (ops[1] && GET_CODE (ops[1]) == CONST_INT
+      && (code == GT || code == LE || code == GTU || code == LEU))
+    {
+      int x = INTVAL (ops[1]);
+      switch (code)
+	{
+	case GT:
+	  ops[1] = GEN_INT (x + 1);
+	  code = GE;
+	  break;
+	case LE:
+	  ops[1] = GEN_INT (x + 1);
+	  code = LT;
+	  break;
+	case GTU:
+	  ops[1] = GEN_INT (x + 1);
+	  code = GEU;
+	  break;
+	case LEU:
+	  ops[1] = GEN_INT (x + 1);
+	  code = LTU;
+	  break;
+	default:
+	  break;
+	}
+    }
+  else if (ops[1] && CONSTANT_P (ops[1]) && GET_MODE(ops[1]) == HImode
+      && (code == GT || code == LE || code == GTU || code == LEU))
+  {
+    /* Handle pointers here */
+    ops[1] = gen_rtx_CONST(HImode,gen_rtx_PLUS(HImode,ops[1],GEN_INT(1)));
+
+    switch (code)
+    {
+      case GT:
+	code = GE;
+	break;
+      case LE:
+	code = LT;
+	break;
+      case GTU:
+	code = GEU;
+	break;
+      case LEU:
+	code = LTU;
+	break;
+      default:
+	break;
+    }
+  }
+
+
+  if (ops[0] != cc0_rtx && ops[1] && ops[0])
+    {
+      if (code == NE || code == EQ)
+	{
+	  /* check if op0 is zero shited - win 1 byte */
+	  if (indexed_location (ops[0]) && !CONSTANT_P (ops[1]))
+	    {
+	      rtx x = ops[0];
+	      ops[0] = ops[1];
+	      ops[1] = x;
+	    }
+	}
+
+      /* check if compares were not issued */
+      if ((mode == QImode || mode == HImode)
+	  && msp430_cc_source (insn, code, ops[0], ops[1]))
+	{
+	  if( ops[1] == const0_rtx
+	      || (GET_CODE(ops[1]) == CONST_INT
+		&& INTVAL(ops[1]) == 0 ))
+	    {
+	      if(code == LT || code == GE)
+		nooverflow = 1;
+	    }
+
+	}
+      else if (mode == QImode || mode == HImode)
+	{
+	  /* check if previous insns did not set CC correctly */
+	  if (quater)
+	    OUT_INSN (len, "cmp.b\t%1, %0", ops);
+	  else
+	    OUT_INSN (len, "cmp\t%1, %0", ops);
+
+	  dummy += 3;
+	  if (REG_P (ops[0]))
+	    dummy--;
+	  if (REG_P (ops[1]))
+	    dummy--;
+	  if (indexed_location (ops[1]))
+	    dummy--;
+	  if (GET_CODE (ops[1]) == CONST_INT)
+	    {
+	      int x = INTVAL (ops[1]) & 0xffff;
+	      if (x == 0 || x == -1 || x == 1 || x == 2 || x == 4 || x == 8)
+		dummy--;
+	    }
+	}
+      else
+	{
+	  ;			/* nothing... prev insn set CC */
+	}
+
+      /* adjust distance */
+      distance -= dummy;
+
+      if (mode == SImode && (code == EQ || code == NE))
+	{
+	  /* compare against zero and can we clobber source register ? */
+	  if (((GET_CODE (ops[1]) == CONST_INT
+		&& INTVAL (ops[1]) == 0)
+	       || ops[1] == const0_rtx)
+	      && REG_P (ops[0]) && dead_or_set_p (insn, ops[0]))
+	    {
+	      OUT_INSN (len, "bis\t%A0, %B0", ops);
+	      OUT_INSN (len, "tst\t%B0", ops);
+	      dummy += 2;
+	    }
+	  else
+	    {
+	      /* cannot clobber or something... */
+	      OUT_INSN (len, "cmp\t%A1, %A0", ops);
+	      dummy += 3;
+	      if (REG_P (ops[0]))
+		dummy--;
+	      if (REG_P (ops[1]))
+		dummy--;
+	      if (indexed_location (ops[1]))
+		dummy--;
+	      if (GET_CODE (ops[1]) == CONST_INT)
+		{
+		  int x = INTVAL (ops[1]) & 0xffff;
+		  if (x == 0 || x == 1 || x == -1 || x == 2 || x == 4
+		      || x == 8)
+		    dummy--;
+		}
+	      distance -= dummy;
+	      if (distance > 500 || distance < -500)
+		predist = 3;
+	      else
+		predist = 1;
+
+	      if (code == EQ)
+		{
+		  OUT_INSN (len, "jne\t.LcmpSIe%=", ops);
+		  OUT_INSN (len, "cmp\t%B1, %B0", ops);
+		  dummy++;
+		}
+	      else
+		{
+		  /* should be handeled in cbranch guard above. */
+		  ECOND (ne, 0);
+		  OUT_INSN (len, "cmp\t%B1, %B0", ops);
+		}
+
+	      dummy += 3;
+	      if (REG_P (ops[0]))
+		dummy--;
+	      if (REG_P (ops[1]))
+		dummy--;
+	      if (GET_CODE (ops[1]) == CONST_INT)
+		{
+		  int x = (INTVAL (ops[1]) >> 16) & 0xffff;
+		  if (x == 0 || x == 0xffff || x == 1 || x == 2 || x == 4
+		      || x == 8)
+		    dummy--;
+		}
+	    }
+	}
+      else if (mode == SImode)
+	{
+	  int dl = 0;
+	  rtx oops[3];
+	  oops[0] = ops[0];
+	  oops[1] = ops[0];
+	  oops[2] = ops[1];
+
+	  if (len)
+	    msp430_subsi_code (insn, oops, &dl);
+	  else
+	    msp430_subsi_code (insn, oops, NULL);
+
+	  if (len)
+	    {
+	      /* not handeled by adjust_insn_len() */
+	      dummy += dl;
+	      if (GET_CODE (ops[1]) == CONST_INT)
+		{
+		  int x = (INTVAL (ops[1]) >> 16) & 0xffff;
+		  if (x == 0 || x == 1 || x == -1 || x == 2 || x == 4
+		      || x == 8)
+		    dummy--;
+		  x = (INTVAL (ops[1]) >> 0) & 0xffff;
+		  if (x == 0 || x == 1 || x == -1 || x == 2 || x == 4
+		      || x == 8)
+		    dummy--;
+		}
+	    }
+	}
+    }
+
+  distance -= dummy;
+
+  if (distance > 500 || distance < -500)
+    predist = 3;
+  else
+    predist = 1;
+
+  /* out assembler commands if required */
+  switch (code)
+    {
+    case EQ:
+      ECOND (eq, 0);
+      if (mode == SImode)
+	{
+	  OUT_INSN (len, ".LcmpSIe%=:", operands);
+	}
+      break;
+    case NE:
+      ECOND (ne, 0);
+      break;
+    case LT:
+      if(nooverflow)
+	ECOND (ltnoovfl,0);
+      else
+	ECOND (lt, 0);
+      break;
+    case GE:
+      if(nooverflow)
+      {
+	if(len) *len += 2;
+	if(mode == QImode)
+	  OUT_INSN (len, "bit.b\t#0x80, %0",ops);
+	else
+	  OUT_INSN (len, "bit\t#0x8000, %0",ops);
+      }
+      ECOND (ge, 0);
+      break;
+    case LTU:
+      ECOND (ltu, 0);
+      break;
+    case GEU:
+      ECOND (geu, 0);
+      break;
+      /* hopfully the following will not occur */
+    case LEU:
+      ECOND (leu, 1);
+      break;
+    case GT:
+      ECOND (gt, 1);
+      break;
+    case GTU:
+      ECOND (gtu, 1);
+      break;
+    case LE:
+      ECOND (le, 1);
+      break;
+
+    default:
+      break;
+    }
+
+  if (len)
+    *len = dummy;
+  return "";
+}
+
+/*****************  AUXES FOR TESTS *********************/
+
+RTX_CODE
+followed_compare_condition (insn)
+     rtx insn;
+{
+  rtx next = next_real_insn (insn);
+  RTX_CODE cond = UNKNOWN;
+
+  if (next && GET_CODE (next) == JUMP_INSN)
+    {
+      rtx pat = PATTERN (next);
+      rtx src, t;
+
+      if (GET_CODE (pat) == RETURN)
+	return UNKNOWN;
+
+      src = SET_SRC (pat);
+      t = XEXP (src, 0);
+      cond = GET_CODE (t);
+    }
+  else if (next && GET_CODE (next) == INSN)
+    {
+      /* here, two possible : sgeu ans sltu */
+
+      rtx pat = PATTERN (next);
+      rtx src;
+
+      if (!pat || GET_CODE (pat) != SET)
+	return UNKNOWN;
+
+      src = SET_SRC (pat);
+      cond = GET_CODE (src);	/* this must be IF_THEN_ELSE */
+      if (cond != IF_THEN_ELSE)
+	return UNKNOWN;
+    }
+  return cond;
+}
+
+/******** jumps ************/
+
+const char *
+msp430_emit_blt0si (operands, len)
+     rtx operands[];
+     int len;
+{
+  output_asm_insn ("tst\t%B2", operands);
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jl\t%0", operands);
+      break;
+    case 4:
+      output_asm_insn ("jge\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_beq (operands, len)
+     rtx operands[];
+     int len;
+{
+
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jeq\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jne\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_bne (operands, len)
+     rtx operands[];
+     int len;
+{
+
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jne\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jeq\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_bgt (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jge\t%0", operands);
+
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+6", operands);
+      output_asm_insn ("jl\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_bgtu (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jhs\t%0", operands);
+
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+6", operands);
+      output_asm_insn ("jlo\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_blt (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jl\t%0	;	%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jge\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+  const char *
+msp430_emit_bltnoovfl (operands, len)
+  rtx operands[];
+  int len;
+{
+  switch (len)
+  {
+    case 1:
+    case 2:
+      output_asm_insn ("jn\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jn\t+2",operands);
+      output_asm_insn ("jmp\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+  }
+
+  return "";
+}
+
+const char *
+msp430_emit_bltu (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jlo\t%0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jhs\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_bge (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jge\t%l0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jl\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_bgeu (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 1:
+    case 2:
+      output_asm_insn ("jhs\t%l0", operands);
+      break;
+    case 3:
+    case 4:
+      output_asm_insn ("jlo\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_ble (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t%0", operands);
+      output_asm_insn ("jl\t%0", operands);
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jge\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_bleu (operands, len)
+     rtx operands[];
+     int len;
+{
+  switch (len)
+    {
+    case 2:
+      output_asm_insn ("jeq\t%0", operands);
+      output_asm_insn ("jlo\t%0", operands);
+      break;
+    case 4:
+      output_asm_insn ("jeq\t+2", operands);
+      output_asm_insn ("jhs\t+4", operands);
+      output_asm_insn ("br\t#%0", operands);
+      break;
+    default:
+      return "bug!!!";
+    }
+
+  return "";
+}
+
+
+/* SHIFT GUARDS */
+int
+msp430_ashlhi3 (operands)
+     rtx operands[];
+{
+  int x;
+  rtx set, shift;
+  rtx dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (HImode, operands[0]);
+      op1 = force_reg (HImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashlhi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x > 15 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x < 3)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+      while (x--)
+	emit_insn (set);
+      return 1;
+    }
+
+  if (x == 15)
+    {
+      shift = gen_rtx_ASHIFT (HImode, operands[1], GEN_INT (15));
+      set = gen_rtx_SET (HImode, operands[0], shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (HImode, operands[1]);
+  else
+    dst = operands[1];
+  if (x > 7)
+    {
+      emit_insn (gen_andhi3 (dst, dst, GEN_INT (0xff)));
+      emit_insn (gen_swpb (dst, dst));
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFT (HImode, dst, const1_rtx);
+  set = gen_rtx_SET (HImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+int
+msp430_ashlsi3 (operands)
+     rtx operands[];
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (SImode, operands[0]);
+      op1 = force_reg (SImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashlsi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x >= 32 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x == 1)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFT (SImode, dst, operands[2]);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (SImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x == 31)
+    {
+      shift = gen_rtx_ASHIFT (SImode, operands[1], GEN_INT (31));
+      set = gen_rtx_SET (SImode, operands[0], shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x >= 16)
+    {
+      rtx dhi = gen_highpart (HImode, operands[0]);
+      rtx dlo = gen_lowpart (HImode, operands[0]);
+
+      shift = gen_rtx_ASHIFT (SImode, dst, GEN_INT (16));
+      set = gen_rtx_SET (SImode, operands[0], shift);
+      emit_insn (set);
+      x -= 16;
+      if (x)
+	{
+	  rtx ops[3];
+	  ops[0] = dhi;
+	  ops[1] = dhi;
+	  ops[2] = GEN_INT (x);
+	  msp430_ashlhi3 (ops);
+	}
+      emit_move_insn (dlo, const0_rtx);
+      return 1;
+    }
+
+  if (x >= 8)
+    {
+      shift = gen_rtx_ASHIFT (SImode, dst, GEN_INT (8));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFT (SImode, dst, GEN_INT (1));
+  set = gen_rtx_SET (SImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+/* arithmetic right */
+int
+msp430_ashrhi3 (operands)
+     rtx operands[];
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (HImode, operands[0]);
+      op1 = force_reg (HImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashrhi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+  if (x >= 15 || x < 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      shift = gen_rtx_ASHIFTRT (HImode, operands[0], GEN_INT (15));
+      set = gen_rtx_SET (HImode, operands[0], shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x < 3)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+
+      while (x--)
+	emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (HImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 8)
+    {
+      rtx dlo = gen_lowpart (QImode, dst);
+      emit_insn (gen_swpb (dst, dst));
+      emit_insn (gen_extendqihi2 (dst, dlo));
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+  set = gen_rtx_SET (HImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+
+  return 1;
+}
+
+int
+msp430_ashrsi3 (operands)
+     rtx operands[];
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (SImode, operands[0]);
+      op1 = force_reg (SImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_ashrsi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (SImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 31 || x < 0)
+    {
+
+      shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (31));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+
+      if (dst != operands[0])
+	emit_move_insn (operands[0], dst);
+      return 1;
+    }
+
+  if (x == 1)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_ASHIFTRT (SImode, dst, operands[2]);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x >= 16)
+    {
+      rtx dlo = gen_lowpart (HImode, operands[0]);
+      rtx shi = gen_highpart (HImode, dst);
+
+      emit_move_insn (gen_highpart (HImode, operands[0]), const0_rtx);
+      emit_insn (gen_extendhisi2 (operands[0], shi));
+      x -= 16;
+      if (x)
+	{
+	  rtx ops[3];
+	  ops[0] = dlo;
+	  ops[1] = dlo;
+	  ops[2] = GEN_INT (x);
+	  msp430_ashrhi3 (ops);
+	}
+      return 1;
+    }
+
+  if (x >= 8)
+    {
+      shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (8));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x -= 8;
+    }
+
+  shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (1));
+  set = gen_rtx_SET (SImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+/* logical right */
+int
+msp430_lshrhi3 (operands)
+     rtx operands[];
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (HImode, operands[0]);
+      op1 = force_reg (HImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_lshrhi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+  if (x > 15 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x < 3)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_LSHIFTRT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+      emit_insn (set);
+      x--;
+
+      if (x)
+	{
+	  shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+	  set = gen_rtx_SET (HImode, dst, shift);
+	  emit_insn (set);
+	}
+      return 1;
+    }
+
+  if (x == 15)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_LSHIFTRT (HImode, dst, GEN_INT (15));
+      set = gen_rtx_SET (HImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (HImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 8)
+    {
+      rtx dlo = gen_lowpart (QImode, dst);
+      emit_insn (gen_swpb (dst, dst));
+      emit_insn (gen_zero_extendqihi2 (dst, dlo));
+      x -= 8;
+    }
+
+  if (x)
+    {
+      shift = gen_rtx_LSHIFTRT (HImode, dst, const1_rtx);
+      set = gen_rtx_SET (HImode, dst, shift);
+      x--;
+      emit_insn (set);
+    }
+  shift = gen_rtx_ASHIFTRT (HImode, dst, const1_rtx);
+  set = gen_rtx_SET (HImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+
+  return 1;
+}
+
+int
+msp430_lshrsi3 (operands)
+     rtx operands[];
+{
+  int x;
+  rtx shift, set, dst;
+
+  if (!const_int_operand (operands[2], VOIDmode))
+    {
+      rtx op0, op1;
+
+      op0 = force_reg (SImode, operands[0]);
+      op1 = force_reg (SImode, operands[1]);
+      operands[2] = copy_to_mode_reg (HImode, operands[2]);
+      emit_insn (gen_lshrsi3_cnt (op0, op1, operands[2]));
+      emit_move_insn (operands[0], op0);
+      return 1;
+    }
+
+  x = INTVAL (operands[2]);
+
+  if (x == 0)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      return 1;
+    }
+
+  if (x == 1)
+    {
+      emit_move_insn (operands[0], operands[1]);
+      dst = operands[0];
+      shift = gen_rtx_LSHIFTRT (SImode, dst, operands[2]);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      return 1;
+    }
+
+  if (x > 31 || x < 0)
+    {
+      emit_move_insn (operands[0], const0_rtx);
+      return 1;
+    }
+
+  if (operands[0] != operands[1])
+    dst = copy_to_mode_reg (SImode, operands[1]);
+  else
+    dst = operands[1];
+
+  if (x >= 16)
+    {
+      rtx dlo = gen_lowpart (HImode, operands[0]);
+      rtx shi = gen_highpart (HImode, dst);
+
+      emit_move_insn (gen_highpart (HImode, operands[0]), const0_rtx);
+      emit_insn (gen_zero_extendhisi2 (operands[0], shi));
+      x -= 16;
+      if (x)
+	{
+	  rtx ops[3];
+	  ops[0] = dlo;
+	  ops[1] = dlo;
+	  ops[2] = GEN_INT (x);
+	  msp430_lshrhi3 (ops);
+	}
+      return 1;
+    }
+
+  if (x >= 8)
+    {
+      shift = gen_rtx_LSHIFTRT (SImode, dst, GEN_INT (8));
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x -= 8;
+    }
+
+  if (x)
+    {
+      shift = gen_rtx_LSHIFTRT (SImode, dst, const1_rtx);
+      set = gen_rtx_SET (SImode, dst, shift);
+      emit_insn (set);
+      x--;
+    }
+
+  shift = gen_rtx_ASHIFTRT (SImode, dst, GEN_INT (1));
+  set = gen_rtx_SET (SImode, dst, shift);
+
+  while (x--)
+    emit_insn (set);
+  if (dst != operands[0])
+    emit_move_insn (operands[0], dst);
+  return 1;
+}
+
+/******* COMMON SHIFT CODE ***************/
+int
+is_shift_better_in_reg (operands)
+     rtx operands[];
+{
+  rtx x = operands[0];
+  rtx cnt = operands[2];
+  int size = GET_MODE_SIZE (x->mode);
+  int icnt = -1;
+  int r = 0;
+
+  if (!optimize)
+    return 0;
+
+  if (GET_CODE (cnt) == CONST_INT)
+    icnt = INTVAL (cnt);
+  else
+    return 1;
+
+  switch (size)
+    {
+    case 1:
+      if (icnt != 1 && icnt != 2 && icnt != 7)
+	r = 1;
+      break;
+    case 2:
+      if (icnt != 1 && icnt != 2 && icnt != 8 && icnt != 15)
+	r = 2;
+      break;
+    case 4:
+      if (icnt != 1
+	  && icnt != 2 && icnt != 8 && icnt != 16 && icnt != 24 && icnt != 31)
+	r = 4;
+      break;
+    case 8:
+      if (icnt != 1
+	  && icnt != 2 && icnt != 16 && icnt != 32 && icnt != 48 && icnt != 63)
+	r = 8;
+      break;
+    }
+
+  return r;
+}
+
+
+static int set_len PARAMS ((rtx, int, int));
+/* for const operand2 and for SI, DI modes.*/
+static int
+set_len (x, bl, sc)
+     rtx x;			/* operand0 */
+     int bl;			/* base length in assumption of memory operand */
+     int sc;			/* shift count */
+{
+  int dummy;
+  int zs = zero_shifted (x);
+  int size = GET_MODE_SIZE (x->mode);
+  int sshi = 0;
+
+  if (size == 4)
+    sshi = 1;
+  else if (size == 8)
+    sshi = 2;
+
+  if (size == 1)
+    size++;
+
+  if (GET_CODE (x) == REG)
+    dummy = (bl >> 1) - sshi;	/* bl / 2 is not fully correct */
+  else if (zs)
+    dummy = bl - 1;
+  else if (indexed_location (x))
+    dummy = bl - 1;
+  else
+    dummy = bl;
+
+  return dummy * sc;
+}
+
+static int set_ren PARAMS ((rtx, int, int));
+/* for const operand2 and for SI, DI modes.*/
+static int
+set_ren (x, bl, sc)
+     rtx x;			/* operand0 */
+     int bl;			/* base length in assumption of memory operand */
+     int sc;			/* shift count */
+{
+  int dummy;
+
+  bl *= sc;
+  if (GET_CODE (x) == REG)
+    dummy = bl / 2;
+  else if (indexed_location (x))
+    dummy = bl - sc;
+  else
+    dummy = bl;
+  return dummy;
+}
+
+static int set_rel PARAMS ((rtx, int, int));
+/* for const operand2 and for SI, DI modes.*/
+static int
+set_rel (x, bl, sc)
+     rtx x;			/* operand0 */
+     int bl;			/* base length in assumption of memory operand */
+     int sc;			/* shift count */
+{
+  int dummy;
+
+  bl *= sc;
+  if (GET_CODE (x) == REG)
+    dummy = bl / 2;
+  else if (indexed_location (x))
+    dummy = bl - sc;
+  else
+    dummy = bl;
+  dummy += sc;
+  return dummy;
+}
+
+
+
+#define INST_THRESHOLD  16
+
+int
+msp430_emit_shift_cnt (set_len_fun, pattern, insn, operands, len, lsc)
+     int (*set_len_fun) (rtx, int, int);
+     const char *pattern;
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+     int lsc;
+{
+  rtx op[10];
+  int dummy = 0;
+
+  op[0] = operands[0];
+  op[1] = operands[1];
+  op[2] = operands[2];
+  op[3] = operands[3];
+
+
+  OUT_INSN (len, "tst\t%2", op);
+  OUT_INSN (len, "jz\t.Lsend%=\n.Lsst%=:", op);
+  OUT_INSN (len, pattern, op);
+  OUT_INSN (len, "dec\t%2", op);
+  OUT_INSN (len, "jnz\t.Lsst%=\n.Lsend%=:", op);
+  dummy = (set_len_fun) (op[0], lsc, 1) + 4;
+  if (!REG_P (op[2]) && !indexed_location (op[2]))
+    dummy += 2;
+
+
+  if (len)
+    *len = dummy;
+  return 0;
+}
+
+
+/* <<<<<<<<<<<<< SHIFT LEFT CODE <<<<<<<<<<<<<<<<<     */
+
+const char *
+msp430_emit_ashlqi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *pattern;
+  int shiftpos;
+
+  if (zs)
+    pattern = "rla.b\t@%E0";
+  else
+    pattern = "rla.b\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	default:
+	  if (zs)
+	    OUT_INSN (len, "clr.b\t@%E0", operands);
+	  else
+	    OUT_INSN (len, "clr.b\t%A0", operands);
+	  dummy = 2;
+	  if (REG_P (operands[0]))
+	    dummy >>= 1;
+	  break;
+
+	case 0:		/* paranoia setting */
+	  dummy = 0;
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 3, 1);
+	    }
+	  break;
+
+	case 7:
+	  if (zs)
+	    {
+	      OUT_INSN (len, "rra.b\t%0", operands);
+	      OUT_INSN (len, "clr.b\t%0", operands);
+	      OUT_INSN (len, "rrc.b\t%0", operands);
+	      dummy = 5;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "rra.b\t%0", operands);
+	      OUT_INSN (len, "clr.b\t%0", operands);
+	      OUT_INSN (len, "rrc.b\t%0", operands);
+	      dummy = 6;
+	      if (REG_P (operands[0]))
+		dummy = 3;
+	    }
+
+	  break;
+	}
+
+      if (len)
+	*len = dummy;
+      return "";
+
+    }
+  else
+    {
+      msp430_emit_shift_cnt (set_len, pattern, insn, operands, len, 3);
+    }
+
+  return "";
+}
+
+
+const char *
+msp430_emit_ashlhi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs;
+  const char *pattern;
+  int shiftpos;
+
+  zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+
+  if (zs)
+    pattern = "rla\t@%E0";
+  else
+    pattern = "rla\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	case 0:		/* paranoia setting */
+	  dummy = 0;
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 3, 1);
+	    }
+	  break;
+
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	  if (zs)
+	    {
+	      dummy = 3;
+	      OUT_INSN (len, "and.b\t#0xffff, %A0", operands);
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	    }
+	  else
+	    {
+	      dummy = 4;
+	      OUT_INSN (len, "and.b\t#0xffff, %A0", operands);
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      if (REG_P (operands[0]))
+		dummy = 2;
+	    }
+
+
+	  shiftpos -= 8;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 3, 1);
+	    }
+	  break;
+
+	case 15:
+	  if (zs)
+	    {
+	      OUT_INSN (len, "rra\t%0", operands);
+	      OUT_INSN (len, "clr\t%0", operands);
+	      OUT_INSN (len, "rrc\t%0", operands);
+	      dummy = 5;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "rra\t%0", operands);
+	      OUT_INSN (len, "clr\t%0", operands);
+	      OUT_INSN (len, "rrc\t%0", operands);
+	      dummy = 6;
+	      if (REG_P (operands[0]))
+		dummy = 3;
+	    }
+
+	  break;
+
+
+	default:
+
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  dummy = 2;
+	  if (REG_P (operands[0]))
+	    dummy = 1;
+	  break;
+	}
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    {
+      msp430_emit_shift_cnt (set_len, pattern, insn, operands, len, 3);
+    }
+
+  return "";
+}
+
+
+const char *
+msp430_emit_ashlsi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+
+  int dummy = 0;
+  int zs;
+  const char *pattern;
+
+  zs = zero_shifted (operands[0]);
+
+  if (zs)
+    pattern = "add\t@%E0+, -2(%E0)\n\taddc\t@%E0+, -2(%E0)\n\tsub\t#4, %E0";
+  else
+    pattern = "rla\t%A0\n\trlc\t%B0";
+
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+
+	case 0:
+	  dummy = 0;
+	  break;
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 6, 1);
+	    }
+	  break;
+
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+
+	  if (zs || indexed_location (operands[0]))
+	    {
+	      OUT_INSN (len, "xor.b\t@%E0, %B0", operands);
+	      OUT_INSN (len, "xor\t@%E0, %B0", operands);
+	      OUT_INSN (len, "swpb\t%B0", operands);
+	      OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      dummy = 9;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "xor.b\t%A0, %B0", operands);
+	      OUT_INSN (len, "xor\t%A0, %B0", operands);
+	      OUT_INSN (len, "swpb\t%B0", operands);
+	      OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      dummy = 12;
+	      if (REG_P (operands[0]))
+		dummy = 5;
+	    }
+
+	  shiftpos -= 8;
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 6, 1);
+	    }
+
+	  if (len)
+	    *len = dummy;
+	  return "";
+
+	  break;
+
+	case 16:
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 22:
+	case 23:
+
+	  if (zs || indexed_location (operands[0]))
+	    {
+	      OUT_INSN (len, "mov\t@%E0, %B0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      dummy = 4;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "mov\t%A0, %B0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      dummy = 5;
+	      if (REG_P (operands[0]))
+		dummy = 3;
+	    }
+
+	  shiftpos -= 16;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 6, 1);
+	    }
+
+	  if (len)
+	    *len = dummy;
+	  return "";
+	  break;
+
+	case 24:
+	case 25:
+	case 26:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	  if (zs || indexed_location (operands[0]))
+	    {
+	      OUT_INSN (len, "mov.b\t@%E0,%B0", operands);
+	      OUT_INSN (len, "swpb\t%B0", operands);
+	      OUT_INSN (len, "clr\t@%E0", operands);
+	      dummy = 6;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "mov.b\t%A0,%B0", operands);
+	      OUT_INSN (len, "swpb\t%B0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      dummy = 8;
+	      if (GET_CODE (operands[0]) == REG)
+		dummy = 3;
+	    }
+
+	  shiftpos -= 24;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 6, 1);
+	    }
+
+	  if (len)
+	    *len = dummy;
+	  return "";
+
+	  break;
+
+	case 31:
+	  if (zs || indexed_location (operands[0]))
+	    {
+	      OUT_INSN (len, "rra\t@%E0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "rrc\t%B0", operands);
+	      dummy = 9;
+
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "rrc\t%B0", operands);
+	      dummy = 10;
+	      if (REG_P (operands[0]))
+		dummy = 4;
+	    }
+
+	  if (len)
+	    *len = dummy;
+	  return "";
+	  break;
+
+	default:
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  if (len)
+	    *len = set_len (operands[0], 6, 1);
+	  return "";
+	  break;
+
+	}			/* switch */
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    msp430_emit_shift_cnt (set_len, pattern, insn, operands, len, 6);
+
+  return "";
+
+}
+
+const char *
+msp430_emit_ashldi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+
+  int dummy = 0;
+  int zs;
+  const char *pattern;
+
+  zs = zero_shifted (operands[0]);
+
+  if (zs)
+    pattern =
+	"add\t@%E0+,-2(%E0)\n\taddc\t@%E0+,-2(%E0)\n\taddc\t@%E0+,-2(%E0)\n\taddc\t@%E0+,-2(%E0)\n\tsub\t#8,%E0";
+  else
+    pattern = "rla\t%A0\n\trlc\t%B0\n\trlc\t%C0\n\trlc\t%D0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	case 0:
+	  dummy = 0;
+	  if (len)
+	    *len = dummy;
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 12, 1);
+	    }
+	  if (len)
+	    *len = dummy;
+	  break;
+
+	case 16:
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 22:
+	case 23:
+	  if (zs || indexed_location (operands[0]))
+	    {
+	      dummy = 10;
+	      OUT_INSN (len, "mov\t%C0, %D0", operands);
+	      OUT_INSN (len, "mov\t%B0, %C0", operands);
+	      OUT_INSN (len, "mov\t@%E0, %B0", operands);
+	      OUT_INSN (len, "clr\t@%E0", operands);
+	    }
+	  else
+	    {
+	      dummy = 11;
+	      OUT_INSN (len, "mov\t%C0, %D0", operands);
+	      OUT_INSN (len, "mov\t%B0, %C0", operands);
+	      OUT_INSN (len, "mov\t%A0, %B0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+
+	    }
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 4;
+	  shiftpos -= 16;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 12, 1);
+	    }
+	  if (len)
+	    *len = dummy;
+	  break;
+
+	case 24:
+	case 25:
+	case 26:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	case 31:
+	  if (zs)
+	    {
+	      dummy = 8;
+	      OUT_INSN (len, "mov\t@%E0, %D0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "clr\t%C0", operands);
+
+	    }
+	  else
+	    {
+	      dummy = 9;
+	      OUT_INSN (len, "mov\t%A0, %D0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "clr\t%C0", operands);
+	    }
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 4;
+
+	  shiftpos -= 16;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 12, 1);
+	    }
+
+	  if (len)
+	    *len = dummy;
+	  break;
+
+	case 32:
+	case 33:
+	case 34:
+	case 35:
+	case 36:
+	case 37:
+	case 38:
+	case 39:
+	case 40:
+	case 41:
+	case 42:
+	case 43:
+	case 44:
+	case 45:
+	case 46:
+	case 47:
+
+	  if (zs)
+	    {
+	      OUT_INSN (len, "mov\t@%E0+, %C0", operands);
+	      OUT_INSN (len, "mov\t@%E0+, %D0", operands);
+	      OUT_INSN (len, "sub\t#4, %E0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      dummy = 9;
+	    }
+	  else
+	    {
+	      dummy = 10;
+	      OUT_INSN (len, "mov\t%A0, %C0", operands);
+	      OUT_INSN (len, "mov\t%B0, %D0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	    }
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 4;
+
+	  shiftpos -= 32;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 12, 1);
+	    }
+
+	  if (len)
+	    *len = dummy;
+	  break;
+
+	case 48:
+	case 49:
+	case 50:
+	case 51:
+	case 52:
+	case 53:
+	case 54:
+	case 55:
+	case 56:
+	case 57:
+	case 58:
+	case 59:
+	case 60:
+	case 61:
+	case 62:
+	  if (zs)
+	    {
+	      dummy = 8;
+	      OUT_INSN (len, "mov\t@%E0, %D0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "clr\t%C0", operands);
+	    }
+	  else
+	    {
+	      dummy = 9;
+	      OUT_INSN (len, "mov\t%A0, %D0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "clr\t%C0", operands);
+	    }
+
+	  shiftpos -= 48;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_len (operands[0], 12, 1);
+	    }
+
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 4;
+	  if (len)
+	    *len = dummy;
+
+	  break;
+
+	case 63:
+	  if (zs || indexed_location (operands[0]))
+	    {
+	      OUT_INSN (len, "rra\t@%E0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "clr\t%C0", operands);
+	      OUT_INSN (len, "clr\t%D0", operands);
+	      OUT_INSN (len, "rrc\t%D0", operands);
+	      dummy = 11;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "clr\t%B0", operands);
+	      OUT_INSN (len, "clr\t%C0", operands);
+	      OUT_INSN (len, "clr\t%D0", operands);
+	      OUT_INSN (len, "rrc\t%D0", operands);
+	      dummy = 12;
+	      if (REG_P (operands[0]))
+		dummy = 6;
+	    }
+
+	  if (len)
+	    *len = dummy;
+
+	  break;		/* make compiler happy */
+
+	default:
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  OUT_INSN (len, "clr\t%C0", operands);
+	  OUT_INSN (len, "clr\t%D0", operands);
+	  dummy = 8;
+	  if (zs)
+	    dummy--;
+	  if (REG_P (operands[0]))
+	    dummy = 4;
+
+	  if (len)
+	    *len = dummy;
+
+	}			/* switch */
+
+      return "";
+    }
+  else
+    msp430_emit_shift_cnt (set_len, pattern, insn, operands, len, 12);
+
+  return "";			/* make compiler happy */
+}
+
+/********* SHIFT RIGHT CODE ***************************************/
+const char *
+msp430_emit_ashrqi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *pattern;
+  int shiftpos;
+
+  if (zs)
+    pattern = "rra.b\t@%E0";
+  else
+    pattern = "rra.b\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+
+      shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	case 0:		/* paranoia setting */
+	  dummy = 0;
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += 2;
+	    }
+	  break;
+
+	case 7:
+	  if (zs)
+	    {
+	      OUT_INSN (len, "sxt\t@%E0", operands);
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	      dummy = 4;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "sxt\t%A0", operands);
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	      dummy = 6;
+	    }
+	  if (REG_P (operands[0]))
+	    dummy = 3;
+	  if (len)
+	    *len = dummy;
+	  return "";
+
+	  break;
+
+	default:
+	  OUT_INSN (len, "clr.b\t%A0", operands);
+	  dummy = 2;
+	  if (REG_P (operands[0]))
+	    dummy = 1;
+	}
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    {
+      msp430_emit_shift_cnt (set_ren, pattern, insn, operands, len, 2);
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_ashrhi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *pattern;
+  int shiftpos;
+
+  if (zs)
+    pattern = "rra\t@%E0";
+  else
+    pattern = "rra\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	case 0:		/* paranoia setting */
+	  dummy = 0;
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += 2;
+	    }
+	  if (zs || REG_P (operands[0]))
+	    dummy >>= 1;
+	  break;
+
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	  if (zs)
+	    {
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      OUT_INSN (len, "sxt\t@%E0", operands);
+	      dummy = 2;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      OUT_INSN (len, "sxt\t%A0", operands);
+	      dummy = 4;
+	      if (REG_P (operands[0]))
+		dummy = 2;
+	    }
+	  shiftpos -= 8;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += (zs || REG_P (operands[0])) ? 1 : 2;
+	    }
+	  break;
+
+	case 15:
+	  if (zs)
+	    {
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      OUT_INSN (len, "sxt\t@%E0", operands);
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      dummy = 4;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      OUT_INSN (len, "sxt\t%A0", operands);
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      OUT_INSN (len, "sxt\t%A0", operands);
+	      dummy = 8;
+	    }
+	  if (REG_P (operands[0]))
+	    dummy = 4;
+	  break;
+
+	default:
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  dummy = 2;
+	  if (REG_P (operands[0]))
+	    dummy = 1;
+	}
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    {
+      msp430_emit_shift_cnt (set_ren, pattern, insn, operands, len, 2);
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_ashrsi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+
+  int dummy = 0;
+  const char *pattern;
+  int zs = zero_shifted (operands[0]);
+
+  pattern = "rra\t%B0\n\trrc\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	case 0:
+	  dummy = 0;
+	  break;
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_ren (operands[0], 4, 1);
+	    }
+	  break;
+
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	  OUT_INSN (len, "swpb\t%A0", operands);
+	  OUT_INSN (len, "swpb\t%B0", operands);
+	  OUT_INSN (len, "xor.b\t%B0, %A0", operands);
+	  OUT_INSN (len, "xor\t%B0, %A0", operands);
+	  OUT_INSN (len, "sxt\t%B0", operands);
+	  dummy = 12;
+
+	  if (REG_P (operands[0]))
+	    dummy = 5;
+	  shiftpos -= 8;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_ren (operands[0], 4, 1);
+	    }
+	  break;
+
+	case 16:
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 22:
+	case 23:
+	  OUT_INSN (len, "mov\t%B0, %A0", operands);
+	  OUT_INSN (len, "bit\t#0x8000, %B0", operands);
+	  OUT_INSN (len, "jz\t.Lsrc%=", operands);
+	  OUT_INSN (len, "bis\t#0xffff, %B0", operands);
+	  OUT_INSN (len, "jmp\t.Lsre%=\n.Lsrc%=:", operands);
+	  OUT_INSN (len, "clr\t%B0\n.Lsre%=:", operands);
+	  dummy = 12;
+
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 7;
+
+	  shiftpos -= 16;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      dummy += 2;
+	      if (GET_CODE (operands[0]) == REG || zs)
+		dummy--;
+	    }
+
+	  break;
+
+	case 24:
+	case 25:
+	case 26:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	  OUT_INSN (len, "swpb\t%B0", operands);
+	  OUT_INSN (len, "sxt\t%B0", operands);
+	  OUT_INSN (len, "mov\t%B0, %A0", operands);
+	  OUT_INSN (len, "swpb\t%B0", operands);
+	  OUT_INSN (len, "sxt\t%B0", operands);
+	  dummy = 11;
+
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 5;
+
+	  shiftpos -= 24;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      dummy += 2;
+	      if (GET_CODE (operands[0]) == REG || zs)
+		dummy--;
+	    }
+	  break;
+
+	case 31:
+	  OUT_INSN (len, "tst\t%B0", operands);
+	  OUT_INSN (len, "mov\t#-1,%B0", operands);
+	  OUT_INSN (len, "mov\t#-1,%A0", operands);
+	  if (GET_CODE (operands[0]) == REG)
+	    OUT_INSN (len, "jn\t+4", operands);
+	  else
+	    OUT_INSN (len, "jn\t+8", operands);
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  dummy = 11;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 6;
+	  break;
+
+	default:
+	  dummy = 0;		/* leave it alone!!! */
+	  break;
+
+	}			/* switch */
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    msp430_emit_shift_cnt (set_ren, pattern, insn, operands, len, 4);
+
+  return "";
+
+}
+
+const char *
+msp430_emit_ashrdi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+
+  int dummy = 0;
+  const char *pattern;
+
+  pattern = "rra\t%D0\n\trrc\t%C0\n\trrc\t%B0\n\trrc\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int shiftpos = INTVAL (operands[2]);
+
+      switch (shiftpos)
+	{
+	case 0:
+	  dummy = 0;
+	  break;
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, pattern, operands);
+	      dummy += set_ren (operands[0], 8, 1);
+	    }
+	  break;
+
+	case 16:
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 22:
+	case 23:
+	case 24:
+	case 25:
+	case 26:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	case 31:
+
+	  OUT_INSN (len, "mov\t%B0, %A0", operands);
+	  OUT_INSN (len, "mov\t%C0, %B0", operands);
+	  OUT_INSN (len, "mov\t%D0, %C0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+
+	  dummy = 17;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 7;
+	  shiftpos -= 16;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%C0\n\trrc\t%B0\n\trrc\t%A0", operands);
+	      dummy += set_ren (operands[0], 6, 1);
+	    }
+
+	  break;
+
+	case 32:
+	case 33:
+	case 34:
+	case 35:
+	case 36:
+	case 37:
+	case 38:
+	case 39:
+	case 40:
+	case 41:
+	case 42:
+	case 43:
+	case 44:
+	case 45:
+	case 46:
+	case 47:
+	  OUT_INSN (len, "mov\t%C0, %A0", operands);
+	  OUT_INSN (len, "mov\t%D0, %B0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "mov\t%D0, %C0", operands);
+	  dummy = 17;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 8;
+	  shiftpos -= 32;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%B0\n\trrc\t%A0", operands);
+	      dummy += set_ren (operands[0], 4, 1);
+	    }
+	  break;
+
+	case 48:
+	case 49:
+	case 50:
+	case 51:
+	case 52:
+	case 53:
+	case 54:
+	case 55:
+	case 56:
+	case 57:
+	case 58:
+	case 59:
+	case 60:
+	case 61:
+	case 62:
+	  OUT_INSN (len, "mov\t%D0, %A0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "mov\t%D0, %C0", operands);
+	  OUT_INSN (len, "mov\t%D0, %B0", operands);
+	  dummy = 17;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 7;
+	  shiftpos -= 48;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      dummy += set_ren (operands[0], 2, 1);
+	    }
+	  break;
+
+	case 63:
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "swpb\t%D0", operands);
+	  OUT_INSN (len, "sxt\t%D0", operands);
+	  OUT_INSN (len, "mov\t%D0, %C0", operands);
+	  OUT_INSN (len, "mov\t%D0, %B0", operands);
+	  OUT_INSN (len, "mov\t%D0, %A0", operands);
+	  dummy = 17;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 7;
+	  break;
+
+	default:
+	  dummy = 0;
+
+	}			/* case */
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    msp430_emit_shift_cnt (set_ren, pattern, insn, operands, len, 8);
+  return "";
+}
+
+/********* LOGICAL SHIFT RIGHT CODE ***************************************/
+const char *
+msp430_emit_lshrqi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *pattern;
+  const char *second_pat;
+  int shiftpos;
+
+  if (zs)
+    {
+      pattern = "clrc\n\trrc.b\t@%E0";
+      second_pat = "rra.b\t@%E0";
+    }
+  else
+    {
+      pattern = "clrc\n\trrc.b\t%A0";
+      second_pat = "rra.b\t%A0";
+    }
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+
+      shiftpos = INTVAL (operands[2]);
+
+      if (shiftpos != 7 && shiftpos)
+	{
+	  OUT_INSN (len, pattern, operands);
+	  dummy += set_rel (operands[0], 2, 1);
+	  shiftpos--;
+	}
+
+      switch (shiftpos)
+	{
+	case 0:
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, second_pat, operands);
+	      dummy += set_rel (operands[0], 2, 1) - 1;
+	    }
+
+	  break;
+
+	case 7:
+	  if (zs)
+	    {
+	      OUT_INSN (len, "rla.b\t@%E0", operands);
+	      OUT_INSN (len, "clr.b\t%A0", operands);
+	      OUT_INSN (len, "rlc.b\t@%E0", operands);
+	      dummy = 4;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "rla.b\t%A0", operands);
+	      OUT_INSN (len, "clr.b\t%A0", operands);
+	      OUT_INSN (len, "rlc.b\t%A0", operands);
+	      dummy = 6;
+	    }
+	  if (REG_P (operands[0]))
+	    dummy = 3;
+	  break;
+
+	default:
+	  OUT_INSN (len, "clr.b\t%A0", operands);
+	  dummy = 2;
+	  if (REG_P (operands[0]))
+	    dummy = 1;
+	  break;
+	}
+
+      if (len)
+	*len = dummy;
+    }
+  else
+    {
+      msp430_emit_shift_cnt (set_rel, pattern, insn, operands, len, 2);
+    }
+
+  return "";
+}
+
+const char *
+msp430_emit_lshrhi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *pattern;
+  const char *second_pat;
+  int shiftpos;
+
+  if (zs)
+    {
+      pattern = "clrc\n\trrc\t@%E0";
+      second_pat = "rra\t@%E0";
+    }
+  else
+    {
+      pattern = "clrc\n\trrc\t%A0";
+      second_pat = "rra\t%A0";
+    }
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      shiftpos = INTVAL (operands[2]);
+
+      if (shiftpos < 8 && shiftpos)
+	{
+	  OUT_INSN (len, pattern, operands);
+	  dummy += set_rel (operands[0], 2, 1);
+	  shiftpos--;
+	}
+
+      switch (shiftpos)
+	{
+	case 0:
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, second_pat, operands);
+	      dummy += set_rel (operands[0], 2, 1) - 1;
+	    }
+
+	  break;
+
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+
+	  if (zs)
+	    {
+	      OUT_INSN (len, "swpb\t@%E0", operands);
+	      OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	      dummy = 3;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "swpb\t%A0", operands);
+	      OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	      dummy = 4;
+	    }
+	  if (REG_P (operands[0]))
+	    dummy = 2;
+	  shiftpos -= 8;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, second_pat, operands);
+	      dummy += set_rel (operands[0], 2, 1) - 1;
+	    }
+	  break;
+
+	case 15:
+
+	  if (zs)
+	    {
+	      OUT_INSN (len, "rla\t@%E0", operands);
+	      OUT_INSN (len, "clr\t@%E0", operands);
+	      OUT_INSN (len, "rlc\t@%E0", operands);
+	      dummy = 3;
+	    }
+	  else
+	    {
+	      OUT_INSN (len, "rla\t%A0", operands);
+	      OUT_INSN (len, "clr\t%A0", operands);
+	      OUT_INSN (len, "rlc\t%A0", operands);
+	      dummy = 6;
+	    }
+	  if (REG_P (operands[0]))
+	    dummy = 3;
+	  break;
+
+	default:
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  dummy = 2;
+	  if (REG_P (operands[0]))
+	    dummy = 1;
+	  break;
+	}
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    {
+      msp430_emit_shift_cnt (set_rel, pattern, insn, operands, len, 2);
+    }
+
+  return "";
+
+}
+
+const char *
+msp430_emit_lshrsi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  const char *pattern;
+  int dummy = 0;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *second_pat = "rra\t%B0\n\trrc\t%A0";
+
+  pattern = "clrc\n\trrc\t%B0\n\trrc\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int shiftpos = INTVAL (operands[2]);
+
+      if (shiftpos < 8 && shiftpos)
+	{
+	  OUT_INSN (len, pattern, operands);
+	  /* This function was underestimating the length by 1 for shifts from
+	     1 to 7.  I added one here - Max */
+	  dummy += set_rel (operands[0], 2, 1) + 1;
+	  shiftpos--;
+	}
+
+      switch (shiftpos)
+	{
+	case 0:
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, second_pat, operands);
+	      dummy += set_rel (operands[0], 4, 1) - 1;
+	    }
+
+	  break;
+
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	  OUT_INSN (len, "swpb\t%A0", operands);
+	  OUT_INSN (len, "swpb\t%B0", operands);
+	  OUT_INSN (len, "xor.b\t%B0, %A0", operands);
+	  OUT_INSN (len, "xor\t%B0, %A0", operands);
+	  OUT_INSN (len, "and.b\t#-1, %B0", operands);
+	  dummy = 12;
+
+	  if (REG_P (operands[0]))
+	    dummy = 5;
+	  shiftpos -= 8;
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, second_pat, operands);
+	      dummy += set_rel (operands[0], 4, 1) - 1;
+	    }
+	  break;
+
+	case 16:
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 22:
+	case 23:
+	  OUT_INSN (len, "mov\t%B0, %A0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  dummy = 5;
+	  if (REG_P (operands[0]))
+	    dummy = 2;
+
+	  shiftpos -= 16;
+	  if (shiftpos)
+	    {
+	      OUT_INSN (len, "clrc\n\trrc\t%A0", operands);
+	      dummy += 2;
+	      if (!zs && !REG_P (operands[0]))
+		dummy++;
+	      shiftpos--;
+	    }
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      dummy += 1;
+	      if (!zs && !REG_P (operands[0]))
+		dummy++;
+	    }
+	  break;
+
+	case 24:
+	case 25:
+	case 26:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	  OUT_INSN (len, "mov\t%B0, %A0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  OUT_INSN (len, "swpb\t%A0", operands);
+	  OUT_INSN (len, "and.b\t#-1, %A0", operands);
+	  dummy = 9;
+	  if (REG_P (operands[0]))
+	    dummy = 4;
+	  if (indexed_location (operands[0]))
+	    dummy -= 1;
+	  shiftpos -= 24;
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      dummy += 1;
+	      if (!zs && !REG_P (operands[0]))
+		dummy++;
+	    }
+	  break;
+
+	case 31:
+	  OUT_INSN (len, "rla\r%B0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  OUT_INSN (len, "rlc\t%A0", operands);
+	  dummy = 8;
+	  if (REG_P (operands[0]))
+	    dummy = 4;
+	  if (indexed_location (operands[0]))
+	    dummy -= 1;
+	  break;
+
+	default:
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  dummy = 4;
+	  if (REG_P (operands[0]))
+	    dummy = 2;
+	  break;
+
+	}			/* switch */
+
+      if (len)
+	*len = dummy;
+      return "";
+    }
+  else
+    msp430_emit_shift_cnt (set_rel, pattern, insn, operands, len, 4);
+
+  return "";
+}
+
+const char *
+msp430_emit_lshrdi3 (insn, operands, len)
+     rtx insn;
+     rtx operands[];
+     int *len;
+{
+  int dummy = 0;
+  const char *pattern;
+  int zs = zero_shifted (operands[0]) || indexed_location (operands[0]);
+  const char *secondary_pat = "rra\t%D0\n\trrc\t%C0\n\trrc\t%B0\n\trrc\t%A0";
+
+  pattern = "clrc\n\trrc\t%D0\n\trrc\t%C0\n\trrc\t%B0\n\trrc\t%A0";
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int shiftpos = INTVAL (operands[2]);
+
+      if (shiftpos < 16 && shiftpos)
+	{
+	  OUT_INSN (len, pattern, operands);
+	  dummy += set_rel (operands[0], 2, 1);
+	  shiftpos--;
+	}
+
+      switch (shiftpos)
+	{
+	case 0:
+	  break;
+
+	case 1:
+	case 2:
+	case 3:
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+	case 8:
+	case 9:
+	case 10:
+	case 11:
+	case 12:
+	case 13:
+	case 14:
+	case 15:
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, secondary_pat, operands);
+	      dummy += set_rel (operands[0], 8, 1) - 1;
+	    }
+
+	  break;
+
+	case 16:
+	case 17:
+	case 18:
+	case 19:
+	case 20:
+	case 21:
+	case 22:
+	case 23:
+	case 24:
+	case 25:
+	case 26:
+	case 27:
+	case 28:
+	case 29:
+	case 30:
+	case 31:
+	  OUT_INSN (len, "mov\t%B0, %A0", operands);
+	  OUT_INSN (len, "mov\t%C0, %B0", operands);
+	  OUT_INSN (len, "mov\t%D0, %C0", operands);
+	  OUT_INSN (len, "clr\t%D0", operands);
+	  dummy = 11;
+	  if (REG_P (operands[0]))
+	    dummy = 4;
+	  shiftpos -= 16;
+
+	  if (shiftpos)
+	    {
+	      OUT_INSN (len, secondary_pat, operands);
+	      dummy += set_rel (operands[0], 8, 1) - 1;
+	      shiftpos--;
+	    }
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%C0\n\trrc\t%B0\n\trrc\t%A0", operands);
+	      if (REG_P (operands[0]))
+		dummy = 3;
+	      else
+		dummy += 6;
+	      if (zs)
+		dummy--;
+	    }
+
+	  break;
+
+	case 32:
+	case 33:
+	case 34:
+	case 35:
+	case 36:
+	case 37:
+	case 38:
+	case 39:
+	case 40:
+	case 41:
+	case 42:
+	case 43:
+	case 44:
+	case 45:
+	case 46:
+	case 47:
+	  OUT_INSN (len, "mov\t%C0, %A0", operands);
+	  OUT_INSN (len, "mov\t%D0, %B0", operands);
+	  OUT_INSN (len, "clr\t%C0", operands);
+	  OUT_INSN (len, "clr\t%D0", operands);
+
+	  dummy = 10;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 4;
+
+	  shiftpos -= 32;
+
+	  if (shiftpos)
+	    {
+	      OUT_INSN (len, "clrc\n\trrc\t%B0,rrc\t%A0", operands);
+	      if (REG_P (operands[0]))
+		dummy += 3;
+	      else
+		dummy += 5;
+	      if (zs)
+		dummy--;
+	      shiftpos--;
+	    }
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%B0,rrc\t%A0", operands);
+	      if (REG_P (operands[0]))
+		dummy += 2;
+	      else
+		dummy += 4;
+	      if (zs)
+		dummy--;
+	    }
+	  break;
+
+	case 48:
+	case 49:
+	case 50:
+	case 51:
+	case 52:
+	case 53:
+	case 54:
+	case 55:
+	case 56:
+	case 57:
+	case 58:
+	case 59:
+	case 60:
+	case 61:
+	case 62:
+	  OUT_INSN (len, "mov\t%D0, %A0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  OUT_INSN (len, "clr\t%C0", operands);
+	  OUT_INSN (len, "clr\t%D0", operands);
+	  dummy = 9;
+	  if (GET_CODE (operands[0]) == REG)
+	    dummy = 4;
+	  shiftpos -= 48;
+
+	  if (shiftpos)
+	    {
+	      OUT_INSN (len, "clrc\n\trrc\t%A0", operands);
+	      if (REG_P (operands[0]) || zs)
+		dummy += 2;
+	      else
+		dummy += 3;
+
+	      shiftpos--;
+	    }
+
+	  while (shiftpos--)
+	    {
+	      OUT_INSN (len, "rra\t%A0", operands);
+	      if (REG_P (operands[0]) || zs)
+		dummy++;
+	      else
+		dummy += 2;
+	    }
+	  break;
+
+	case 63:
+
+	  OUT_INSN (len, "rla\t%D0", operands);
+	  OUT_INSN (len, "clr\t%D0", operands);
+	  OUT_INSN (len, "clr\t%C0", operands);
+	  OUT_INSN (len, "clr\t%B0", operands);
+	  OUT_INSN (len, "clr\t%A0", operands);
+	  OUT_INSN (len, "rlc\t%A0", operands);
+	  if (REG_P (operands[0]))
+	    dummy += 6;
+	  else
+	    dummy += 13;
+
+	  if (zs)
+	    dummy--;
+	  break;
+
+	default:
+	  break;
+	}			/* case */
+
+      if (len)
+	*len = dummy;
+    }
+  else
+    msp430_emit_shift_cnt (set_rel, pattern, insn, operands, len, 8);
+
+  return "";
+}
+
+/*
+ *	Multiplication helpers
+ *	1. As shifts, 2. the rest 
+ */
+
+#define SOME_SHIFT_THRESHOLD_VAL 	10
+
+int
+msp430_easy_mul (operands, sext)
+     rtx operands[];
+     int sext;
+{
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx insn;
+  int m = INTVAL (operands[2]);
+  int sign = (m < 0);
+  int val = (m > 0 ? m : -m);
+  int shift1 = 0, shift0 = 0;
+  int add1 = 0, sub1 = 0;
+  int t0, t1;
+  int ops = 0;
+
+  m = val;
+  /* 
+     we can do: 
+     const == single bit const +- N that (shift0 + add1/sub1 < 8 instructions) 
+   */
+  shift0 = 1;
+  shift1 = 0;
+
+  for (t0 = 2;
+       t0 <= val * 2 && shift0 < GET_MODE_SIZE (op0mode) * BITS_PER_UNIT;
+       t0 <<= 1)
+    {
+      if (t0 == val)
+	goto done;
+
+      for (t1 = 1; t1 < t0 && shift1 < GET_MODE_SIZE (op1mode) * BITS_PER_UNIT;
+	   t1 <<= 1)
+	{
+	  add1 = 0;
+	  sub1 = 0;
+	  if (t0 + t1 == m)
+	    {
+	      add1 = 1;
+	      goto done;
+	    }
+	  if (t0 - t1 == m)
+	    {
+	      sub1 = 1;
+	      goto done;
+	    }
+
+	  if (t0 + t1 * 3 == m)
+	    {
+	      add1 = 3;
+	      goto done;
+	    }
+
+	  if (t0 - t1 * 3 == m)
+	    {
+	      sub1 = 3;
+	      goto done;
+	    }
+
+	  add1 = 0;
+	  sub1 = 0;
+	  shift1++;
+
+	}
+      shift1 = 0;
+      shift0++;
+    }
+
+  return 0;
+done:
+
+  ops = shift0 * (op0mode == SImode ? 2 : 1);
+  ops += shift1 + add1 + sub1;
+  if (op0mode != op1mode)
+    {
+      ops += (op0mode == SImode ? 2 : 1) * ((add1 || sub1) ? 2 : 1);
+    }
+
+  if (ops > SOME_SHIFT_THRESHOLD_VAL)
+    return 0;
+
+  if (op0mode != op1mode)
+    {
+      rtx extend;
+      if (sext)
+	extend = gen_rtx_SIGN_EXTEND (op0mode, op1);
+      else
+	extend = gen_rtx_ZERO_EXTEND (op0mode, op1);
+      insn = gen_rtx_SET (VOIDmode, op0, extend);
+      emit_insn (insn);
+    }
+  else
+    {
+      emit_move_insn (op0, op1);
+    }
+
+  /* shift0 */
+  switch (op0mode)
+    {
+    case QImode:
+      emit_insn (gen_ashlqi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    case HImode:
+      emit_insn (gen_ashlhi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    case SImode:
+      emit_insn (gen_ashlsi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    case DImode:
+      emit_insn (gen_ashldi3 (op0, op0, GEN_INT (shift0)));
+      break;
+    default:
+      abort ();
+    }
+
+  if (op0mode != op1mode && (add1 || sub1 || shift1))
+    {
+      /* equalize operands modes */
+      rtx extend;
+      rtx treg = gen_reg_rtx (op0mode);
+
+      if (sext)
+	extend = gen_rtx_SIGN_EXTEND (op0mode, op1);
+      else
+	extend = gen_rtx_ZERO_EXTEND (op0mode, op1);
+      insn = gen_rtx_SET (VOIDmode, treg, extend);
+      emit_insn (insn);
+      op1 = treg;
+      op1mode = GET_MODE (treg);
+    }
+  else if (add1 || sub1 || shift1)
+    {
+      rtx treg = gen_reg_rtx (op0mode);
+      emit_move_insn (treg, op1);
+      op1 = treg;
+    }
+
+  if (shift1 && (add1 || sub1))
+    {
+      switch (op1mode)
+	{
+	case QImode:
+	  emit_insn (gen_ashlqi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	case HImode:
+	  emit_insn (gen_ashlhi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	case SImode:
+	  emit_insn (gen_ashlsi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	case DImode:
+	  emit_insn (gen_ashldi3 (op1, op1, GEN_INT (shift1)));
+	  break;
+	default:
+	  abort ();
+	}
+    }
+  else if (shift1)
+    abort ();			/* paranoia */
+
+  while (add1--)
+    {
+      insn =
+	  gen_rtx_SET (VOIDmode, op0, gen_rtx_PLUS (GET_MODE (op0), op0, op1));
+      emit_insn (insn);
+    }
+
+  while (sub1--)
+    {
+      insn =
+	  gen_rtx_SET (VOIDmode, op0,
+		       gen_rtx_MINUS (GET_MODE (op0), op0, op1));
+      emit_insn (insn);
+    }
+
+  if (sign)
+    {
+      switch (op0mode)
+	{
+	case QImode:
+	  emit_insn (gen_negqi2 (op0, op0));
+	  break;
+	case HImode:
+	  emit_insn (gen_neghi2 (op0, op0));
+	  break;
+	case SImode:
+	  emit_insn (gen_negsi2 (op0, op0));
+	  break;
+	case DImode:
+	  emit_insn (gen_negdi2 (op0, op0));
+	  break;
+	default:
+	  abort ();
+	}
+    }
+
+  return 1;
+}
+
+/* multiplication guards */
+#define LOAD_MPY(x)	\
+do{ \
+  if(GET_MODE(x) == QImode)		\
+    emit_insn(gen_load_mpyq(x));	\
+  else					\
+    emit_insn(gen_load_mpy(x));	\
+}while(0)
+
+#define LOAD_MPYS(x)	\
+do{ \
+  if(GET_MODE(x) == QImode)		\
+    emit_insn(gen_load_mpysq(x));	\
+  else					\
+    emit_insn(gen_load_mpys(x));	\
+}while(0)
+
+#define LOAD_OP2(x)	\
+do{ \
+  if(GET_MODE(x) == QImode)		\
+    emit_insn(gen_load_op2q(x));	\
+  else					\
+    emit_insn(gen_load_op2(x));	\
+}while(0)
+
+int
+msp430_mul3_guard (operands, sext)
+     rtx operands[];
+     int sext;
+{
+  rtx m_mpys = mpys_rtx;
+  rtx m_op2 = op2_rtx;
+  rtx m_reslo = reslo_rtx;
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  rtx r12 = gen_rtx_REG (op1mode, 12);
+  rtx r10 = gen_rtx_REG (op1mode, 10);
+  rtx r14 = gen_rtx_REG (op0mode, 14);
+
+  if (const_int_operand (operands[2], VOIDmode) &&
+      msp430_easy_mul (operands, sext))
+    return 1;
+
+  if (!msp430_has_hwmul)
+    {
+      rtx clob1 = gen_rtx_CLOBBER (VOIDmode, r10);
+      rtx clob2 = gen_rtx_CLOBBER (VOIDmode, r12);
+      rtx set;
+      rtx mult, op1, op2;
+      rtvec vec;
+      /* prepare 'call' pattern */
+      if (sext)
+	{
+	  op1 = gen_rtx_SIGN_EXTEND (op0mode, r10);
+	  op2 = gen_rtx_SIGN_EXTEND (op0mode, r12);
+	}
+      else
+	{
+	  op1 = r10;
+	  op2 = r12;
+	}
+
+      mult = gen_rtx_MULT (op0mode, op1, op2);
+      set = gen_rtx_SET (op0mode, r14, mult);
+      vec = gen_rtvec (3, set, clob1, clob2);
+
+      emit_move_insn (r10, operands[1]);
+      emit_move_insn (r12, operands[2]);
+      emit (gen_rtx_PARALLEL (VOIDmode, vec));
+      emit_move_insn (operands[0], r14);
+      return 1;
+    }
+  if (op1mode == QImode)
+    {
+      m_mpys = gen_lowpart (QImode, mpys_rtx);
+      m_op2 = gen_lowpart (QImode, op2_rtx);
+    }
+
+  if (op0mode == QImode)
+    m_reslo = gen_lowpart (QImode, reslo_rtx);
+
+  if (!MSP430_HWMUL_NO_INT)
+    emit_insn (gen_reent_in ());
+
+  LOAD_MPYS (operands[1]);
+  if (sext)
+    emit_insn (gen_extendqihi2 (mpys_rtx, m_mpys));
+  LOAD_OP2 (operands[2]);
+  if (sext)
+    emit_insn (gen_extendqihi2 (op2_rtx, m_op2));
+
+  if (MSP430_HWMUL_NO_INT)
+    {
+      emit_move_insn (operands[0], m_reslo);
+    }
+  else
+    {
+      if (op0mode == HImode)
+	emit_insn (gen_fetch_result_hi (operands[0]));
+      else
+	emit_insn (gen_fetch_result_qi (operands[0]));
+    }
+
+  return 1;
+}
+
+
+int
+msp430_umul3_guard (operands, sext)
+     rtx operands[];
+     int sext ATTRIBUTE_UNUSED;
+{
+  rtx m_mpy = mpy_rtx;
+  rtx m_op2 = op2_rtx;
+  rtx m_reslo = reslo_rtx;
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  rtx r12 = gen_rtx_REG (op1mode, 12);
+  rtx r10 = gen_rtx_REG (op1mode, 10);
+  rtx r14 = gen_rtx_REG (op0mode, 14);
+
+  if (const_int_operand (operands[2], VOIDmode) &&
+      msp430_easy_mul (operands, 0))
+    return 1;
+
+  if (!msp430_has_hwmul)
+    {
+      rtx clob1 = gen_rtx_CLOBBER (VOIDmode, r10);
+      rtx clob2 = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (op1mode, 12));
+      rtx set;
+      rtx mult, op1, op2;
+      rtvec vec;
+      /* prepare 'call' pattern */
+      op1 = gen_rtx_ZERO_EXTEND (op0mode, r10);
+      op2 = gen_rtx_ZERO_EXTEND (op0mode, r12);
+
+      mult = gen_rtx_MULT (op0mode, op1, op2);
+      set = gen_rtx_SET (op0mode, r14, mult);
+      vec = gen_rtvec (3, set, clob1, clob2);
+
+      emit_move_insn (r10, operands[1]);
+      emit_move_insn (r12, operands[2]);
+      emit (gen_rtx_PARALLEL (VOIDmode, vec));
+      emit_move_insn (operands[0], r14);
+      return 1;
+    }
+
+  m_mpy = gen_lowpart (QImode, mpy_rtx);
+  m_op2 = gen_lowpart (QImode, op2_rtx);
+
+  if (!MSP430_HWMUL_NO_INT)
+    emit_insn (gen_reent_in ());
+
+  LOAD_MPY (operands[1]);
+  emit_insn (gen_zero_extendqihi2 (mpy_rtx, m_mpy));
+  LOAD_OP2 (operands[2]);
+  emit_insn (gen_zero_extendqihi2 (op2_rtx, m_op2));
+
+  if (MSP430_HWMUL_NO_INT)
+    emit_move_insn (operands[0], m_reslo);
+  else
+    emit_insn (gen_fetch_result_hi (operands[0]));
+
+  return 1;
+}
+
+
+int
+msp430_mulhisi_guard (operands)
+     rtx operands[];
+{
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  rtx r12 = gen_rtx_REG (op1mode, 12);
+  rtx r10 = gen_rtx_REG (op1mode, 10);
+  rtx r14 = gen_rtx_REG (op0mode, 14);
+  rtx r11 = gen_rtx_REG (op1mode, 11);
+  rtx r13 = gen_rtx_REG (op1mode, 13);
+
+  if (const_int_operand (operands[2], VOIDmode) &&
+      msp430_easy_mul (operands, 1))
+    return 1;
+
+  if (!msp430_has_hwmul)
+    {
+      rtx clob1 = gen_rtx_CLOBBER (VOIDmode, r10);
+      rtx clob2 = gen_rtx_CLOBBER (VOIDmode, r11);
+      rtx clob3 = gen_rtx_CLOBBER (VOIDmode, r12);
+      rtx clob4 = gen_rtx_CLOBBER (VOIDmode, r13);
+
+      rtx set;
+      rtx mult, op1, op2;
+      rtvec vec;
+      /* prepare 'call' pattern */
+      op1 = gen_rtx_SIGN_EXTEND (op0mode, r10);
+      op2 = gen_rtx_SIGN_EXTEND (op0mode, r12);
+
+      mult = gen_rtx_MULT (op0mode, op1, op2);
+      set = gen_rtx_SET (op0mode, r14, mult);
+      vec = gen_rtvec (5, set, clob1, clob2, clob3, clob4);
+
+      emit_move_insn (r10, operands[1]);
+      emit_move_insn (r12, operands[2]);
+      emit (gen_rtx_PARALLEL (VOIDmode, vec));
+      emit_move_insn (operands[0], r14);
+      return 1;
+    }
+  if (!MSP430_HWMUL_NO_INT)
+    emit_insn (gen_reent_in ());
+
+  LOAD_MPYS (operands[1]);
+  LOAD_OP2 (operands[2]);
+
+  if (MSP430_HWMUL_NO_INT)
+    {
+      emit_move_insn (gen_lowpart (HImode, operands[0]), reslo_rtx);
+      emit_move_insn (gen_highpart (HImode, operands[0]), reshi_rtx);
+    }
+  else
+    emit_insn (gen_fetch_result_si (operands[0]));
+
+  return 1;
+}
+
+
+int
+msp430_umulhisi_guard (operands)
+     rtx operands[];
+{
+  enum machine_mode op0mode = GET_MODE (operands[0]);
+  enum machine_mode op1mode = GET_MODE (operands[1]);
+  rtx r12 = gen_rtx_REG (op1mode, 12);
+  rtx r10 = gen_rtx_REG (op1mode, 10);
+  rtx r14 = gen_rtx_REG (op0mode, 14);
+  rtx r11 = gen_rtx_REG (op1mode, 11);
+  rtx r13 = gen_rtx_REG (op1mode, 13);
+
+  if (const_int_operand (operands[2], VOIDmode) &&
+      msp430_easy_mul (operands, 0))
+    return 1;
+
+  if (!msp430_has_hwmul)
+    {
+      rtx clob1 = gen_rtx_CLOBBER (VOIDmode, r10);
+      rtx clob2 = gen_rtx_CLOBBER (VOIDmode, r11);
+      rtx clob3 = gen_rtx_CLOBBER (VOIDmode, r12);
+      rtx clob4 = gen_rtx_CLOBBER (VOIDmode, r13);
+
+      rtx set;
+      rtx mult, op1, op2;
+      rtvec vec;
+      /* prepare 'call' pattern */
+      op1 = gen_rtx_ZERO_EXTEND (op0mode, r10);
+      op2 = gen_rtx_ZERO_EXTEND (op0mode, r12);
+
+      mult = gen_rtx_MULT (op0mode, op1, op2);
+      set = gen_rtx_SET (op0mode, r14, mult);
+      vec = gen_rtvec (5, set, clob1, clob2, clob3, clob4);
+
+      emit_move_insn (r10, operands[1]);
+      emit_move_insn (r12, operands[2]);
+      emit (gen_rtx_PARALLEL (VOIDmode, vec));
+      emit_move_insn (operands[0], r14);
+      return 1;
+    }
+
+  if (!MSP430_HWMUL_NO_INT)
+    emit_insn (gen_reent_in ());
+
+  LOAD_MPY (operands[1]);
+  LOAD_OP2 (operands[2]);
+
+  if (MSP430_HWMUL_NO_INT)
+    {
+      emit_move_insn (gen_lowpart (HImode, operands[0]), reslo_rtx);
+      emit_move_insn (gen_highpart (HImode, operands[0]), reshi_rtx);
+    }
+  else
+    emit_insn (gen_fetch_result_si (operands[0]));
+
+  return 1;
+}
+
+
+/* something like 'push x(r1)' or 'push @r1' */
+int
+self_push (x)
+     rtx x;
+{
+  rtx c;
+  rtx r;
+
+  if (GET_CODE (x) != MEM)
+    return 0;
+
+  c = XEXP (x, 0);
+
+  if (REG_P (c) && REGNO (c) == 1)
+    return 1;
+
+  if (GET_CODE (c) == PLUS)
+    {
+      r = XEXP (c, 0);
+      if (REG_P (r) && REGNO (r) == 1)
+	return 1;
+    }
+  return 0;
+}
+
+/* difficult pushes.
+   if planets are not aligned, the combiner does not allocate
+   r4 as a frame pointer. Instead, it uses stack pointer for frame.
+   If there is a va_arg call and non-register local var has to be passed 
+   as a function parameter, the push X(r1) in SI, SF and DI modes will
+   corrupt passed var. The following minds this fact */
+
+
+const char *
+msp430_pushqi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int sp = self_push (operands[0]);
+  int dummy = 0;
+
+  if (sp)
+    {
+      rtx c;
+      c = XEXP (operands[0], 0);
+      if (REG_P (c))
+	OUT_INSN (len, "push.b\t2(%E0)", operands);
+      else
+	OUT_INSN (len, "push.b\t2+%A0", operands);
+      dummy = 2;
+    }
+  else
+    {
+      OUT_INSN (len, "push.b\t%A0", operands);
+      dummy = 2;
+
+      if (GET_CODE (operands[0]) == CONST_INT)
+	{
+	  int cval = INTVAL (operands[0]);
+	  int x = (cval) & 0x0fffful;
+	  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8 || x == 0xffff)
+	    dummy--;
+
+	}
+      else if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      else if (GET_CODE (operands[0]) == MEM && REG_P (XEXP (operands[0], 0)))
+	dummy--;
+    }
+
+  return "";
+}
+
+const char *
+msp430_pushhi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int sp = self_push (operands[0]);
+  int dummy = 0;
+
+  if (sp)
+    {
+      rtx c;
+      c = XEXP (operands[0], 0);
+      if (REG_P (c))
+	OUT_INSN (len, "push\t2(%E0)", operands);
+      else
+	OUT_INSN (len, "push\t2+%A0", operands);
+      dummy = 2;
+    }
+  else
+    {
+      OUT_INSN (len, "push\t%A0", operands);
+      dummy = 2;
+
+      if (GET_CODE (operands[0]) == CONST_INT)
+	{
+	  int cval = INTVAL (operands[0]);
+	  int x = (cval) & 0x0fffful;
+
+	  if (cval == 99999999)
+	    {
+	      if (len)
+		*len = 3;
+	      return "";
+	    }
+
+	  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8 || x == 0xffff)
+	    dummy--;
+
+	}
+      else if (GET_CODE (operands[0]) == REG)
+	dummy--;
+      else if (GET_CODE (operands[0]) == MEM && REG_P (XEXP (operands[0], 0)))
+	dummy--;
+    }
+  if (len)
+    *len = dummy;
+  return "";
+}
+
+const char *
+msp430_pushsisf (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int sp = self_push (operands[0]);
+  int dummy = 0;
+
+  if (!sp)
+    {
+      OUT_INSN (len, "push\t%B0", operands);
+      OUT_INSN (len, "push\t%A0", operands);
+      dummy = 4;
+      if (indexed_location (operands[0]))
+	dummy--;
+      if (REG_P (operands[0]))
+	dummy -= 2;
+      if (GET_CODE (operands[0]) == CONST_INT)
+	{
+	  int cval = INTVAL (operands[0]);
+	  int x = (cval) & 0x0fffful;
+	  int y = (((unsigned long) (cval)) & 0xffff0000ul >> 16);
+	  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8 || x == 0xffff)
+	    dummy--;
+	  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8 || y == 0xffff)
+	    dummy--;
+	}
+      else if (GET_CODE (operands[0]) == CONST_DOUBLE
+	       && GET_MODE (operands[0]) == SFmode)
+	{
+	  long val;
+	  int y, x;
+	  REAL_VALUE_TYPE rv;
+	  REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[0]);
+	  REAL_VALUE_TO_TARGET_SINGLE (rv, val);
+
+	  y = (val & 0xffff0000ul) >> 16;
+	  x = val & 0xffff;
+	  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8 || x == 0xffff)
+	    dummy--;
+	  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8 || y == 0xffff)
+	    dummy--;
+	}
+    }
+  else
+    {
+      OUT_INSN (len, "push\t2+%B0", operands);
+      OUT_INSN (len, "push\t2+%B0", operands);
+      dummy = 4;
+    }
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+
+const char *
+msp430_pushdi (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[];
+     int *len;
+{
+  int sp = self_push (operands[0]);
+  int dummy = 0;
+
+  if (!sp)
+    {
+      OUT_INSN (len, "push\t%D0", operands);
+      OUT_INSN (len, "push\t%C0", operands);
+      OUT_INSN (len, "push\t%B0", operands);
+      OUT_INSN (len, "push\t%A0", operands);
+
+      dummy = 8;
+      if (indexed_location (operands[0]))
+	dummy--;
+      if (REG_P (operands[0]))
+	dummy -= 4;
+      if (GET_CODE (operands[0]) == CONST_DOUBLE)
+	{
+	  int hi = CONST_DOUBLE_HIGH (operands[0]);
+	  int lo = CONST_DOUBLE_LOW (operands[0]);
+	  int x, y, z;
+
+	  x = (hi & 0xffff0000ul) >> 16;
+	  y = hi & 0xffff;
+	  z = (lo & 0xffff0000ul) >> 16;
+	  if (x == 0 || x == 1 || x == 2 || x == 4 || x == 8 || x == 0xffff)
+	    dummy--;
+	  if (y == 0 || y == 1 || y == 2 || y == 4 || y == 8 || y == 0xffff)
+	    dummy--;
+	  if (z == 0 || z == 1 || z == 2 || z == 4 || z == 8 || z == 0xffff)
+	    dummy--;
+	  z = lo & 0xffff;
+	  if (z == 0 || z == 1 || z == 2 || z == 4 || z == 8 || z == 0xffff)
+	    dummy--;
+	}
+    }
+  else
+    {
+      OUT_INSN (len, "push\t2+%D0", operands);
+      OUT_INSN (len, "push\t2+%D0", operands);
+      OUT_INSN (len, "push\t2+%D0", operands);
+      OUT_INSN (len, "push\t2+%D0", operands);
+      dummy = 8;
+    }
+
+  if (len)
+    *len = dummy;
+
+  return "";
+}
+
+int
+dead_or_set_in_peep (which, insn, x)
+     int which;
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx x;
+{
+  rtx r;
+  rtx next;
+
+  next = peep2_next_insn (which);
+  if (!next)
+    return 0;
+  if (!REG_P (x))
+    return 0;
+  r = find_regno_note (next, REG_DEAD, REGNO (x));
+
+  if (!r)
+    return 0;
+
+  return GET_MODE (r) == GET_MODE (x);
+}
+
+void
+msp430_trampoline_template (FILE * fd)
+{
+  fprintf (fd, "; TRAMPOLINE HERE\n"
+	   "; move context (either r1 or r4) to r6\n"
+	   "; call function (0xf0f0 will be changed)\n");
+  fprintf (fd, "\tmov	#0xf0f0, r6\n");
+  fprintf (fd, "\tbr	#0xf0f0\n");
+  fprintf (fd, "; END OF TRAMPOLINE\n\n");
+}
+
+void
+msp430_initialize_trampoline (tramp, fn, ctx)
+     rtx tramp;
+     rtx fn;
+     rtx ctx;
+{
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, 2)), ctx);
+  emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, 6)), fn);
+}
+
+const char *
+msp430_emit_return (insn, operands, len)
+     rtx insn ATTRIBUTE_UNUSED;
+     rtx operands[] ATTRIBUTE_UNUSED;
+     int *len ATTRIBUTE_UNUSED;
+{
+  return_issued = 1;
+  if (msp430_empty_epilogue () == 1)
+    return "ret";
+
+  return "reti";
+}
+
+int
+three_operands_msp430 (x, mode)
+     rtx x;
+     enum machine_mode mode;
+{
+  enum rtx_code code = GET_CODE (x);
+  if (GET_MODE (x) != mode)
+    return 0;
+
+  return (code == PLUS
+	  || code == MINUS || code == AND || code == IOR || code == XOR);
+}
+
+int
+equality_operator (op, mode)
+     register rtx op;
+     enum machine_mode mode;
+{
+  return ((mode == VOIDmode || GET_MODE (op) == mode)
+	  && (GET_CODE (op) == EQ || GET_CODE (op) == NE));
+}
+
+/* Return 1 if this is a comparison operator but not an EQ or NE operator.  */
+int
+inequality_operator (op, mode)
+     register rtx op;
+     enum machine_mode mode;
+{
+  return comparison_operator (op, mode) && !equality_operator (op, mode);
+}
+
+
+static void
+msp430_asm_out_ctor (symbol, priority)
+    rtx symbol;
+    int priority;
+{
+  fputs ("\t.global __do_global_ctors\n", asm_out_file);
+  default_ctor_section_asm_out_constructor (symbol, priority);
+}
+
+static void
+msp430_asm_out_dtor (symbol, priority)
+    rtx symbol;
+    int priority;
+{
+  fputs ("\t.global __do_global_dtors\n", asm_out_file);
+  default_dtor_section_asm_out_destructor (symbol, priority);
+}
+
+
+/*
+rtx
+msp430_lo(mode, x)
+    enum machine_mode mode;
+    register rtx op;
+{
+    if(GET_CODE(x) == CONST_INT)
+    {
+      int v = INTVAL(x);
+      return GEN_INT (trunc_int_for_mode(mode, v));
+    }
+    else if(GET_CODE(x) == CONST_DOUBLE && GET_MODE(x) == SFmode)
+    {
+      long v;
+      REAL_VALUE_TYPE rv;
+      REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+      REAL_VALUE_TO_TARGET_SINGLE (rv, val);
+      return GEN_INT (trunc_int_for_mode(mode, v));
+    }
+    else if(GET_CODE(x) == CONST_DOUBLE && GET_MODE(x) == VOIDmode)
+    {
+      long l = CONST_DOUBLE_LOW(x);
+
+      if(GET_MODE_SIZE(mode) > GET_MODE_SIZE(SImode))
+	abort();
+      GEN_INT (trunc_int_for_mode(mode, l));
+    }
+    
+    return gen_lowpart(mode, x);
+}
+*/
diff -Nru gcc-3.3-orig/gcc/config/msp430/msp430.h gcc-3.3/gcc/config/msp430/msp430.h
--- gcc-3.3-orig/gcc/config/msp430/msp430.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/msp430.h	2006-01-30 09:44:49.000000000 +0100
@@ -0,0 +1,1008 @@
+
+/* Definitions of target machine for GNU compiler,
+   for Texas Instruments MSP430 microcontrollers.
+   Copyright (C) 2001,2002,2003 Free Software Foundation, Inc.
+   Contributed by Dmitry Diky <diwil@mail.ru>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+
+#ifndef __MSP430_H__
+#define __MSP430_H__
+
+#define TARGET_CPU_CPP_BUILTINS()                       \
+do{							\
+  builtin_define_std ("MSP430");			\
+  builtin_define_std ("__MSP430__");			\
+  if(TARGET_NO_HW_MUL)					\
+    builtin_define ("MSP430_NO_HW_MUL");		\
+  else							\
+    builtin_define ("MSP430_HAS_HW_MUL");		\
+}while(0)
+
+extern int target_flags;
+
+#define MASK_ALL_DEBUG		0x00000FE0
+#define MASK_FORCE_HW_MUL	0x00001000
+#define MASK_NO_STACK_INIT	0x00008000
+#define MASK_NO_VOLAT_WRKAR	0x00010000
+#define MASK_REORDER		0x00020000
+#define MASK_INLINESIHWMUL	0x00040000
+#define MASK_NO_HW_MUL		0x00100000
+#define MASK_HWMUL_NO_INT	0x00200000
+#define MASK_SAVE_PROLOGUE	0x00400000
+
+#define TARGET_NO_HW_MUL	(target_flags & MASK_NO_HW_MUL)
+#define TARGET_HW_MUL		(target_flags & MASK_FORCE_HW_MUL)
+#define TARGET_HWMUL_NO_INT	(target_flags & MASK_HWMUL_NO_INT)
+#define TARGET_ALL_DEBUG 	(target_flags & MASK_ALL_DEBUG)
+#define TARGET_NSI		(target_flags & MASK_NO_STACK_INIT)
+#define TARGET_NVWA		(target_flags & MASK_NO_VOLAT_WRKAR)
+#define TARGET_REORDER		(target_flags & MASK_REORDER)
+#define TARGET_INLINESIHWMUL	(target_flags & MASK_INLINESIHWMUL)
+#define TARGET_SAVE_PROLOGUE	(target_flags & MASK_SAVE_PROLOGUE)
+
+
+#define TARGET_SWITCHES {						\
+  { "deb", MASK_ALL_DEBUG, NULL },					\
+  { "force-hw-mul", MASK_FORCE_HW_MUL,N_("Force hardware multiplier") },\
+  { "no-stack-init",MASK_NO_STACK_INIT,N_("No stack init in main()") },	\
+  { "no-volatile-workaround",MASK_NO_STACK_INIT,N_("Do not perform volatile workaround for bitwise operations") }, \
+  { "reorder", MASK_REORDER, N_("Reverse registers allocation order") }, \
+  { "inline-hwmul", MASK_INLINESIHWMUL, N_("Issue inline multiplication code for 32-bit integers") }, \
+  { "disable-hwmul", MASK_NO_HW_MUL, N_("Disable hardware multiplier") }, \
+  { "hwmul-no-int", MASK_HWMUL_NO_INT, ("Assume interrupt routine does not do hardware multiply")}, \
+  { "save-prologue",MASK_SAVE_PROLOGUE, ("Use subroutine call for function prologue/epilogue when possible")}, \
+  { "", 0, NULL } \
+}
+
+extern const char *msp430_endup;
+extern const char *msp430_init_stack;
+extern const char *msp430_mcu_name;
+extern int msp430_has_hwmul;
+
+
+#define MSP430_HAS_HWMUL (msp430_has_hwmul)
+
+int msp430_current_function_hwmul_no_int_function_p(void);
+#define MSP430_HWMUL_NO_INT (msp430_current_function_hwmul_no_int_function_p())
+
+#define TARGET_OPTIONS {						      \
+ { "init-stack=", &msp430_init_stack, N_("Specify the initial stack address") }, \
+ { "mcu=", &msp430_mcu_name, N_("Specify the MCU name") }, \
+ { "endup-at=",&msp430_endup,N_("Jump to specified routine at the end of main()")} \
+}
+
+#define TARGET_VERSION fprintf (stderr, " (GNU assembler syntax)");
+
+#define OVERRIDE_OPTIONS msp430_override_options()
+
+#define CAN_DEBUG_WITHOUT_FP
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 0
+#define WORDS_BIG_ENDIAN 0
+#define BITS_PER_UNIT 8
+#define BITS_PER_WORD 16
+
+#define UNITS_PER_WORD 2
+
+#define POINTER_SIZE 16
+#define MAX_FIXED_MODE_SIZE 32
+#define PARM_BOUNDARY 16
+#define FUNCTION_BOUNDARY 16
+#define EMPTY_FIELD_BOUNDARY 16
+#define BIGGEST_ALIGNMENT 16
+#define STRICT_ALIGNMENT 0
+#define INT_TYPE_SIZE  16
+#define SHORT_TYPE_SIZE 16
+#define LONG_TYPE_SIZE 32
+#define MAX_LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define  CHAR_TYPE_SIZE 8
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 32
+#define LONG_DOUBLE_TYPE_SIZE 32
+#define DEFAULT_SIGNED_CHAR 1
+
+#define SIZE_TYPE ("unsigned int")
+#define PTRDIFF_TYPE ("int")
+#define WCHAR_TYPE_SIZE 16
+
+
+#define FIRST_PSEUDO_REGISTER 16
+
+#define FIXED_REGISTERS {\
+  1,1,/* r0 r1 == PC  SP */\
+  1,1,/* r2 r3 == CG1(SR) CG2*/\
+  0,0,/* r4 r5 */\
+  0,0,/* r6 r7 */\
+  0,0,/* r8 r9 */\
+  0,0,/* r10 r11 */\
+  0,0,/* r12 r13 */\
+  0,0,/* r14 r15 */\
+}
+
+#define CALL_USED_REGISTERS {			\
+    1,1,/* r0 r1 */				\
+    1,1,/* r2 r3 */				\
+    0,0,/* r4 r5 */				\
+    0,0,/* r6 r7 */				\
+    0,0,/* r8 r9 */				\
+    0,0,/* r10 r11 */				\
+    1,1,/* r12 r13 */				\
+    1,1,/* r14 r15 */				\
+}
+
+#define NON_SAVING_SETJMP 0
+
+#define REG_ALLOC_ORDER { 15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0 }
+
+#define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()
+
+#define HARD_REGNO_NREGS(REGNO, MODE) \
+((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
+
+#define MODES_TIEABLE_P(MODE1, MODE2)           	0
+
+enum reg_class {
+  NO_REGS,
+  PC_REG,			/* r0  - PC	*/
+  SP_REG,			/* r1  - SP	*/
+  STACK_REGS,			/* r2  - SR	*/
+  CG1_REG,			/* r2  - CG1	*/
+  CG2_REG,			/* r3  - CG2	*/
+  CG_REGS,			/* r2, r3	*/
+  GENERAL_REGS,			/* r4 - r15 	*/
+  POINTER_REGS,
+  FFOUR_REG,
+  ALL_REGS, LIM_REG_CLASSES
+};
+  
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES {		\
+		"NO_REGS",		\
+		"PC_REG",		\
+		"SP_REG",		\
+		"STACK_REGS",		\
+		"CG1_REG",		\
+		"CG2_REG",		\
+		"CG_REGS",		\
+		"GENERAL_REGS",		\
+		"POINTER_REGS",		\
+		"FFOUR_REG",		\
+		"ALL_REGS" 		\
+}
+
+
+#define REG_CLASS_CONTENTS {				\
+  {0x00000000ul},	/* NO_REGS	*/	\
+  {0x00000001ul},	/* PC_REG 	*/	\
+  {0x00000002ul},	/* SP_REG 	*/	\
+  {0x00000004ul},	/* r2		*/	\
+  {0x00000004ul},	/* r2		*/	\
+  {0x00000008ul},	/* r3		*/	\
+  {0x0000000cul},	/* r2,r3	*/	\
+  {0x0000fff2ul}, /* r4 - r15,r1  */      \
+  {0x0000fff2ul}, /* r4 - r15,r1  */      \
+  {0x0000fff0ul},	/* r4 - r15	*/	\
+  {0x0000fffful}	/* ALL_REGS */		\
+}
+
+enum reg_class msp430_regno_reg_class PARAMS ((int));
+#define REGNO_REG_CLASS(R) msp430_regno_reg_class(R)
+
+#define BASE_REG_CLASS POINTER_REGS
+
+#define INDEX_REG_CLASS NO_REGS
+
+#define REG_CLASS_FROM_LETTER(C) msp430_reg_class_from_letter(C)
+
+#define REGNO_OK_FOR_BASE_P(r) msp430_regno_ok_for_base_p(r) 
+					
+#define REGNO_OK_FOR_INDEX_P(NUM) 0
+
+#define PREFERRED_RELOAD_CLASS(X, CLASS) FFOUR_REG
+
+#define SMALL_REGISTER_CLASSES 1
+
+#define CLASS_MAX_NREGS(CLASS, MODE)	\
+	((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* In the following defenition only 'P' matters. All other left here for 
+ backward compatibility */
+#define CONST_OK_FOR_LETTER_P(VALUE, C)				\
+  ((C) == 'I' ? (VALUE) >= -32767 && (VALUE) <= 32767 :		\
+   (C) == 'J' ? (VALUE) <= 0 && (VALUE) >= -32767:		\
+   (C) == 'K' ? (VALUE) >= 0 && (VALUE) <= 32767 :		\
+   (C) == 'L' ? (VALUE) >= 0 && (VALUE) <= 0xff	 :		\
+   (C) == 'M' ? (VALUE) >= 0x10 && (VALUE) <= 0xff :		\
+   (C) == 'N' ? (VALUE) >= 0x100 && (VALUE) <= 0x1ff :		\
+   (C) == 'O' ? (VALUE)&1:					\
+   (C) == 'P' ? ((VALUE)==-1||(VALUE)==1||(VALUE)==2||(VALUE)==4||(VALUE)==8 ||(VALUE)==0) : 0)
+
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'G' ? (VALUE) == CONST0_RTX (SFmode)	\
+   : 0)
+
+#define EXTRA_CONSTRAINT(x, c) extra_constraint(x, c)
+
+#define STACK_PUSH_CODE POST_DEC
+
+#define STACK_GROWS_DOWNWARD
+
+#define STARTING_FRAME_OFFSET 0
+
+#define STACK_POINTER_OFFSET 0
+
+#define FIRST_PARM_OFFSET(FUNDECL) 0
+
+#define STACK_BOUNDARY 16
+
+#define STACK_POINTER_REGNUM 1
+
+#define FRAME_POINTER_REGNUM 4
+
+#define ARG_POINTER_REGNUM 5
+
+#define STATIC_CHAIN_REGNUM 6
+
+#define FRAME_POINTER_REQUIRED   frame_pointer_required_p()
+
+#define ELIMINABLE_REGS {			\
+   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
+   {ARG_POINTER_REGNUM, STACK_POINTER_REGNUM} \
+}
+
+#define CAN_ELIMINATE(FROM, TO) 1
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+     OFFSET = initial_elimination_offset (FROM, TO)
+
+#define PUSH_ROUNDING(NPUSHED) ((NPUSHED+1) & ~1)
+
+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0
+
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+(function_arg (&(CUM), MODE, TYPE, NAMED))
+
+typedef struct msp430_args {
+  int nregs;			/* # registers available for passing */
+  int regno;			/* next available register number */
+} CUMULATIVE_ARGS;
+
+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT) \
+init_cumulative_args (&(CUM), FNTYPE, LIBNAME, INDIRECT)
+
+#define  INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME) \
+init_cumulative_incoming_args(&(CUM), FNTYPE, LIBNAME)
+
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)	\
+  (function_arg_advance (&CUM, MODE, TYPE, NAMED))
+
+#define FUNCTION_ARG_REGNO_P(r) (r >= 12 && r <= 15)
+
+extern int msp430_reg_order[];
+
+#define RET_REGISTER  15 /* msp430_ret_register ()*/
+
+#define FUNCTION_VALUE(VALTYPE, FUNC) msp430_function_value (VALTYPE, FUNC)
+
+#define LIBCALL_VALUE(MODE)  msp430_libcall_value (MODE)
+
+#define FUNCTION_VALUE_REGNO_P(N) ((N) == RET_REGISTER)
+
+#define RETURN_IN_MEMORY(TYPE) ((TYPE_MODE (TYPE) == BLKmode)	\
+				? int_size_in_bytes (TYPE) > 8	\
+				: 0)
+
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+#define STRUCT_VALUE 0
+#define STRUCT_VALUE_INCOMING 0
+
+#define STRICT_ARGUMENT_NAMING 1
+
+#define HAVE_POST_INCREMENT 	1
+
+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)
+
+#define MAX_REGS_PER_ADDRESS 1
+
+#ifdef REG_OK_STRICT
+#  define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR)	\
+{							\
+  if (legitimate_address_p (mode, operand, 1))		\
+    goto ADDR;						\
+}
+#  else
+#  define GO_IF_LEGITIMATE_ADDRESS(mode, operand, ADDR)	\
+{							\
+  if (legitimate_address_p (mode, operand, 0))		\
+    goto ADDR;						\
+}
+#endif
+
+#define REG_OK_FOR_BASE_NOSTRICT_P(X) \
+  (REGNO (X) >= FIRST_PSEUDO_REGISTER || REG_OK_FOR_BASE_STRICT_P(X))
+
+#define REG_OK_FOR_BASE_STRICT_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))
+
+#ifdef REG_OK_STRICT
+#  define REG_OK_FOR_BASE_P(X) REG_OK_FOR_BASE_STRICT_P (X)
+#else
+#  define REG_OK_FOR_BASE_P(X) REG_OK_FOR_BASE_NOSTRICT_P (X)
+#endif
+
+#define REG_OK_FOR_INDEX_P(X) 0 /*( REGNO(X)!=3 && REGNO(X)!=2 &&REGNO(X)<=15) */
+
+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)				\
+GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN)
+
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)			{}
+
+#define LEGITIMATE_CONSTANT_P(X) 1
+
+#define CONST_COSTS(x,CODE,OUTER_CODE)		\
+    case CONST_INT:				\
+      if (OUTER_CODE == PLUS			\
+	  || OUTER_CODE == IOR			\
+	  || OUTER_CODE == AND			\
+	  || OUTER_CODE == MINUS		\
+	  || OUTER_CODE == SET			\
+	  || INTVAL (x) == 0			\
+          || INTVAL (x) == 1			\
+          || INTVAL (x) == 2			\
+          || INTVAL (x) == 4			\
+          || INTVAL (x) == 8			\
+          || INTVAL (x) == -1)			\
+        return 4;				\
+    case CONST:					\
+      return 8;					\
+    case LABEL_REF:				\
+      return 8;					\
+    case SYMBOL_REF:				\
+      return 8;					\
+    case CONST_DOUBLE:				\
+      return 16;
+
+#define ADDRESS_COST(ADDRESS) msp430_address_costs(ADDRESS)
+
+#define REGISTER_MOVE_COST(MODE, FROM, TO) ((MODE)==QImode ? 4 :   \
+					    (MODE)==HImode ? 4 :   \
+					    (MODE)==SImode ? 8 :   \
+					    (MODE)==SFmode ? 8 : 16)
+
+#define MEMORY_MOVE_COST(MODE,CLASS,IN) ((MODE)==QImode ? 8 :	\
+					 (MODE)==HImode ? 8 :	\
+					 (MODE)==SImode ? 18:	\
+					 (MODE)==SFmode ? 18: 32)
+#define BRANCH_COSTS 0
+#define SLOW_BYTE_ACCESS 0
+
+// #define NO_FUNCTION_CSE
+// #define NO_RECURSIVE_FUNCTION_CSE
+
+#define TEXT_SECTION_ASM_OP "\t.text"
+#define DATA_SECTION_ASM_OP "\t.data"
+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section
+#define EXTRA_SECTIONS in_bootloader, in_infomem
+
+#undef CTORS_SECTION_ASM_OP
+#define CTORS_SECTION_ASM_OP "\t.section .ctors,\"a\",@progbits"
+
+#undef DTORS_SECTION_ASM_OP
+#define DTORS_SECTION_ASM_OP "\t.section .dtors,\"a\",@progbits"
+
+#define TARGET_ASM_CONSTRUCTOR msp430_asm_out_ctor
+
+#define TARGET_ASM_DESTRUCTOR msp430_asm_out_dtor
+  
+#define EXTRA_SECTION_FUNCTIONS						      \
+									      \
+void									      \
+bootloader_section (void)							\
+{									      \
+  if (in_section != in_bootloader)						\
+    {									      \
+      fprintf (asm_out_file,						      \
+	       "\t.section .bootloader, \"ax\", @progbits\n");	      		\
+      /* Should already be aligned, this is just to be safe if it isn't.  */  \
+      fprintf (asm_out_file, "\t.p2align 1\n");				      \
+      in_section = in_bootloader;						\
+    }									      \
+}										\
+									      \
+void									      \
+infomem_section (void)							      \
+{									      \
+  if (in_section != in_infomem)						      \
+    {									      \
+      fprintf (asm_out_file,						      \
+	       "\t.section .infomem, \"a\", @progbits\n");	      		\
+      /* Should already be aligned, this is just to be safe if it isn't.  */  \
+      fprintf (asm_out_file, "\t.p2align 1\n");				      \
+      in_section = in_infomem;						      \
+    }									      \
+}
+
+#define JUMP_TABLES_IN_TEXT_SECTION 0
+
+#define UNIQUE_SECTION(DECL, RELOC) unique_section (DECL, RELOC)
+
+#define ASM_FILE_START(STREAM) asm_file_start (STREAM)
+#define ASM_FILE_END(STREAM) asm_file_end (STREAM)
+#define ASM_COMMENT_START " ; "
+#define ASM_APP_ON ";; APP\n"
+#define ASM_APP_OFF ";; NOAPP\n"
+#define ASM_OUTPUT_SOURCE_LINE(STREAM, LINE) fprintf (STREAM,"/* line: %d */\n",LINE)
+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC) \
+  asm_output_section_name(FILE, DECL, NAME, RELOC)
+
+#define OBJC_PROLOGUE {}
+
+#define ASM_OUTPUT_INT(FILE, VALUE)			\
+ ( fprintf (FILE, "\t.long "),				\
+   output_addr_const (FILE, (VALUE)),			\
+   fputs ("\n", FILE))
+
+#define ASM_OUTPUT_SHORT(FILE,VALUE) asm_output_short(FILE,VALUE)
+#define ASM_OUTPUT_CHAR(FILE,VALUE) asm_output_char(FILE,VALUE)
+#define ASM_OUTPUT_BYTE(FILE,VALUE) asm_output_byte (FILE,VALUE)
+#define ASM_BYTE_OP "\t.byte "
+#define ASM_OUTPUT_ASCII(FILE, P, SIZE)	 gas_output_ascii (FILE,P,SIZE)
+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C) ((C) == '\n')
+
+#define ASM_OUTPUT_LABELREF(FILE,NAME) 			\
+do{							\
+	const char *p = NAME;					\
+	while(*p == '_') p++;				\
+	if(*p == 'r' || *p == 'R')			\
+	{						\
+	    int val;					\
+	    char *endptr;				\
+	    p++;					\
+	    val = strtol (p, &endptr, 10);		\
+	    if(val >= 0 && val <= 15 &&			\
+	    	*endptr == 0 )				\
+	    {						\
+	    	asm_fprintf ((FILE), "_%U%s", (NAME));	\
+	    }						\
+	    else					\
+	    	asm_fprintf ((FILE), "%U%s", (NAME));   \
+	}						\
+	else						\
+		asm_fprintf ((FILE), "%U%s", (NAME));	\
+} while(0)
+
+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)	\
+do {							\
+     const char *p = NAME;					\
+     if(*p == '*' || *p == '@' ) p++;			\
+     if(*p >= '0' && *p <= '9' ) break;			\
+     fputs ("\t.comm ", (STREAM));			\
+     assemble_name ((STREAM), (NAME));			\
+     fprintf ((STREAM), ",%d%s", (SIZE), (SIZE)>1?",2\n":"\n");\
+} while (0)
+
+#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)	\
+do {							\
+     const char *p = NAME;					\
+     if(*p == '*' || *p == '@' ) p++;			\
+     if(*p >= '0' && *p <= '9' ) break;			\
+     fputs ("\t.local ", (STREAM));			\
+     assemble_name ((STREAM), (NAME));			\
+     fputs ("\n",(STREAM));				\
+     fputs ("\t.comm ", (STREAM));                     	\
+     assemble_name ((STREAM), (NAME));			\
+     fprintf ((STREAM), ",%d%s", (SIZE),(SIZE)>1?",2\n":"\n");\
+} while (0)
+
+#define BSS_SECTION_ASM_OP	"\t.section\t.bss"
+
+#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ROUNDED)                 \
+do { \
+  const char *p = (NAME); \
+  if(*p == '*' || *p == '@' ) p++; \
+  if(*p >= '0' && *p <= '9' ) break; \
+  asm_output_bss ((FILE), (DECL), (NAME), (SIZE), (ROUNDED)); \
+} while(0)
+  
+
+
+#define ASM_OUTPUT_LABEL(STREAM, NAME)		\
+{						\
+  assemble_name (STREAM, NAME);			\
+  fprintf (STREAM, ":\n");			\
+}
+
+#undef TYPE_ASM_OP
+#undef SIZE_ASM_OP
+#undef WEAK_ASM_OP
+#define TYPE_ASM_OP	"\t.type\t"
+#define SIZE_ASM_OP	"\t.size\t"
+#define WEAK_ASM_OP	"\t.weak\t"
+
+#undef TYPE_OPERAND_FMT
+#define TYPE_OPERAND_FMT	"@%s"
+
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \
+asm_declare_function_name (FILE, NAME, DECL)
+
+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)			\
+  do {									\
+    if (!flag_inhibit_size_directive)					\
+      {									\
+        char label[256];						\
+	static int labelno;						\
+	labelno++;							\
+	ASM_GENERATE_INTERNAL_LABEL (label, "Lfe", labelno);		\
+	ASM_OUTPUT_INTERNAL_LABEL (FILE, "Lfe", labelno);		\
+	fprintf (FILE, "%s", SIZE_ASM_OP);				\
+	assemble_name (FILE, (FNAME));					\
+        fprintf (FILE, ",");						\
+	assemble_name (FILE, label);					\
+        fprintf (FILE, "-");						\
+	assemble_name (FILE, (FNAME));					\
+	fprintf (FILE,"\n/********* End of function ******/\n\n");	\
+      }									\
+  } while (0)
+
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			  \
+do {									  \
+      fprintf (FILE, "%s", TYPE_ASM_OP);				  \
+      assemble_name (FILE, NAME);					  \
+      putc (',', FILE);							  \
+      fprintf (FILE, TYPE_OPERAND_FMT, "object");			  \
+      putc ('\n', FILE);						  \
+      size_directive_output = 0;					  \
+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))		  \
+	{								  \
+	  size_directive_output = 1;					  \
+	  fprintf (FILE, "%s", SIZE_ASM_OP);				  \
+	  assemble_name (FILE, NAME);					  \
+	  fprintf (FILE, ",%ld\n",  int_size_in_bytes (TREE_TYPE (DECL))); \
+    }									  \
+  ASM_OUTPUT_LABEL(FILE, NAME);						  \
+} while (0)
+
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	 \
+do {									 \
+     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);		 \
+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		 \
+         && ! AT_END && TOP_LEVEL					 \
+	 && DECL_INITIAL (DECL) == error_mark_node			 \
+	 && !size_directive_output)					 \
+       {								 \
+	 size_directive_output = 1;					 \
+	 fprintf (FILE, "%s", SIZE_ASM_OP);				 \
+	 assemble_name (FILE, name);					 \
+	 fprintf (FILE, ",%d\n",  int_size_in_bytes (TREE_TYPE (DECL))); \
+       }								 \
+   } while (0)
+
+#define ESCAPES \
+"\1\1\1\1\1\1\1\1btn\1fr\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\0\0\"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\
+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\0\0\
+\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\
+\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1"
+
+#define STRING_LIMIT	((unsigned) 64)
+#define STRING_ASM_OP	"\t.string\t"
+#define GLOBAL_ASM_OP ".global\t"
+     
+#define ASM_WEAKEN_LABEL(FILE, NAME) 	\
+  do					\
+    {					\
+      fputs ("\t.weak\t", (FILE));	\
+      assemble_name ((FILE), (NAME)); 	\
+      fputc ('\n', (FILE));		\
+    }					\
+  while (0)
+
+#define SUPPORTS_WEAK 1
+
+#define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)	\
+fprintf(STREAM, ".%s%d:\n", PREFIX, NUM)
+
+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)	\
+sprintf (STRING, "*.%s%d", PREFIX, NUM)
+
+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)	\
+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),	\
+  sprintf ((OUTPUT), "%s.%ld", (NAME), (LABELNO)))
+
+#define HAS_INIT_SECTION 1
+
+#define REGISTER_NAMES {				\
+  "r0","r1","r2","r3","r4","r5","r6","r7",		\
+  "r8","r9","r10","r11","r12","r13","r14","r15"		\
+}
+
+#define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)
+
+#define PRINT_OPERAND(STREAM, X, CODE) print_operand (STREAM, X, CODE)
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '~')
+#define PRINT_OPERAND_ADDRESS(STREAM, X) print_operand_address(STREAM, X)
+#define USER_LABEL_PREFIX ""
+#define ASSEMBLER_DIALECT MSP430_HAS_HWMUL
+
+#define ASM_OUTPUT_REG_PUSH(STREAM, REGNO)	\
+{						\
+  if (REGNO > 15)				\
+    abort ();					\
+  fprintf (STREAM, "\tpush\tr%d", REGNO);	\
+}
+
+#define ASM_OUTPUT_REG_POP(STREAM, REGNO)	\
+{						\
+  if (REGNO > 15)				\
+    abort ();					\
+  fprintf (STREAM, "\tpop\tr%d", REGNO);	\
+}
+
+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)		\
+  msp430_output_addr_vec_elt(STREAM, VALUE)
+
+#define ASM_OUTPUT_SKIP(STREAM, N)		\
+  fprintf (STREAM, "\t.skip %d,0\n", N)
+#define ASM_OUTPUT_ALIGN(STREAM, POWER) \
+  fprintf (STREAM, "\t.p2align %d,0\n", POWER)
+
+#define CASE_VECTOR_MODE HImode
+
+/* the X_msp430 have the same meaning as X, except
+   operands can be volatile */
+#define PREDICATE_CODES \
+{"memory_operand_msp430", {SUBREG, MEM}},	\
+{"nonimmediate_operand_msp430", {SUBREG, REG, MEM}},\
+{"general_operand_msp430", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF, LABEL_REF, SUBREG, REG, MEM}},\
+{"three_operands_msp430", {PLUS, MINUS, AND, IOR, XOR}}, \
+{"equality_operator", {EQ, NE }},                     \
+{"inequality_operator", {GE, GT, LE, LT, GEU, GTU, LEU, LTU }},
+
+extern struct rtx_def *msp430_compare_op0, *msp430_compare_op1;
+extern int msp430_case_values_threshold;
+#define CASE_VALUES_THRESHOLD msp430_case_values_threshold
+
+#undef WORD_REGISTER_OPERATIONS
+
+#define MOVE_MAX 2
+
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+#define Pmode HImode
+#define FUNCTION_MODE HImode
+     
+/*                            1        3 */
+#define INTEGRATE_THRESHOLD(DECL) (1 + (3 * list_length (DECL_ARGUMENTS (DECL)) / 2))
+
+
+#define DOLLARS_IN_IDENTIFIERS 0
+#define NO_DOLLAR_IN_LABEL 1
+
+#define MACHINE_DEPENDENT_REORG(INSN) machine_dependent_reorg (INSN)
+
+#define GIV_SORT_CRITERION(X, Y)	\
+  if (GET_CODE ((X)->add_val) == CONST_INT		\
+      && GET_CODE ((Y)->add_val) == CONST_INT)		\
+    return INTVAL ((X)->add_val) - INTVAL ((Y)->add_val);
+
+#define TARGET_BELL 007
+#define TARGET_BS 010
+#define TARGET_TAB 011
+#define TARGET_NEWLINE 012
+#define TARGET_VT 013
+#define TARGET_FF 014
+#define TARGET_CR 015
+#define TARGET_ESC 033
+
+#define TRAMPOLINE_TEMPLATE(FILE) msp430_trampoline_template((FILE))
+
+#define TRAMPOLINE_SIZE 8
+#define TRAMPOLINE_ALIGNMENT 16
+
+
+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)	\
+	msp430_initialize_trampoline (TRAMP, FNADDR, CXT)
+
+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)
+
+#define CC_OVERFLOW_UNUSABLE 01000
+/* The mov,and,or,xor insns don't set carry.  That's ok though as the
+   Z bit is all we need when doing unsigned comparisons on the result of
+   these insns (since they're always with 0).  However, conditions.h has
+   CC_NO_OVERFLOW defined for this purpose.  Rename it to something more
+   understandable.  */
+#define CC_NO_CARRY CC_NO_OVERFLOW
+
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fprintf (FILE, "/* profiler %d */", (LABELNO))
+
+#define ADJUST_INSN_LENGTH(INSN, LENGTH) (LENGTH =\
+					  adjust_insn_length (INSN, LENGTH))
+
+#define TARGET_MEM_FUNCTIONS
+
+#define CPP_SPEC "\
+%{!mmcu*|mmcu=msp1:%(cpp_msp1)} \
+%{mmcu=msp2:%(cpp_msp2) -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x110:%(cpp_msp1) -D__MSP430_110__} \
+%{mmcu=msp430x112:%(cpp_msp1) -D__MSP430_112__} \
+%{mmcu=msp430x1101:%(cpp_msp1) -D__MSP430_1101__} \
+%{mmcu=msp430x1111:%(cpp_msp1) -D__MSP430_1111__} \
+%{mmcu=msp430x1121:%(cpp_msp1) -D__MSP430_1121__} \
+%{mmcu=msp430x1122:%(cpp_msp1) -D__MSP430_1122__} \
+%{mmcu=msp430x1132:%(cpp_msp1) -D__MSP430_1132__} \
+%{mmcu=msp430x122:%(cpp_msp1) -D__MSP430_122__} \
+%{mmcu=msp430x123:%(cpp_msp1) -D__MSP430_123__} \
+%{mmcu=msp430x1222:%(cpp_msp1) -D__MSP430_1222__} \
+%{mmcu=msp430x1232:%(cpp_msp1) -D__MSP430_1232__} \
+%{mmcu=msp430x133:%(cpp_msp1) -D__MSP430_133__} \
+%{mmcu=msp430x135:%(cpp_msp1) -D__MSP430_135__} \
+%{mmcu=msp430x1331:%(cpp_msp1) -D__MSP430_1331__} \
+%{mmcu=msp430x1351:%(cpp_msp1) -D__MSP430_1351__} \
+%{mmcu=msp430x147:%(cpp_msp2) -D__MSP430_147__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x148:%(cpp_msp2) -D__MSP430_148__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x149:%(cpp_msp2) -D__MSP430_149__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x1471:%(cpp_msp2) -D__MSP430_1471__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x1481:%(cpp_msp2) -D__MSP430_1481__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x1491:%(cpp_msp2) -D__MSP430_1491__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x155:%(cpp_msp1) -D__MSP430_155__} \
+%{mmcu=msp430x156:%(cpp_msp1) -D__MSP430_156__} \
+%{mmcu=msp430x157:%(cpp_msp1) -D__MSP430_157__} \
+%{mmcu=msp430x167:%(cpp_msp2) -D__MSP430_167__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x168:%(cpp_msp2) -D__MSP430_168__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x169:%(cpp_msp2) -D__MSP430_169__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x1610:%(cpp_msp2) -D__MSP430_1610__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x1611:%(cpp_msp2) -D__MSP430_1611__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x1612:%(cpp_msp2) -D__MSP430_1612__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x2101:%(cpp_msp1) -D__MSP430_2101__} \
+%{mmcu=msp430x2111:%(cpp_msp1) -D__MSP430_2111__} \
+%{mmcu=msp430x2121:%(cpp_msp1) -D__MSP430_2121__} \
+%{mmcu=msp430x2131:%(cpp_msp1) -D__MSP430_2131__} \
+%{mmcu=msp430x311:%(cpp_msp1) -D__MSP430_311__} \
+%{mmcu=msp430x312:%(cpp_msp1) -D__MSP430_312__} \
+%{mmcu=msp430x313:%(cpp_msp1) -D__MSP430_313__} \
+%{mmcu=msp430x314:%(cpp_msp1) -D__MSP430_314__} \
+%{mmcu=msp430x315:%(cpp_msp1) -D__MSP430_315__} \
+%{mmcu=msp430x323:%(cpp_msp1) -D__MSP430_323__} \
+%{mmcu=msp430x325:%(cpp_msp1) -D__MSP430_325__} \
+%{mmcu=msp430x336:%(cpp_msp2) -D__MSP430_336__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x337:%(cpp_msp2) -D__MSP430_337__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x412:%(cpp_msp1) -D__MSP430_412__} \
+%{mmcu=msp430x413:%(cpp_msp1) -D__MSP430_413__} \
+%{mmcu=msp430x415:%(cpp_msp1) -D__MSP430_415__} \
+%{mmcu=msp430x417:%(cpp_msp1) -D__MSP430_417__} \
+%{mmcu=msp430x423:%(cpp_msp2) -D__MSP430_423__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x425:%(cpp_msp2) -D__MSP430_425__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x427:%(cpp_msp2) -D__MSP430_427__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x4250:%(cpp_msp1) -D__MSP430_4250__} \
+%{mmcu=msp430x4260:%(cpp_msp1) -D__MSP430_4260__} \
+%{mmcu=msp430x4270:%(cpp_msp1) -D__MSP430_4270__} \
+%{mmcu=msp430xE423:%(cpp_msp2) -D__MSP430_E423__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430xE425:%(cpp_msp2) -D__MSP430_E425__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430xE427:%(cpp_msp2) -D__MSP430_E427__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430xW423:%(cpp_msp1) -D__MSP430_W423__} \
+%{mmcu=msp430xW425:%(cpp_msp1) -D__MSP430_W425__} \
+%{mmcu=msp430xW427:%(cpp_msp1) -D__MSP430_W427__} \
+%{mmcu=msp430xG437:%(cpp_msp1) -D__MSP430_G437__} \
+%{mmcu=msp430xG438:%(cpp_msp1) -D__MSP430_G438__} \
+%{mmcu=msp430xG439:%(cpp_msp1) -D__MSP430_G439__} \
+%{mmcu=msp430x435:%(cpp_msp1) -D__MSP430_435__} \
+%{mmcu=msp430x436:%(cpp_msp1) -D__MSP430_436__} \
+%{mmcu=msp430x437:%(cpp_msp1) -D__MSP430_437__} \
+%{mmcu=msp430x447:%(cpp_msp2) -D__MSP430_447__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x448:%(cpp_msp2) -D__MSP430_448__ -DMSP430_HAS_HWMUL} \
+%{mmcu=msp430x449:%(cpp_msp2) -D__MSP430_449__ -DMSP430_HAS_HWMUL} \
+%{posix:-D_POSIX_SOURCE}"
+
+#define NO_BUILTIN_SIZE_TYPE
+#define NO_BUILTIN_PTRDIFF_TYPE
+
+#define CC1_SPEC "%{profile:-p}"
+
+#define CC1PLUS_SPEC "%{!frtti:-fno-rtti} \
+%{!fenforce-eh-specs:-fno-enforce-eh-specs} \
+%{!fexceptions:-fno-exceptions}"
+
+#define ASM_SPEC ""
+#define ASM_FINAL_SPEC ""
+
+#define LINK_SPEC "\
+%{!mmcu*:-m msp430x110} \
+%{mmcu=msp1:-m msp430x110} \
+%{mmcu=msp2:-m msp430x336} \
+%{mmcu=msp430x110:-m msp430x110 } \
+%{mmcu=msp430x112:-m msp430x112 } \
+%{mmcu=msp430x1101:-m msp430x1101 } \
+%{mmcu=msp430x1111:-m msp430x1111 } \
+%{mmcu=msp430x1121:-m msp430x1121 } \
+%{mmcu=msp430x1122:-m msp430x1122 } \
+%{mmcu=msp430x1132:-m msp430x1132 } \
+%{mmcu=msp430x122:-m msp430x122 } \
+%{mmcu=msp430x123:-m msp430x123 } \
+%{mmcu=msp430x1222:-m msp430x1222 } \
+%{mmcu=msp430x1232:-m msp430x1232 } \
+%{mmcu=msp430x133:-m msp430x133 } \
+%{mmcu=msp430x135:-m msp430x135 } \
+%{mmcu=msp430x1331:-m msp430x1331 } \
+%{mmcu=msp430x1351:-m msp430x1351 } \
+%{mmcu=msp430x147:-m msp430x147 } \
+%{mmcu=msp430x148:-m msp430x148 } \
+%{mmcu=msp430x149:-m msp430x149 } \
+%{mmcu=msp430x1471:-m msp430x1471 } \
+%{mmcu=msp430x1481:-m msp430x1481 } \
+%{mmcu=msp430x1491:-m msp430x1491 } \
+%{mmcu=msp430x155:-m msp430x155 } \
+%{mmcu=msp430x156:-m msp430x156 } \
+%{mmcu=msp430x157:-m msp430x157 } \
+%{mmcu=msp430x167:-m msp430x167 } \
+%{mmcu=msp430x168:-m msp430x168 } \
+%{mmcu=msp430x169:-m msp430x169 } \
+%{mmcu=msp430x1610:-m msp430x1610 } \
+%{mmcu=msp430x1611:-m msp430x1611 } \
+%{mmcu=msp430x1612:-m msp430x1612 } \
+%{mmcu=msp430x2101:-m msp430x2101 } \
+%{mmcu=msp430x2111:-m msp430x2111 } \
+%{mmcu=msp430x2121:-m msp430x2121 } \
+%{mmcu=msp430x2131:-m msp430x2131 } \
+%{mmcu=msp430x311:-m msp430x311 } \
+%{mmcu=msp430x312:-m msp430x312 } \
+%{mmcu=msp430x313:-m msp430x313 } \
+%{mmcu=msp430x314:-m msp430x314 } \
+%{mmcu=msp430x315:-m msp430x315 } \
+%{mmcu=msp430x323:-m msp430x323 } \
+%{mmcu=msp430x325:-m msp430x325 } \
+%{mmcu=msp430x336:-m msp430x336 } \
+%{mmcu=msp430x337:-m msp430x337 } \
+%{mmcu=msp430x412:-m msp430x412 } \
+%{mmcu=msp430x413:-m msp430x413 } \
+%{mmcu=msp430x415:-m msp430x415 } \
+%{mmcu=msp430x417:-m msp430x417 } \
+%{mmcu=msp430x423:-m msp430x423 } \
+%{mmcu=msp430x425:-m msp430x425 } \
+%{mmcu=msp430x427:-m msp430x427 } \
+%{mmcu=msp430x4250:-m msp430x4250 } \
+%{mmcu=msp430x4260:-m msp430x4260 } \
+%{mmcu=msp430x4270:-m msp430x4270 } \
+%{mmcu=msp430xE423:-m msp430xE423 } \
+%{mmcu=msp430xE425:-m msp430xE425 } \
+%{mmcu=msp430xE427:-m msp430xE427 } \
+%{mmcu=msp430xW423:-m msp430xW423 } \
+%{mmcu=msp430xW425:-m msp430xW425 } \
+%{mmcu=msp430xW427:-m msp430xW427 } \
+%{mmcu=msp430xG437:-m msp430xG437 } \
+%{mmcu=msp430xG438:-m msp430xG438 } \
+%{mmcu=msp430xG439:-m msp430xG439 } \
+%{mmcu=msp430x435:-m msp430x435 } \
+%{mmcu=msp430x436:-m msp430x436 } \
+%{mmcu=msp430x437:-m msp430x437 } \
+%{mmcu=msp430x447:-m msp430x447 } \
+%{mmcu=msp430x448:-m msp430x448 } \
+%{mmcu=msp430x449:-m msp430x449 }"
+
+#define LIB_SPEC "-lc"
+#define LIBGCC_SPEC "-lgcc"
+#define LIBSTDCXX "-lgcc"
+
+#define STARTFILE_SPEC "%(crt_binutils)"
+#define ENDFILE_SPEC ""
+
+#define CRT_BINUTILS_SPECS "\
+%{!mmcu=*|mmcu=msp430x110|mmcu=msp1:crt430x110.o%s} \
+%{mmcu=msp430x112:crt430x112.o%s} \
+%{mmcu=msp430x1101:crt430x1101.o%s} \
+%{mmcu=msp430x1111:crt430x1111.o%s} \
+%{mmcu=msp430x1121:crt430x1121.o%s} \
+%{mmcu=msp430x1122:crt430x1122.o%s} \
+%{mmcu=msp430x1132:crt430x1132.o%s} \
+%{mmcu=msp430x122:crt430x122.o%s} \
+%{mmcu=msp430x123:crt430x123.o%s} \
+%{mmcu=msp430x1222:crt430x1222.o%s} \
+%{mmcu=msp430x1232:crt430x1232.o%s} \
+%{mmcu=msp430x133:crt430x133.o%s} \
+%{mmcu=msp430x135:crt430x135.o%s} \
+%{mmcu=msp430x1331:crt430x1331.o%s} \
+%{mmcu=msp430x1351:crt430x1351.o%s} \
+%{mmcu=msp430x147:crt430x147.o%s} \
+%{mmcu=msp430x148:crt430x148.o%s} \
+%{mmcu=msp430x149:crt430x149.o%s} \
+%{mmcu=msp430x1471:crt430x1471.o%s} \
+%{mmcu=msp430x1481:crt430x1481.o%s} \
+%{mmcu=msp430x1491:crt430x1491.o%s} \
+%{mmcu=msp430x155:crt430x155.o%s} \
+%{mmcu=msp430x156:crt430x156.o%s} \
+%{mmcu=msp430x157:crt430x157.o%s} \
+%{mmcu=msp430x167:crt430x167.o%s} \
+%{mmcu=msp430x168:crt430x168.o%s} \
+%{mmcu=msp430x169:crt430x169.o%s} \
+%{mmcu=msp430x1610:crt430x1610.o%s} \
+%{mmcu=msp430x1611:crt430x1611.o%s} \
+%{mmcu=msp430x1612:crt430x1612.o%s} \
+%{mmcu=msp430x2101:crt430x2101.o%s} \
+%{mmcu=msp430x2111:crt430x2111.o%s} \
+%{mmcu=msp430x2121:crt430x2121.o%s} \
+%{mmcu=msp430x2131:crt430x2131.o%s} \
+%{mmcu=msp430x311:crt430x311.o%s} \
+%{mmcu=msp430x312:crt430x312.o%s} \
+%{mmcu=msp430x313:crt430x313.o%s} \
+%{mmcu=msp430x314:crt430x314.o%s} \
+%{mmcu=msp430x315:crt430x315.o%s} \
+%{mmcu=msp430x323:crt430x323.o%s} \
+%{mmcu=msp430x325:crt430x325.o%s} \
+%{mmcu=msp430x336|mmcu=msp2:crt430x336.o%s} \
+%{mmcu=msp430x337:crt430x337.o%s} \
+%{mmcu=msp430x412:crt430x412.o%s} \
+%{mmcu=msp430x413:crt430x413.o%s} \
+%{mmcu=msp430x415:crt430x415.o%s} \
+%{mmcu=msp430x417:crt430x417.o%s} \
+%{mmcu=msp430x423:crt430x423.o%s} \
+%{mmcu=msp430x425:crt430x425.o%s} \
+%{mmcu=msp430x427:crt430x427.o%s} \
+%{mmcu=msp430x4250:crt430x4250.o%s} \
+%{mmcu=msp430x4260:crt430x4260.o%s} \
+%{mmcu=msp430x4270:crt430x4270.o%s} \
+%{mmcu=msp430xE423:crt430xE423.o%s} \
+%{mmcu=msp430xE425:crt430xE425.o%s} \
+%{mmcu=msp430xE427:crt430xE427.o%s} \
+%{mmcu=msp430xW423:crt430xW423.o%s} \
+%{mmcu=msp430xW425:crt430xW425.o%s} \
+%{mmcu=msp430xW427:crt430xW427.o%s} \
+%{mmcu=msp430xG437:crt430xG437.o%s} \
+%{mmcu=msp430xG438:crt430xG438.o%s} \
+%{mmcu=msp430xG439:crt430xG439.o%s} \
+%{mmcu=msp430x435:crt430x435.o%s} \
+%{mmcu=msp430x436:crt430x436.o%s} \
+%{mmcu=msp430x437:crt430x437.o%s} \
+%{mmcu=msp430x447:crt430x447.o%s} \
+%{mmcu=msp430x448:crt430x448.o%s} \
+%{mmcu=msp430x449:crt430x449.o%s}"
+
+
+#define EXTRA_SPECS                           	\
+{"crt_binutils", CRT_BINUTILS_SPECS},
+
+#define MULTILIB_DEFAULTS { "mmcu=msp430x110" }
+#define LINKER_NAME "msp430-ld"
+
+#define TEST_HARD_REG_CLASS(CLASS, REGNO) \
+  TEST_HARD_REG_BIT (reg_class_contents[ (int) (CLASS)], REGNO)
+
+#define INIT_TARGET_OPTABS				\
+{							\
+  msp430_init_once ();					\
+}
+
+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT
+
+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+
+#define DBX_REGISTER_NUMBER(r) (r)
+
+#include "dbxelf.h"
+
+#endif
+
diff -Nru gcc-3.3-orig/gcc/config/msp430/msp430.md gcc-3.3/gcc/config/msp430/msp430.md
--- gcc-3.3-orig/gcc/config/msp430/msp430.md	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/msp430.md	2003-06-03 15:32:28.000000000 +0200
@@ -0,0 +1,3820 @@
+; -*- Mode: Scheme -*-
+;;   Machine description for GNU compiler,
+;;   for Texas Instruments msp430 MCUs
+;;   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+;;   Contributed by Dmitry Diky <diwil@mail.ru>
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GCC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+;; Special characters after '%':
+;;  A  No effect (add 0).
+;;  B  Add 1 to REG number, 2 to MEM address or CONST_INT.
+;;  C	   2		    4
+;;  D	   3		    6
+;;  E  adds nothing to reg but used only with (mem:hi (reg:hi))
+;;  F  no trim array
+;;  Extra constarains:
+;;  P  hardware constants: -1,0,+1,+2,+4,+8
+;;  Q  Indexed destination register as X(Rn)
+;;  R  Indexed source register as @Rn+
+;;  S  Symbol reference for 'C' like: a = *b;
+;;
+
+;; Unspec usage:
+;; 3 - strlen
+;; 0  - addc_reg
+;; 5  - addc_any
+;; 1  - bittest_lo
+;; 2  - bittest_hi
+;; 6  - bittest
+;; 4  - swpb
+;; 7  - bittest_b
+;; 8  - move SF to SI with no conversion
+
+
+;; Condition code settings.
+
+
+(define_attr "cc" "none,set_czn,compare,clobber,further,oper,cbranch"
+  (const_string "none"))
+
+(define_attr "type" "branch,branch1,arith"
+  (const_string "arith"))
+
+(define_attr "msp430_has_hwmul" "yes,no"
+  (const (if_then_else (symbol_ref "MSP430_HAS_HWMUL")
+		       (const_string "yes")
+		       (const_string "no"))))
+
+(define_attr "msp430_hwmul_no_int" "" (symbol_ref "MSP430_HWMUL_NO_INT"))
+
+;; The size of instructions in bytes.
+;; XXX may depend from "cc"
+
+;; for confitional branches
+(define_attr "length" ""
+  (cond [(eq_attr "type" "branch")
+         (if_then_else  (and (ge (minus (pc) (match_dup 0)) 
+	 				(const_int -508))
+                             (le (minus (pc) (match_dup 0)) 
+			     		(const_int  508)))
+                        (const_int 1)
+			(const_int 2))]
+	(const_int 2)
+))
+
+
+;;========================================================================
+;;  PUSH/POP helper functions
+;;
+
+
+(define_insn "*pushqi_pre_mod"
+[(set (mem:QI (pre_modify:HI (reg:HI 1)
+                (plus:HI (reg:HI 1) (const_int -2))))
+	(match_operand:QI 0 "general_operand" "rim"))]
+""
+"* return msp430_pushqi(insn, operands, NULL);"
+[(set_attr "length" "2")])
+
+(define_insn "*pushqi"
+  [(set (mem:QI (post_dec (reg:HI 1)))
+        (match_operand:QI 0 "general_operand" "rim"))]
+  ""
+  "* return msp430_pushqi(insn, operands, NULL);"
+  [(set_attr "length" "2")])
+
+(define_insn "*pushhi"
+  [(set (mem:HI (post_dec (reg:HI 1))) 
+        (match_operand:HI 0 "general_operand" "rim"))]
+  ""
+  "* return msp430_pushhi(insn, operands, NULL);"
+  [(set_attr "length" "2")])
+
+(define_insn "*pushsi"
+  [(set (mem:SI (post_dec (reg:HI 1))) 
+        (match_operand:SI 0 "general_operand" "rmi"))]
+  ""
+  "* return msp430_pushsisf(insn, operands, NULL);"
+  [(set_attr "length" "4")])
+
+
+(define_insn "*pushdi"
+  [(set (mem:DI (post_dec (reg:HI 1)))
+        (match_operand:DI 0 "general_operand" "rmi"))]
+  ""
+  "* return msp430_pushdi(insn, operands, NULL);"
+  [(set_attr "length" "8")])
+
+
+(define_insn "*pushsf"
+  [(set (mem:SF (post_dec (reg:HI 1)))
+        (match_operand:SF 0 "general_operand" "rmi"))]
+  ""
+  "* return msp430_pushsisf(insn, operands, NULL);"
+  [(set_attr "length" "4")])
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "general_operand" ""))
+   (set (mem:HI (post_dec (reg:HI 1)))
+	(match_dup 0))]
+"dead_or_set_in_peep(1, insn, operands[0])"
+  [(set (mem:HI (post_dec (reg:HI 1)))
+	(match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "general_operand" ""))
+   (set (mem:SI (post_dec (reg:HI 1)))
+	(match_dup 0))]
+"dead_or_set_in_peep(1, insn, operands[0])"
+  [(set (mem:SI (post_dec (reg:HI 1)))
+	(match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SF 0 "register_operand" "") 
+	(match_operand:SF 1 "general_operand" ""))
+   (set (mem:SF (post_dec (reg:HI 1)))
+	(match_dup 0))]
+"dead_or_set_in_peep(1, insn, operands[0])"
+  [(set (mem:SF (post_dec (reg:HI 1)))
+	(match_dup 1))]
+"")
+
+;;========================================================================
+;; compare
+
+(define_expand "cmpqi"
+  [(set (cc0)
+        (compare:QI (match_operand:QI 0 "nonimmediate_operand_msp430" "rm")   
+                    (match_operand:QI 1 "general_operand_msp430" "rmi")))]
+ ""
+"
+  msp430_compare_op0 = operands[0];
+  msp430_compare_op1 = operands[1];
+  DONE;
+")
+
+(define_expand "cmphi"
+  [(set (cc0)
+        (compare:HI (match_operand:HI 0 "nonimmediate_operand_msp430" "rm")   
+                    (match_operand:HI 1 "general_operand_msp430" "rmi")))]
+ ""
+"
+  msp430_compare_op0 = operands[0];
+  msp430_compare_op1 = operands[1];
+  DONE;
+")
+
+(define_expand "cmpsi"
+   [(set (cc0)
+         (compare:SI (match_operand:SI 0 "nonimmediate_operand" "rm")
+                     (match_operand:SI 1 "general_operand" "rmi")))]
+   ""
+"
+  msp430_compare_op0 = operands[0];
+  msp430_compare_op1 = operands[1];
+  DONE;
+")
+
+(define_expand "beq"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (EQ, operands[0]); DONE; }")
+
+(define_expand "bne"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (NE, operands[0]); DONE; }")
+
+(define_expand "bge"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (GE, operands[0]); DONE; }")
+
+(define_expand "bgt"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (GT, operands[0]); DONE; }")
+
+(define_expand "ble"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (LE, operands[0]); DONE; }")
+
+(define_expand "blt"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (LT, operands[0]); DONE; }")
+
+(define_expand "bgeu"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (GEU, operands[0]); DONE; }")
+
+(define_expand "bgtu"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (GTU, operands[0]); DONE; }")
+
+(define_expand "bleu"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (LEU, operands[0]); DONE; }")
+
+(define_expand "bltu"
+   [(use (match_operand 0 "" ""))]
+""
+"{ msp430_emit_cbranch (LTU, operands[0]); DONE; }")
+
+(define_insn "*cbranchqi"
+  [(set (pc)
+     (if_then_else (match_operator:QI 1 "comparison_operator"
+		    [(match_operand:QI 2 "nonimmediate_operand_msp430" "rm")
+		     (match_operand:QI 3 "general_operand" "rmi")])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+""
+"* return msp430_cbranch(insn, operands, NULL);"
+ [(set_attr "length" "9") 
+ (set_attr "cc" "cbranch")])
+
+(define_insn "*cbranchhi"
+  [(set (pc)
+     (if_then_else (match_operator:HI 1 "comparison_operator"
+		    [(match_operand:HI 2 "nonimmediate_operand_msp430" "rm")
+		     (match_operand:HI 3 "general_operand" "rmi")])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+""
+"* return msp430_cbranch(insn, operands, NULL);"
+ [(set_attr "length" "9")
+ (set_attr "cc" "cbranch")])
+
+(define_insn "*cbranchsi_eqne"
+  [(set (pc)
+     (if_then_else (match_operator:SI 1 "equality_operator"
+		    [(match_operand:SI 2 "nonimmediate_operand_msp430" "rm")
+		     (match_operand:SI 3 "general_operand" "rmi")])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+""
+"* return msp430_cbranch(insn, operands, NULL);"
+[(set_attr "length" "9")
+ (set_attr "cc" "cbranch")])
+
+(define_insn "*cbranchsi_others"
+  [(parallel [(set (pc)
+     (if_then_else (match_operator:SI 1 "inequality_operator"
+		    [(match_operand:SI 2 "register_operand" "r")
+		     (match_operand:SI 3 "general_operand" "rmi")])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))
+  (clobber (match_dup 2))])]
+""
+"* return msp430_cbranch(insn, operands, NULL);"
+[(set_attr "length" "9")
+ (set_attr "cc" "cbranch")])
+
+
+(define_insn "*cbranch_uncoded"
+  [(set (pc)
+     (if_then_else (match_operator 1 "comparison_operator"
+		    [(cc0)
+		     (const_int 0)])
+      (label_ref (match_operand 0 "" ""))
+      (pc)))]
+""
+"* return msp430_cbranch(insn, operands, NULL);"
+[(set_attr "length" "9")
+(set_attr "cc" "cbranch")])
+
+;;========================================================================
+;; noop
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "cc" "none")
+   (set_attr "length" "1")])
+
+
+;;============================================================================
+;; call
+;;
+
+(define_expand "call"
+  [(call (match_operand:HI 0 "general_operand" "")
+         (match_operand:HI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "*call_insn"
+  [(call (mem:HI (match_operand:HI 0 "general_operand" "r,R,mi"))
+         (match_operand:HI 1 "general_operand" "X,X,X"))]
+""
+"call\\t%0"
+[ (set_attr "length" "1,1,2")
+   (set_attr "cc" "clobber")])
+
+
+(define_expand "call_value"
+  [(set (match_operand 0 "register_operand" "")
+        (call (match_operand:HI 1 "general_operand" "")
+              (match_operand:HI 2 "general_operand" "")))]
+  ""
+  "")
+
+(define_insn "*call_value_insn"
+  [( set (match_operand 0 "register_operand" "=r,r,r")
+   (call (mem:HI (match_operand:HI 1 "general_operand" "rP,R,mi"))
+	 (match_operand:HI 2 "general_operand" "X,X,X")))]
+""
+ "call\\t%1"
+[ (set_attr "length" "1,1,2")
+   (set_attr "cc" "clobber")])
+
+;;========================================================================
+;; mult helpers
+
+(define_insn "reent_in"
+  [(set (mem:HI (post_dec (reg:HI 1))) 
+        (unspec_volatile:HI [(const_int 99999999)] 10))]
+  ""
+  "push\\tr2
+\\tdint
+\\tnop"
+  [(set_attr "length" "4")
+   (set_attr "cc" "clobber")])
+
+;;
+;; Next three help to make sure, that
+;; all instructions are 'in order'
+
+(define_insn "fetch_result_qi"
+ [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,m") 
+       (unspec_volatile:QI [(const_int 0)] 12))
+  (set (mem:HI (post_inc (reg:HI 1)))
+	(unspec_volatile:HI [(const_int 99999999)] 11))]
+ ""
+ "mov.b\\t&__RESLO, %0
+\\tpop\\tr2"
+ [(set_attr "length" "3,4")
+  (set_attr "cc" "none")])
+ 
+(define_insn "fetch_result_hi"
+ [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=r,m") 
+       (unspec_volatile:HI [(const_int 0)] 13))
+  (set (mem:HI (post_inc (reg:HI 1)))
+	(unspec_volatile:HI [(const_int 99999999)] 11))]
+ ""
+ "mov\\t&__RESLO, %0
+\\tpop\\tr2"
+ [(set_attr "length" "3,4")
+  (set_attr "cc" "none")])
+
+(define_insn "fetch_result_si"
+ [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "=r,m") 
+       (unspec_volatile:SI [(const_int 0)] 14))
+  (set (mem:HI (post_inc (reg:HI 1)))
+	(unspec_volatile:HI [(const_int 99999999)] 11))]
+ ""
+ "mov\\t&__RESLO, %A0
+\\tmov\\t&__RESHI, %B0
+\\tpop\\tr2"
+ [(set_attr "length" "5,7")
+  (set_attr "cc" "none")])
+
+(define_insn "addc_zero"
+ [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=r,m")
+   (unspec_volatile:HI [(const_int 0 )] 15))]
+ ""
+ "addc\\t#0, %0"
+[(set_attr "length" "1,2")
+ (set_attr "cc" "clobber")])
+
+(define_insn "subc_zero"
+ [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=r,m")
+   (unspec:HI [(const_int 0 )] 16))]
+ ""
+ "subc\\t#0, %0"
+[(set_attr "length" "1,2")
+ (set_attr "cc" "clobber")])
+
+(define_insn "load_mpy"
+ [(unspec_volatile:HI [(const_int 0)] 17)
+  (use (match_operand:HI 0 "general_operand_msp430" "rRP,mi"))]
+""
+"mov\\t%0, &__MPY"
+[(set_attr "length" "2,3")
+ (set_attr "cc" "none")])
+
+
+(define_insn "load_mpys"
+  [(unspec_volatile:HI [(const_int 0 )] 18)
+   (use (match_operand:HI 0 "general_operand_msp430" "rRP,mi"))]
+""
+"mov\\t%0, &__MPYS"
+[(set_attr "length" "2,3")
+ (set_attr "cc" "none")])
+ 
+ 
+(define_insn "load_op2"
+  [(unspec_volatile:HI [(const_int 0 )] 19)
+   (use (match_operand:HI 0 "general_operand_msp430" "rRP,mi"))]
+""
+"mov\\t%0, &__OP2"
+[(set_attr "length" "2,3")
+ (set_attr "cc" "none")])
+ 
+
+(define_insn "load_mpyq"
+  [(unspec_volatile:QI [(const_int 0 )] 20)
+   (use (match_operand:QI 0 "general_operand_msp430" "rRP,mi"))]
+""
+"mov.b\\t%0, &__MPY"
+[(set_attr "length" "2,3")
+ (set_attr "cc" "none")])
+
+
+(define_insn "load_mpysq"
+  [(unspec_volatile:QI [(const_int 0 )] 21)
+   (use (match_operand:QI 0 "general_operand_msp430" "rRP,mi"))]
+""
+"mov.b\\t%0, &__MPYS"
+[(set_attr "length" "2,3")
+ (set_attr "cc" "none")])
+ 
+(define_insn "load_op2q"
+  [(unspec_volatile:QI [(const_int 0 )] 22)
+  (use (match_operand:QI 0 "general_operand_msp430" "rRP,mi"))]
+""
+"mov.b\\t%0, &__OP2"
+[(set_attr "length" "2,3")
+ (set_attr "cc" "none")])
+
+
+;;========================================================================
+;;  Multiplication 
+;;========================================================================
+;; 8 = 8x8 and 16 = 8x8
+
+(define_expand "mulqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (mult:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")
+                 (match_operand:QI 2 "general_operand_msp430" "")))]  
+  ""             
+"{ msp430_mul3_guard(operands,0); DONE; }")
+
+(define_insn "*mulqi3_call"
+  [(set (reg:QI 14) (mult:QI (reg:QI 10) (reg:QI 12)))
+	(clobber (reg:QI 10))
+	(clobber (reg:QI 12))]
+  "!MSP430_HAS_HWMUL"
+  "call	#__mulqi3"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;; ============= qi -> hi =======================================================
+(define_expand "mulqihi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (mult:HI (sign_extend:HI (match_operand:QI 1 "nonimmediate_operand_msp430" ""))
+                 (sign_extend:HI (match_operand:QI 2 "general_operand_msp430" ""))))]
+""
+"{ msp430_mul3_guard(operands,1); DONE; }")
+
+(define_insn "*mulqihi3_call"
+  [(set (reg:HI 14) (mult:HI (sign_extend:HI (reg:QI 10))
+			     (sign_extend:HI (reg:QI 12))))
+        (clobber (reg:QI 10))
+        (clobber (reg:QI 12))]
+  "!MSP430_HAS_HWMUL"
+  "call	#__mulqihi3"   
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;; ============ unsigned ones ===================================================
+(define_expand "umulqihi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (mult:HI (zero_extend:HI (match_operand:QI 1 "nonimmediate_operand_msp430" ""))
+                 (zero_extend:HI (match_operand:QI 2 "general_operand_msp430" ""))))]
+  ""
+  "{ msp430_umul3_guard(operands,0); DONE; }")  
+
+(define_insn "*umulqihi3_call"
+  [(set (reg:HI 14) (mult:HI (zero_extend:HI (reg:QI 10))
+                	     (zero_extend:HI (reg:QI 12))))
+        (clobber (reg:QI 10))
+        (clobber (reg:QI 12))]
+  "!MSP430_HAS_HWMUL"
+  "call	#__umulqihi3" 
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;;========================================================================
+;; 16 = 16x16 and 32 = 16x16
+
+(define_expand "mulhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (mult:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "")
+                 (match_operand:HI 2 "general_operand_msp430" "")))]  
+  ""
+"{msp430_mul3_guard(operands,0); DONE; } ")
+
+(define_insn "*mulhi3_call"
+  [(set (reg:HI 14) (mult:HI (reg:HI 10) (reg:HI 12)))
+	(clobber (reg:HI 10))
+	(clobber (reg:HI 12))]
+  "!MSP430_HAS_HWMUL"
+  "call	#__mulhi3"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;; ========================== hi -> si =============================
+(define_expand "mulhisi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "")
+        (mult:SI (sign_extend:SI (match_operand:HI 1 "nonimmediate_operand_msp430" ""))
+                 (sign_extend:SI (match_operand:HI 2 "general_operand_msp430" ""))))]
+""
+  "{msp430_mulhisi_guard(operands); DONE;}"
+)
+
+(define_insn "*mulhisi3_call"
+  [(set (reg:SI 14) (mult:SI (sign_extend:SI (reg:HI 10))
+			     (sign_extend:SI (reg:HI 12))))
+        (clobber (reg:HI 10))
+        (clobber (reg:HI 11))
+	(clobber (reg:HI 12))  
+	(clobber (reg:HI 13))]
+  "!MSP430_HAS_HWMUL"
+  "mov	#0,	r11
+	tst	r10
+	jge	+2
+	mov	#-1, r11
+	mov	#0, r13
+	tst	r12
+	jge	+2
+	mov	#-1, r13
+	call	#__mulhisi3"
+  [(set_attr "length" "10")
+   (set_attr "cc" "clobber")])
+
+;; ================== unsigned  hi -> si =============================
+(define_expand "umulhisi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "")
+        (mult:SI (zero_extend:SI (match_operand:HI 1 "nonimmediate_operand_msp430" ""))
+                 (zero_extend:SI (match_operand:HI 2 "general_operand_msp430" ""))))]
+  ""
+  "{msp430_umulhisi_guard(operands); DONE;}")
+
+(define_insn "*umulhisi3_call"
+  [(set (reg:SI 14) (mult:SI (zero_extend:SI (reg:HI 10))
+                	     (zero_extend:SI (reg:HI 12))))
+        (clobber (reg:HI 10))
+        (clobber (reg:HI 11))
+	(clobber (reg:HI 12))  
+	(clobber (reg:HI 13))]
+  "!MSP430_HAS_HWMUL"
+  "clr	r11
+	clr	r13
+	call	#__umulhisi3" 
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+;;========================================================================
+;; 32 = 32x32.      64 = 32x32 <- via library calls only
+
+(define_expand "mulsi3"
+  [(set (reg:SI 10) (match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+   (set (reg:SI 12) (match_operand:SI 2 "general_operand_msp430" ""))
+   (set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))
+   (set (match_operand:SI 0 "nonimmediate_operand_msp430" "") (reg:SI 14))]
+""
+"{ 
+  if(msp430_easy_mul(operands,0))	
+    DONE;
+
+  if (!MSP430_HAS_HWMUL)
+    {
+      /* all ops have to be registers */
+      emit_insn (gen_mulsi3_call (operands[0], operands[1], operands[2]));
+      DONE;
+    }
+}")
+
+(define_insn "*mulsi3hw_call_ni"
+  [(set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))]
+  "(!TARGET_INLINESIHWMUL) && MSP430_HWMUL_NO_INT"
+  "call	#__umulsi3hw"
+[(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*mulsi3hw_call_ie"
+  [(set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))]
+  "(!TARGET_INLINESIHWMUL) && !MSP430_HWMUL_NO_INT"
+  "push	r2
+	dint
+	call	#__umulsi3hw
+	pop	r2"
+[(set_attr "length" "5")
+   (set_attr "cc" "none")])
+
+(define_insn "*mulsi3hw_inline_ni"
+  [(set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))]
+  "TARGET_INLINESIHWMUL && MSP430_HAS_HWMUL && MSP430_HWMUL_NO_INT"
+  "mov	r12, &__MPY
+	mov	r10, &__OP2
+	mov	r12, &__MAC
+	mov	&__RESLO, r14
+	mov	&__RESHI, &__RESLO
+	mov	r11, &__OP2
+	mov	r13, &__MAC
+	mov	r10, &__OP2
+	mov	&__RESLO, r15"
+[(set_attr "length" "19")  
+   (set_attr "cc" "none")])
+
+(define_insn "*mulsi3hw_inline_ie"
+  [(set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))]
+  "TARGET_INLINESIHWMUL && MSP430_HAS_HWMUL && !MSP430_HWMUL_NO_INT"
+  "push	r2
+	dint
+	nop
+	mov	r12, &__MPY
+	mov	r10, &__OP2
+	mov	r12, &__MAC
+	mov	&__RESLO, r14
+	mov	&__RESHI, &__RESLO
+	mov	r11, &__OP2
+	mov	r13, &__MAC
+	mov	r10, &__OP2
+	mov	&__RESLO, r15
+	pop	r2"
+[(set_attr "length" "23")  
+   (set_attr "cc" "none")])
+
+(define_expand "mulsi3_call"
+  [(set (reg:SI 10) (match_operand:SI 1 "register_operand" ""))
+   (set (reg:SI 12) (match_operand:SI 2 "register_operand" "")) 
+   (parallel [(set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))
+        (clobber (reg:SI 10))
+        (clobber (reg:SI 12))])
+   (set (match_operand:SI 0 "register_operand" "") (reg:SI 14))]
+"!MSP430_HAS_HWMUL"
+"")
+
+(define_insn "*mulsi3_call"
+  [(set (reg:SI 14) (mult:SI (reg:SI 10) (reg:SI 12)))
+	(clobber (reg:SI 10))
+	(clobber (reg:SI 12))]
+  "!MSP430_HAS_HWMUL"
+  "call	#__mulsi3"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+;; / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % / % /
+
+(define_expand "divmodqi4"
+  [(set (reg:QI 12) (match_operand:QI 1 "register_operand" ""))
+   (set (reg:QI 10) (match_operand:QI 2 "register_operand" ""))
+   (parallel [(set (reg:QI 12) (div:QI (reg:QI 12) (reg:QI 10)))
+              (set (reg:QI 14) (mod:QI (reg:QI 12) (reg:QI 10)))
+              (clobber (reg:QI 10))
+              (clobber (reg:QI 11))
+	      (clobber (reg:QI 13))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 12))
+   (set (match_operand:QI 3 "register_operand" "") (reg:QI 14))]
+  ""
+  "")
+
+(define_insn "*divmodqi4_call"
+  [(set (reg:QI 12) (div:QI (reg:QI 12) (reg:QI 10)))
+   (set (reg:QI 14) (mod:QI (reg:QI 12) (reg:QI 10)))
+   (clobber (reg:QI 10))
+   (clobber (reg:QI 11))
+   (clobber (reg:QI 13))]
+  ""
+  "call	#__divmodqi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "udivmodqi4"
+  [(set (reg:QI 12) (match_operand:QI 1 "register_operand" ""))
+   (set (reg:QI 10) (match_operand:QI 2 "register_operand" ""))
+   (parallel [(set (reg:QI 12) (udiv:QI (reg:QI 12) (reg:QI 10)))
+              (set (reg:QI 14) (umod:QI (reg:QI 12) (reg:QI 10)))
+              (clobber (reg:QI 10))
+              (clobber (reg:QI 11)) 
+              (clobber (reg:QI 13))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 12))
+   (set (match_operand:QI 3 "register_operand" "") (reg:QI 14))]
+  ""
+  "")
+
+(define_insn "*udivmodqi4_call"
+  [(set (reg:QI 12) (udiv:QI (reg:QI 12) (reg:QI 10)))
+   (set (reg:QI 14) (umod:QI (reg:QI 12) (reg:QI 10)))
+   (clobber (reg:QI 10))
+   (clobber (reg:QI 11)) 
+   (clobber (reg:QI 13))]
+  ""
+  "call	#__udivmodqi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+(define_expand "divmodhi4"
+  [(set (reg:HI 12) (match_operand:HI 1 "register_operand" ""))
+   (set (reg:HI 10) (match_operand:HI 2 "register_operand" ""))
+   (parallel [(set (reg:HI 12) (div:HI (reg:HI 12) (reg:HI 10)))
+              (set (reg:HI 14) (mod:HI (reg:HI 12) (reg:HI 10)))
+              (clobber (reg:HI 10))
+              (clobber (reg:HI 11))
+	      (clobber (reg:HI 13))])
+   (set (match_operand:HI 0 "register_operand" "") (reg:HI 12))
+   (set (match_operand:HI 3 "register_operand" "") (reg:HI 14))]
+  ""
+  "")
+
+(define_insn "*divmodhi4_call"
+  [(set (reg:HI 12) (div:HI (reg:HI 12) (reg:HI 10)))
+   (set (reg:HI 14) (mod:HI (reg:HI 12) (reg:HI 10)))
+   (clobber (reg:HI 10))
+   (clobber (reg:HI 11))
+   (clobber (reg:HI 13))]
+  ""
+  "call	#__divmodhi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "udivmodhi4"
+  [(set (reg:HI 12) (match_operand:HI 1 "register_operand" ""))
+   (set (reg:HI 10) (match_operand:HI 2 "register_operand" ""))
+   (parallel [(set (reg:HI 12) (udiv:HI (reg:HI 12) (reg:HI 10)))
+              (set (reg:HI 14) (umod:HI (reg:HI 12) (reg:HI 10)))
+              (clobber (reg:HI 10))
+              (clobber (reg:HI 11)) 
+              (clobber (reg:HI 13))])
+   (set (match_operand:HI 0 "register_operand" "") (reg:HI 12))
+   (set (match_operand:HI 3 "register_operand" "") (reg:HI 14))]
+  ""
+  "")
+
+(define_insn "*udivmodhi4_call"
+  [(set (reg:HI 12) (udiv:HI (reg:HI 12) (reg:HI 10)))
+   (set (reg:HI 14) (umod:HI (reg:HI 12) (reg:HI 10)))
+   (clobber (reg:HI 10))
+   (clobber (reg:HI 11)) 
+   (clobber (reg:HI 13))]
+  ""
+  "call	#__udivmodhi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+;; ///////////////// SINGLE INTEGER %%%%%%%%%%%%%%%%%
+
+(define_expand "divmodsi4"
+  [(set (reg:SI 12) (match_operand:SI 1 "register_operand" ""))
+   (set (reg:SI 10) (match_operand:SI 2 "register_operand" ""))
+   (parallel [(set (reg:SI 12) (div:SI (reg:SI 12) (reg:SI 10)))
+              (set (reg:SI 14) (mod:SI (reg:SI 12) (reg:SI 10)))
+              (clobber (reg:SI 10))
+              (clobber (reg:HI 9))
+	      (clobber (reg:HI 8))])
+   (set (match_operand:SI 0 "register_operand" "") (reg:SI 12))
+   (set (match_operand:SI 3 "register_operand" "") (reg:SI 14))]
+  ""
+  "")
+
+(define_insn "*divmodsi4_call"
+  [(set (reg:SI 12) (div:SI (reg:SI 12) (reg:SI 10)))
+   (set (reg:SI 14) (mod:SI (reg:SI 12) (reg:SI 10)))
+   (clobber (reg:SI 10))
+   (clobber (reg:HI 9))
+   (clobber (reg:HI 8))]
+  ""
+  "call	#__divmodsi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "udivmodsi4"
+  [(set (reg:SI 12) (match_operand:SI 1 "register_operand" ""))
+   (set (reg:SI 10) (match_operand:SI 2 "register_operand" ""))
+   (parallel [(set (reg:SI 12) (udiv:SI (reg:SI 12) (reg:SI 10)))
+              (set (reg:SI 14) (umod:SI (reg:SI 12) (reg:SI 10)))
+              (clobber (reg:SI 10))
+              (clobber (reg:HI 9)) 
+              (clobber (reg:HI 8))])
+   (set (match_operand:SI 0 "register_operand" "") (reg:SI 12))
+   (set (match_operand:SI 3 "register_operand" "") (reg:SI 14))]
+  ""
+  "")
+
+(define_insn "*udivmodsi4_call"
+  [(set (reg:SI 12) (udiv:SI (reg:SI 12) (reg:SI 10)))
+   (set (reg:SI 14) (umod:SI (reg:SI 12) (reg:SI 10)))
+   (clobber (reg:SI 10))
+   (clobber (reg:HI 9)) 
+   (clobber (reg:HI 8))]
+  ""
+  "call	#__udivmodsi4"
+   [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;;========================================================================
+;; MOV STRING
+;;   structures and stuff are word aligned.
+;;   so, QI mode only defined (as HI actually)
+;;
+
+(define_expand "movstrhi"
+  [(parallel [(set (match_operand:BLK 0 "memory_operand" "")
+                   (match_operand:BLK 1 "memory_operand" ""))
+              (use (match_operand 2 "const_int_operand" ""))
+              (use (match_operand 3 "const_int_operand" ""))
+              (clobber (match_dup 4))
+              (clobber (match_dup 5))
+              (clobber (match_dup 6))])]
+  ""
+  " 
+{   
+  rtx addr0, addr1;
+  rtx a0, a1;
+  
+  if (GET_CODE (operands[2]) != CONST_INT) FAIL;
+
+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));
+  addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));
+  
+  a0 = operands[0];
+  a1 = operands[1];
+  
+  operands[5] = addr0;
+  operands[6] = addr1;
+
+  operands[0] = gen_rtx (MEM, BLKmode, addr0);
+  operands[1] = gen_rtx (MEM, BLKmode, addr1);
+
+  if(INTVAL (operands[2]) <= 10 && !(INTVAL(operands[3])&1))
+  {
+    int x = INTVAL (operands[2]);
+    int y = (x&~1) >> 1;
+    int i = 0;
+     
+    while(y--)
+    {
+      rtx dest = gen_rtx (MEM, HImode, gen_rtx_PLUS(HImode, addr0,GEN_INT(i)));
+      emit_insn(gen_movstrhi5(dest,addr1));
+      i+= 2;
+    }
+
+    if(x & 1)
+    {
+      rtx real_dst = gen_rtx (MEM, HImode, gen_rtx_PLUS(HImode, addr0,GEN_INT(x-1)));
+      emit_insn(gen_movstrqi5(real_dst,addr1));
+    }
+    DONE;
+  }
+  else if(INTVAL (operands[2]) <= 6 && (INTVAL(operands[3])&1))
+  {
+    int x = INTVAL (operands[2]);
+    int i = 0;
+    
+    while(x--)
+    {
+      rtx dst = gen_rtx (MEM, HImode, gen_rtx_PLUS(HImode, addr0,GEN_INT(i)));
+      emit_insn(gen_movstrqi5(dst,addr1));
+      i++;
+    }
+    DONE;
+  }
+  else
+  {
+  	operands[2] = copy_to_mode_reg (HImode, operands[2]);
+  	operands[4] = operands[2];
+  }
+}
+")
+
+(define_insn "movstrqi5"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=m")
+	(mem:HI (match_operand:HI 1 "register_operand" "+r")))
+	(set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
+  ""
+  "mov.b	@%1+, %0"
+[(set_attr "length" "2")
+ (set_attr "cc" "clobber")])
+
+(define_insn "movstrhi5"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=m")
+	(mem:HI (match_operand:HI 1 "register_operand" "+r")))
+	(set (match_dup 1) (plus:HI (match_dup 1) (const_int 2)))]
+ ""
+ "mov	@%1+, %0"
+ [(set_attr "length" "2")
+ (set_attr "cc" "clobber")])
+
+
+(define_insn "*movstrhi_insn"
+  [(set (mem:BLK (match_operand:HI 0 "register_operand" "r"))
+        (mem:BLK (match_operand:HI 1 "register_operand" "r")))
+   (use (match_operand:HI 2 "register_operand" "r"))
+   (use (match_operand 3 "const_int_operand" "i"))
+   (clobber (match_dup 2))
+   (clobber (match_dup 0))
+   (clobber (match_dup 1))]
+  ""
+  "* return movstrhi_insn(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*movstrqi_insn"
+  [(set (mem:BLK (match_operand:HI 0 "register_operand" "r"))
+        (mem:BLK (match_operand:HI 1 "register_operand" "r")))
+   (use (match_operand:QI 2 "register_operand" "r"))
+   (use (match_operand 3 "const_int_operand" "i"))
+   (clobber (match_dup 2))
+   (clobber (match_dup 0))
+   (clobber (match_dup 1))]
+  ""
+  "* return movstrhi_insn(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+
+
+;;========================================================================
+;; CLEAR STRING
+
+(define_expand "clrstrhi"
+  [(parallel [(set (match_operand:BLK 0 "memory_operand" "")
+                   (const_int 0))
+              (use (match_operand 1 "const_int_operand" ""))
+              (use (match_operand 2 "const_int_operand" "i"))
+              (clobber (match_dup 3))
+              (clobber (match_dup 4))])]
+  ""
+  " 
+{
+  rtx addr0;
+
+  if (GET_CODE (operands[1]) != CONST_INT) FAIL;
+  operands[1] = copy_to_mode_reg (HImode, operands[1]);
+  operands[3] = operands[1];
+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));
+  operands[4] = addr0;
+  operands[0] = gen_rtx (MEM, BLKmode, addr0);
+}")
+
+
+(define_insn "*clrstrhi_insn"
+  [(set (mem:BLK (match_operand:HI 0 "register_operand" "r"))
+        (const_int 0))
+   (use (match_operand:HI 1 "register_operand" "r")) 
+   (use (match_operand 2 "const_int_operand" "i"))
+   (clobber (match_dup 1)) 
+   (clobber (match_dup 0))]
+  ""
+  "* return clrstrhi_insn(insn, operands, NULL);"
+[(set_attr "length" "6")
+   (set_attr "cc" "clobber")])
+
+
+;;========================================================================
+;; %0 = strchr(%1,%2) - %1
+
+(define_expand "strlenhi"
+  [(set (match_dup 4)
+            (unspec:HI [(match_operand:BLK 1 "memory_operand" "")
+                        (match_operand 2 "const_int_operand" "")
+                        (match_operand:HI 3 "immediate_operand" "")] 3))
+     (set (match_operand:HI 0 "register_operand" "")
+          (minus:HI (match_dup 4)
+                    (match_dup 5)))]
+   ""
+   "
+{
+  rtx addr;
+
+  if (! (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0))
+	FAIL;
+  addr = copy_to_mode_reg (Pmode, XEXP (operands[1],0));
+  operands[1] = gen_rtx (MEM, BLKmode, addr); 
+  operands[5] = addr;
+  operands[4] = gen_reg_rtx (HImode);
+
+}")
+
+
+(define_insn "*strlenhi"
+ [(set (match_operand:HI 0 "register_operand" "=r")
+        (unspec:HI [(mem:BLK (match_operand:HI 1 "register_operand" "0"))
+                    (const_int 0)
+		    (match_operand:HI 2 "immediate_operand" "i") ] 3))]
+  ""
+"dec	%0
+.L__strlenhi__%=:
+	inc	%0
+	tst.b	0(%0)
+        jne	.L__strlenhi__%="
+[(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+
+;;========================================================================
+;; MOV code
+;;========================================================================
+;; move byte
+;; all addressing modes allowed
+;; fits perfectly into a single instruction 
+
+(define_expand "movqi" 
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (match_operand:QI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "*movqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"	"=m,m,m,m,r,r,r,r")
+	(match_operand:QI 1 "general_operand_msp430"	" m,r,P,i,m,r,P,i"))]
+  ""
+  "mov.b\\t%1, %0"
+  [(set_attr "length" "3,2,3,3,2,1,2,2")
+   (set_attr "cc" "none")])
+
+
+(define_insn "movqipi"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,m")
+	(mem:QI (post_inc:QI (match_operand:HI 1 "register_operand" "r,r"))))]
+  ""
+  "mov.b	@%1+, %0"
+[(set_attr "length" "1,2")
+   (set_attr "cc" "none")])
+
+(define_insn "movqipi2i"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,m")
+	(mem:QI (match_operand:HI 1 "register_operand" "+r,r")))
+   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
+""
+"mov.b	@%1+, %0"
+[(set_attr "length" "1,2")
+   (set_attr "cc" "none")])
+
+
+;;============================================================================
+;; move word (16 bit)
+;; the same as above
+
+(define_expand "movhi" 
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (match_operand:HI 1 "general_operand_msp430" ""))]
+  ""
+  "")
+
+(define_insn "*movhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"	"=m,m,m,m,r,r,r,r")
+	(match_operand:HI 1 "general_operand_msp430"		" r,m,P,i,r,m,P,i"))]
+  ""
+  "mov\\t%1, %0 "
+  [(set_attr "length" "2,3,3,3,1,2,2,2")
+   (set_attr "cc" "none")])
+
+(define_insn "movhipi"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=r,m")
+	(mem:HI (post_inc:HI (match_operand:HI 1 "register_operand" "r,r"))))]
+  ""
+  "mov	@%1+, %0"
+[(set_attr "length" "1,2")
+   (set_attr "cc" "none")])
+
+;;============================================================================
+;; move long (32 bit)
+;; the same as above
+
+(define_expand "movsi" 
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (match_operand:SI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "*movsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"	"=rm")
+	(match_operand:SI 1 "general_operand"		" rmi"))]
+""
+"* return msp430_movesi_code(insn,operands,NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "none")])
+
+(define_insn "movsipi"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "=r,m")
+	(mem:SI (post_inc (match_operand:HI 1 "register_operand" "r,r"))))]
+  ""
+  "mov	@%1+, %A0
+	mov	@%1+, %B0"
+[(set_attr "length" "2,4")
+   (set_attr "cc" "none")])
+
+
+
+;;============================================================================
+;; floats are the SI
+
+(define_expand "movsf" 
+  [(set (match_operand:SF 0 "nonimmediate_operand" "")
+        (match_operand:SF 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "*movsf3"
+  [(set (match_operand:SF 0 "nonimmediate_operand"	"=rm")
+	(match_operand:SF 1 "general_operand"		"rmi"))]
+""
+"* return msp430_movesi_code(insn,operands,NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "none")])
+
+
+(define_insn "movsfpi"
+  [(set (match_operand:SF 0 "nonimmediate_operand_msp430" "=r,m")
+	(mem:SF (post_inc (match_operand:HI 1 "register_operand" "r,r"))))]
+  ""
+  "mov	@%1+, %A0
+	mov	@%1+, %B0"
+[(set_attr "length" "2,4")
+   (set_attr "cc" "none")])
+
+;;============================================================================
+;; move long long (64 bit)
+;; the same as above
+(define_expand "movdi" 
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (match_operand:DI 1 "general_operand" ""))]
+  ""
+  "")
+
+(define_insn "*movdi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand" 	"=rm")
+	(match_operand:DI 1 "general_operand"		"rmi"))]
+""
+"* return msp430_movedi_code(insn,operands,NULL);"
+  [(set_attr "length" "12")
+   (set_attr "cc" "none")])
+
+
+(define_insn "movdipi"
+  [(set (match_operand:DI 0 "nonimmediate_operand_msp430" "=r,m")
+	(mem:DI (post_inc (match_operand:HI 1 "register_operand" "r,r"))))]
+  ""
+  "mov	@%1+, %A0
+	mov	@%1+, %B0
+	mov	@%1+, %C0
+	mov	@%1+, %D0"
+[(set_attr "length" "4,8")
+   (set_attr "cc" "none")])
+
+
+;;============================================================================
+;;  ARITHMETIC CODE
+;;
+
+
+;;  random operations:
+
+(define_insn "*opqi3_pi"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"          "=r,m")
+	(match_operator:QI 3 "three_operands_msp430"
+	 [(match_operand:QI 1 "nonimmediate_operand_msp430" "%0,0")
+	 (mem:QI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%3.b	@%2+, %0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+(define_insn "*ophi3_pi"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"          "=r,m")
+	(match_operator:HI 3 "three_operands_msp430"
+	 [(match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0")
+	  (mem:HI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%3	@%2+, %0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+(define_insn "*opsi3_pi"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"          "=r,m")
+	(match_operator:SI 3 "three_operands_msp430"
+	 [(match_operand:SI 1 "nonimmediate_operand_msp430" "%0,0")
+	  (mem:SI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%A3\\t@%2+, %A0
+\\t%B3\\t@%2+, %B0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+(define_insn "*opdi3_pi"
+  [(set (match_operand:DI 0 "nonimmediate_operand_msp430"          "=r,m")
+	(match_operator:DI 3 "three_operands_msp430"
+	 [(match_operand:DI 1 "nonimmediate_operand_msp430" "%0,0")
+	  (mem:DI (post_inc (match_operand:HI 2 "register_operand" "r,r")))]))]
+""
+"%A3\\t@%2+, %A0
+\\t%B3\\t@%2+, %B0
+\\t%C3\\t@%2+, %C0
+\\t%D3\\t@%2+, %D0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "oper,oper")])
+
+
+
+
+;;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+;; add 1 byte 
+
+(define_expand "addqi3" 
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (plus:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")   
+                 (match_operand:QI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+(define_insn "*addqi3_cg"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=m,r")
+        (plus:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "%0,0")
+		 (match_operand 2 "const_int_operand"      "i,i")))]
+"(INTVAL(operands[2]) == -2
+  || INTVAL(operands[2]) == -4
+  || INTVAL(operands[2]) == -8 )"
+"* {
+      operands[2] = gen_rtx_CONST_INT(QImode, -INTVAL(operands[2]));
+      return \"sub.b\\t%2, %0\";
+}"
+[(set_attr "length" "2,1")
+ (set_attr "cc" "set_czn")])
+
+
+(define_insn "*addqi3_3"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"          "=m,m,m,m,r,r,r,r")  
+        (plus:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "%0,0,0,0,0,0,0,0")  
+                 (match_operand:QI 2 "general_operand_msp430"      " m,r,P,i,m,r,P,i")))]  
+""
+  "add.b	%2, %0"
+  [(set_attr "length" "3,2,2,3,2,1,1,2")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; add 1 word (16 bits)
+;; same as above
+
+
+(define_expand "addhi3" 
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (plus:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "")
+                 (match_operand:HI 2 "general_operand_msp430" "")))]
+  ""
+  "")
+
+(define_insn "*addhi3_cg"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=m,r")
+	(plus:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0")
+		 (match_operand 2 "const_int_operand"      "i,i")))]
+"(INTVAL(operands[2]) == -2
+  || INTVAL(operands[2]) == -4
+  || INTVAL(operands[2]) == -8 )"
+"* {
+      operands[2] = gen_rtx_CONST_INT(HImode, -INTVAL(operands[2]));
+      return \"sub\\t%2, %0\" ;
+}"
+[(set_attr "length" "2,1")
+ (set_attr "cc" "set_czn")])
+
+(define_insn "*addhi3_3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"          "=m,m,m,m,r,r,r,r")
+        (plus:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0,0,0,0,0,0,0")
+                 (match_operand:HI 2 "general_operand_msp430"      " m,r,P,i,m,r,P,i")))]
+""
+  "add	%2, %0"
+  [(set_attr "length" "3,2,2,3,2,1,1,2")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; add 2 words (32 bits)
+;; same as above
+
+(define_expand "addsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "")
+        (plus:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "")
+                 (match_operand:SI 2 "general_operand_msp430" "")))]
+  ""
+  "")
+
+(define_insn "*addsi3_cg"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "=m,r")
+	(plus:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "%0,0")
+		 (match_operand 2 "const_int_operand"      "i,i")))]
+"(INTVAL(operands[2]) == -2
+  || INTVAL(operands[2]) == -4
+  || INTVAL(operands[2]) == -8 )"
+"* {
+     operands[2] = gen_rtx_CONST_INT(SImode, -INTVAL(operands[2]));
+     return \"sub\\t%A2, %A0\\n\\tsubc\\t%B2, %B0\" ;
+}"
+[(set_attr "length" "4,2")
+ (set_attr "cc" "further,further")])
+
+
+(define_insn "*addsi3_3"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"      "=rm")
+        (plus:SI (match_operand:SI 1 "general_operand_msp430"  "%0")
+                 (match_operand:SI 2 "general_operand_msp430"  " rmi")))]
+""
+"* return msp430_addsi_code(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "further")])
+
+
+;;============================================================================
+;; add 4 words (64 bits)
+;; same as above
+
+(define_expand "adddi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (plus:DI (match_operand:DI 1 "nonimmediate_operand" "")   
+                 (match_operand:DI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*adddi3_cg"
+   [(set (match_operand:DI 0 "nonimmediate_operand_msp430" "=m,r")
+		  (plus:DI (match_operand:DI 1 "nonimmediate_operand_msp430" "%0,0")
+	          (match_operand:DI 2 "const_int_operand"      "i,i")))]
+"(INTVAL(operands[2]) == -2
+  || INTVAL(operands[2]) == -4
+  || INTVAL(operands[2]) == -8 )"
+"* {
+     operands[2] = gen_rtx_CONST_INT(DImode, -INTVAL(operands[2]));
+     return \"sub\\t%A2, %A0\\n\\tsubc\\t%B2, %B0\\n\\tsubc\\t%C2, %C0\\n\\tsubc\\t%D2, %D0\";
+}"
+[(set_attr "length" "4,2")
+(set_attr "cc" "further,further")])
+
+(define_insn "*adddi3_3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"      	"=rm")
+        (plus:DI (match_operand:DI 1 "nonimmediate_operand"  	"%0")
+                 (match_operand:DI 2 "general_operand"  	" rmi")))]
+""
+"* return msp430_adddi_code(insn, operands, NULL);"
+  [(set_attr "length" "12")
+   (set_attr "cc" "further")])
+
+
+;;-----------------------------------------------------------------------
+;;-----------------------------------------------------------------------
+;;-----------------------------------------------------------------------
+;;-----------------------------------------------------------------------
+;;-----------------------------------------------------------------------
+;; sub 1 byte 
+
+
+(define_expand "subqi3" 
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (minus:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")   
+                  (match_operand:QI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+(define_insn "*subqi3_3"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"          "=m,m,m,m,r,r,r,r")  
+        (minus:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "0,0,0,0,0,0,0,0")  
+                 (match_operand:QI 2 "general_operand_msp430"      " m,r,P,i,m,r,P,i")))]  
+""
+  "sub.b	%2, %0"
+  [(set_attr "length" "3,2,2,3,2,1,1,2")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; sub 1 word (16 bits)
+;; same as above
+
+
+(define_expand "subhi3" 
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (minus:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "")
+                  (match_operand:HI 2 "general_operand_msp430" "")))]
+  ""
+  "")
+
+(define_insn "*subhi3_3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"          "=m,m,m,m,r,r,r,r")
+        (minus:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0,0,0,0,0,0,0")
+                  (match_operand:HI 2 "general_operand_msp430"      "m,r,P,i,m,r,P,i")))]
+""
+  "sub	%2, %0"
+  [(set_attr "length" "3,2,2,3,2,1,1,2")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; sub 2 words (32 bits)
+;; same as above
+
+(define_expand "subsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (minus:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                 (match_operand:SI 2 "general_operand" "")))]
+  "" 
+  "")
+
+
+(define_insn "*subsi3_3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"      "=rm")
+        (minus:SI (match_operand:SI 1 "general_operand"  "0")
+                 (match_operand:SI 2 "general_operand"  " rmi")))]
+""
+"* return msp430_subsi_code(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "further")])
+
+
+;;============================================================================
+;; sub 4 words (64 bits)
+;; same as above
+
+(define_expand "subdi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (minus:DI (match_operand:DI 1 "nonimmediate_operand" "")   
+                 (match_operand:DI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*subdi3_3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"      	"=rm")
+        (minus:DI (match_operand:DI 1 "nonimmediate_operand"  	"0")
+                 (match_operand:DI 2 "general_operand"  	" rmi")))]
+""
+"* return msp430_subdi_code(insn, operands,NULL);"
+  [(set_attr "length" "12")
+   (set_attr "cc" "further")])
+
+
+
+
+
+;;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
+;; and 1 byte 
+
+(define_expand "andqi3" 
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (and:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")   
+                 (match_operand:QI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+
+(define_insn "*andqi3_inv"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"         "=r,m")   
+        (and:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "%0,0")
+                (match_operand:QI 2 "immediate_operand"    " i,i")))]
+"(INTVAL(operands[2])==~1
+  || INTVAL(operands[2])==~2
+  || INTVAL(operands[2])==~4
+  || INTVAL(operands[2])==~8)"
+"* {
+	operands[2] = gen_rtx_CONST_INT(QImode, ~(INTVAL(operands[2])));
+	return \"bic.b	%2,%0\";
+}"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "none,none")])
+
+
+(define_insn "*andqi3_3"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"      	"=r,m,r,m,r,m,m,r")
+        (and:QI (match_operand:QI 1 "nonimmediate_operand_msp430"  	"%0,0,0,0,0,0,0,0")
+                (match_operand:QI 2 "general_operand_msp430"  		" r,m,P,P,m,r,i,i")))]
+""
+"and.b	%2, %0"
+  [(set_attr "length" "1,3,1,2,2,2,3,2")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; and 1 word (16 bits)
+;; same as above
+
+(define_expand "andhi3" 
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (and:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "%0")   
+                 (match_operand:HI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+
+(define_insn "*andhi3_inv"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"         "=r,m")   
+        (and:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0")   
+                (match_operand:HI 2 "immediate_operand"    " i,i")))]
+"(INTVAL(operands[2])==~1
+  || INTVAL(operands[2])==~2
+  || INTVAL(operands[2])==~4
+  || INTVAL(operands[2])==~8)"
+"* {
+	operands[2] = gen_rtx_CONST_INT(HImode, ~(INTVAL(operands[2])));
+	return \"bic	%2,%0\";
+}"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "none")])
+
+(define_insn "*andhi3_clrup"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"         "=r,m")
+        (and:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0")
+                (match_operand:HI 2 "immediate_operand"    " i,i")))]
+"INTVAL(operands[2])==255"
+"@
+and.b	#-1, %0
+clr.b	%J0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "clobber,clobber")])
+
+(define_insn "*andhi3_clrlw"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"         "=m,r")
+        (and:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0")
+                (match_operand:HI 2 "immediate_operand"     " i,i")))]
+"((0xffff&INTVAL(operands[2]))==0xff00)"
+"@
+clr.b	%I0
+and\\t#0xff00, %0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*andhi3_3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"      		"=r,m,r,m,r,m,m,r")
+        (and:HI (match_operand:HI 1 "nonimmediate_operand_msp430"  	"%0,0,0,0,0,0,0,0")
+                (match_operand:HI 2 "general_operand_msp430"  		" r,m,P,P,m,r,i,i")))]
+""
+"and	%2, %0"
+  [(set_attr "length" "1,3,1,2,2,2,3,2")
+   (set_attr "cc" "set_czn")])
+
+
+
+
+
+;;============================================================================
+;; and 2 words (32 bits)
+;; same as above
+
+(define_expand "andsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (and:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                (match_operand:SI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*andsi3_3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"          "=rm")
+        (and:SI (match_operand:SI 1 "nonimmediate_operand"  "%0")
+                (match_operand:SI 2 "general_operand"       " rmi")))]
+""
+"* return msp430_andsi_code(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "further")])
+
+
+;;============================================================================
+;; and 4 words (64 bits)
+;; same as above
+
+(define_expand "anddi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (and:DI (match_operand:DI 1 "nonimmediate_operand" "")   
+                (match_operand:DI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*anddi3_3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"         "=rm")
+        (and:DI (match_operand:DI 1 "nonimmediate_operand" "%0")
+                (match_operand:DI 2 "general_operand"      " rmi")))]
+""
+"* return msp430_anddi_code(insn, operands, NULL);"
+  [(set_attr "length" "14")
+   (set_attr "cc" "further")])
+
+
+
+;;|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+;; ior 1 byte 
+;; looks like a 'mov' insn
+
+(define_expand "iorqi3" 
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (ior:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")   
+                 (match_operand:QI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+(define_insn "*iorqi3_3"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"      	"=r,m,r,m,r,m,m,r")
+        (ior:QI (match_operand:QI 1 "nonimmediate_operand_msp430"  	"%0,0,0,0,0,0,0,0")
+                (match_operand:QI 2 "general_operand_msp430"  		" r,m,P,P,m,r,i,i")))]
+""
+  "bis.b	%2, %0"
+  [(set_attr "length" "1,3,1,2,2,2,3,2")
+   (set_attr "cc" "none")])
+
+
+
+;;============================================================================
+;; ior 1 word (16 bits)
+;; same as above
+
+(define_expand "iorhi3" 
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (ior:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "")   
+                 (match_operand:HI 2 "general_operand_msp430" "")))]
+  "" 
+  "
+    if(const_int_operand(operands[2], VOIDmode))
+    {
+      int x = INTVAL(operands[2]) & 0xffff;
+      if(!x) DONE;
+    }
+  ")
+
+(define_insn "*iorhi3_3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"      	"=r,m,r,m,r,m,m,r")
+        (ior:HI (match_operand:HI 1 "nonimmediate_operand_msp430"  	"%0,0,0,0,0,0,0,0")
+                (match_operand:HI 2 "general_operand_msp430"  		" r,m,P,P,m,r,i,i")))]
+""
+  "bis	%2, %0"
+  [(set_attr "length" "1,3,1,2,2,2,3,2")
+   (set_attr "cc" "none")])
+
+
+
+;;============================================================================
+;; ior 2 words (32 bits)
+;; same as above
+
+
+(define_expand "iorsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (ior:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                 (match_operand:SI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*iorsi3_3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"      "=rm")
+        (ior:SI (match_operand:SI 1 "nonimmediate_operand"   "%0")
+                (match_operand:SI 2 "general_operand"   " rmi")))]
+""
+"* return msp430_iorsi_code(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "none")])
+
+(define_split
+ [(set (match_operand:SI 0 "nonimmediate_operand"          "")
+       (ior:SI (match_operand:SI 1 "nonimmediate_operand"  "")
+	       (match_operand:SI 2 "const_int_operand"     "")))]
+ "reload_completed
+  && (halfnibble_integer(operands[2], VOIDmode)
+       || halfnibble_constant(operands[2], VOIDmode))"
+ [(set (match_dup 3) (ior:HI (match_dup 4) (match_dup 5)))]
+ "{
+      int lo = trunc_int_for_mode(INTVAL(operands[2]),HImode);
+      int hi = trunc_int_for_mode(INTVAL(operands[2])>>16,HImode);
+ 
+      if(lo == -1)
+      {
+	rtx op = gen_lowpart(HImode, operands[0]);
+	emit_insn(gen_rtx_SET(HImode, op, GEN_INT(-1)));
+	DONE;
+      }
+      
+      if(hi == -1)
+      {
+	rtx op = gen_highpart(HImode, operands[0]);
+	emit_insn(gen_rtx_SET(HImode, op, GEN_INT(-1)));
+	DONE;
+      }
+      
+      if(lo)
+      {
+	operands[3] = gen_lowpart(HImode, operands[0]);
+	operands[4] = gen_lowpart(HImode, operands[1]);
+	operands[5] = GEN_INT(lo);
+      }
+      else if(hi)
+      {
+	operands[3] = gen_highpart(HImode, operands[0]);
+	operands[4] = gen_highpart(HImode, operands[1]);
+	operands[5] = GEN_INT(hi);
+      }
+ }")
+
+(define_peephole2
+ [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "") 
+       (const_int 0))
+  (set (match_dup 0) (ior:HI (match_dup 0) 
+			     (match_operand:HI 1 "const_int_operand" "")))]
+ ""
+ [(set (match_dup 0) (match_dup 1))]
+ "")
+ 
+
+;;============================================================================
+;; ior 4 words (64 bits)
+;; same as above
+
+(define_expand "iordi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (ior:DI (match_operand:DI 1 "nonimmediate_operand" "")   
+                (match_operand:DI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*iordi3_3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"          "=rm")
+        (ior:DI (match_operand:DI 1 "nonimmediate_operand"  "%0")
+                (match_operand:DI 2 "general_operand"  " rmi")))]
+""
+"* return msp430_iordi_code(insn, operands, NULL);"
+  [(set_attr "length" "12")
+   (set_attr "cc" "none")])
+
+
+
+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;; xor 1 byte 
+;; looks like a 'mov' insn
+
+(define_expand "xorqi3" 
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (xor:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")   
+                 (match_operand:QI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+(define_insn "*xorqi3_3"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"      	"=r,m,r,m,r,m,m,r")
+        (xor:QI (match_operand:QI 1 "nonimmediate_operand_msp430"  	"%0,0,0,0,0,0,0,0")
+                (match_operand:QI 2 "general_operand_msp430"  		" r,m,P,P,m,r,i,i")))]
+""
+  "xor.b	%2, %0"
+  [(set_attr "length" "1,3,1,2,2,2,3,2")
+   (set_attr "cc" "set_czn")])
+
+
+
+;;============================================================================
+;; xor 1 word (16 bits)
+;; same as above
+
+(define_expand "xorhi3" 
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (xor:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "")   
+                 (match_operand:HI 2 "general_operand_msp430" "")))]
+  "" 
+  "")
+
+(define_insn "*xorhi3_3"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"      	"=r,m,r,m,r,m,m,r")
+        (xor:HI (match_operand:HI 1 "nonimmediate_operand_msp430"  	"%0,0,0,0,0,0,0,0")
+                (match_operand:HI 2 "general_operand_msp430"  		" r,m,P,P,m,r,i,i")))]
+""
+  "xor	%2, %0"
+  [(set_attr "length" "1,3,1,2,2,2,3,2")
+   (set_attr "cc" "set_czn")])
+
+
+
+;;============================================================================
+;; xor 2 words (32 bits)
+;; same as above
+
+(define_expand "xorsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (xor:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                 (match_operand:SI 2 "general_operand" "")))]
+  "" 
+  "")
+
+
+(define_insn "*xorsi3_3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"      "=rm")
+        (xor:SI (match_operand:SI 1 "nonimmediate_operand"   "%0")
+                 (match_operand:SI 2 "general_operand"  " rmi")))]
+""
+"* return msp430_xorsi_code(insn, operands, NULL);"
+  [(set_attr "length" "6")
+   (set_attr "cc" "further")])
+
+
+(define_split
+ [(set (match_operand:SI 0 "nonimmediate_operand"          "")
+       (xor:SI (match_operand:SI 1 "nonimmediate_operand"  "")
+	       (match_operand:SI 2 "const_int_operand"     "")))]
+ "reload_completed 
+  && (halfnibble_integer(operands[2], VOIDmode)
+       || halfnibble_constant(operands[2], VOIDmode))
+  && INTVAL(operands[2])"
+ [(set (match_dup 3) (xor:HI (match_dup 4) (match_dup 5)))]
+ "{
+      int lo = trunc_int_for_mode(INTVAL(operands[2]),HImode);
+      int hi = trunc_int_for_mode(INTVAL(operands[2])>>16,HImode);
+      
+      if(lo)
+      {
+	operands[3] = gen_lowpart(HImode, operands[0]);
+	operands[4] = gen_lowpart(HImode, operands[1]);
+	operands[5] = GEN_INT(lo);
+      }
+      else if(hi)
+      {
+	operands[3] = gen_highpart(HImode, operands[0]);
+	operands[4] = gen_highpart(HImode, operands[1]);
+	operands[5] = GEN_INT(hi);
+      }
+ }")
+
+
+(define_peephole2
+ [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "") 
+       (const_int 0))
+  (set (match_dup 0) (xor:HI (match_dup 0) 
+			     (const_int -1)))]
+ ""
+ [(set (match_dup 0) (const_int -1))]
+ "")
+ 
+
+;;============================================================================
+;; xor 4 words (64 bits)
+;; same as above
+
+(define_expand "xordi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (xor:DI (match_operand:DI 1 "nonimmediate_operand" "")   
+                (match_operand:DI 2 "general_operand" "")))]
+  "" 
+  "")
+
+(define_insn "*xordi3_3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"          "=rm")
+        (xor:DI (match_operand:DI 1 "nonimmediate_operand"  "%0")
+                (match_operand:DI 2 "general_operand"  	    " rmi")))]
+""
+"* return msp430_xordi_code(insn, operands, NULL);"
+  [(set_attr "length" "4")
+   (set_attr "cc" "further")])
+
+
+
+
+
+;;------------------------------------------------------------------------
+;; neg
+;; same as above
+
+(define_expand "negqi2"
+ [(set (match_operand:QI 0 "nonimmediate_operand" "")
+   (neg:QI (match_operand:QI 1 "nonimmediate_operand" "")))]
+ ""
+ "{ emit_insn(gen_one_cmplqi2(operands[0],operands[1]));
+ emit_insn(gen_addqi3(operands[0],operands[0],const1_rtx));
+ DONE; }")
+
+(define_expand "neghi2"
+ [(set (match_operand:HI 0 "nonimmediate_operand" "")
+   (neg:HI (match_operand:HI 1 "nonimmediate_operand" "")))]
+ ""
+ "{ emit_insn(gen_one_cmplhi2(operands[0],operands[1]));
+ emit_insn(gen_addhi3(operands[0],operands[0],const1_rtx));
+ DONE; }")
+
+(define_expand "negsi2"
+ [(set (match_operand:SI 0 "nonimmediate_operand" "")
+   (neg:SI (match_operand:SI 1 "nonimmediate_operand" "")))]
+ ""
+ "{ emit_insn(gen_one_cmplsi2(operands[0],operands[1]));
+ emit_insn(gen_addsi3(operands[0],operands[0],const1_rtx));
+ DONE; }")
+
+(define_expand "negdi2"
+ [(set (match_operand:DI 0 "nonimmediate_operand" "")
+   (neg:DI (match_operand:DI 1 "nonimmediate_operand" "")))]
+ ""
+ "{ emit_insn(gen_one_cmpldi2(operands[0],operands[1]));
+ emit_insn(gen_adddi3(operands[0],operands[0],const1_rtx));
+ DONE; }")
+
+(define_insn "negsf2"
+ [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m")
+   (neg:SF (match_operand:SF 1 "nonimmediate_operand" "0,0")))]
+ ""
+ "xor  #0x8000, %B0"
+ [(set_attr "length" "2,3")
+ (set_attr "cc" "clobber,clobber")])
+
+;;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+;; not	x = !x
+;; ones component
+
+(define_expand "one_cmplqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+        (not:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "")))]
+  ""
+  "")
+
+(define_insn "*one_cmplqi2_2"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" 	   "=r,m")
+        (not:QI (match_operand:QI 1 "nonimmediate_operand_msp430" " 0, 0")))]
+  ""
+  "inv.b	%0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; not HI	x = !x
+;; - ones component
+
+(define_expand "one_cmplhi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "")
+        (not:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0")))]
+  ""
+  "")
+
+(define_insn "*one_cmplhi2_2"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" 	   "=r, m")
+        (not:HI (match_operand:HI 1 "nonimmediate_operand_msp430" " 0, 0")))]
+  ""
+  "inv	%0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "set_czn")])
+
+
+
+;;============================================================================
+;; not SI	x = !x 
+;; - ones component
+
+(define_expand "one_cmplsi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (not:SI (match_operand:SI 1 "nonimmediate_operand" "0")))]
+  ""
+  "{
+      rtx op0, op1;
+      
+      op0 = gen_lowpart(HImode,operands[0]);
+      op1 = gen_lowpart(HImode,operands[1]);
+      emit_insn(gen_one_cmplhi2(op0,op1));
+      op0 = gen_highpart(HImode,operands[0]);
+      op1 = gen_highpart(HImode,operands[1]);
+      emit_insn(gen_one_cmplhi2(op0,op1));
+      DONE;
+  }")
+
+(define_insn "*one_cmplsi2_2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" 	   "=r, m")
+        (not:SI (match_operand:SI 1 "nonimmediate_operand" " 0, 0")))]
+""
+  "inv	%A0
+	inv	%B0"
+  [(set_attr "length" "2,4")
+   (set_attr "cc" "further,further")])
+
+;;============================================================================
+;; not DI	x = !x
+;; - ones component
+
+(define_expand "one_cmpldi2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (not:DI (match_operand:DI 1 "nonimmediate_operand" "0")))]
+  ""
+  "")
+
+(define_insn "*one_cmpldi2_2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" 	   "=r, m")
+        (not:DI (match_operand:DI 1 "nonimmediate_operand" " 0, 0")))]
+  ""
+  "inv	%A0
+	inv	%B0
+	inv	%C0
+	inv	%D0"
+  [(set_attr "length" "4,8")
+   (set_attr "cc" "further,further")])
+
+
+
+;;============================================================================
+;; abs
+;; x = |x|
+
+(define_expand "absqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+        (abs:QI (match_operand:QI 1 "nonimmediate_operand" "")))]
+  ""
+  "")
+
+(define_insn "*absqi2_2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" 	   "=r,m")
+        (abs:QI (match_operand:QI 1 "nonimmediate_operand" " 0,0")))]
+  ""
+	"tst.b	%1
+	jge	.Leaq%=
+	inv.b	%0
+	inc.b	%0
+.Leaq%=:"
+  [(set_attr "length" "4,7")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; abs HI	x = |x|
+;; 
+
+(define_expand "abshi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+        (abs:HI (match_operand:HI 1 "nonimmediate_operand" "0")))]
+  ""
+  "")
+
+
+(define_insn "*abshi2_2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" 	   "=r,m")
+        (abs:HI (match_operand:HI 1 "nonimmediate_operand" " 0,0")))]
+  ""
+	"tst	%1
+	jge	.Laeh%=
+	inv	%0
+	inc	%0
+.Laeh%=:"
+  [(set_attr "length" "4,7")
+   (set_attr "cc" "set_czn")])
+
+
+;;============================================================================
+;; abs SI	x = |x|
+
+(define_expand "abssi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (abs:SI (match_operand:SI 1 "nonimmediate_operand" "0")))]
+  ""
+  "")
+
+(define_insn "*abssi2_2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" 	   "=r,m")
+        (abs:SI (match_operand:SI 1 "nonimmediate_operand" " 0,0")))]
+  ""
+  "* return msp430_emit_abssi(insn, operands,NULL);"
+  [(set_attr "length" "6,11")
+   (set_attr "cc" "clobber")])
+
+
+;;============================================================================
+;; abs DI	x = |x|
+
+(define_expand "absdi2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "")
+        (abs:DI (match_operand:DI 1 "nonimmediate_operand" "0")))]
+  ""
+  "")
+
+(define_insn "*absdi2_2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" 	   "=r,m")
+        (abs:DI (match_operand:DI 1 "nonimmediate_operand" " 0,0")))]
+  ""
+  "* return msp430_emit_absdi(insn, operands,NULL);"
+  [(set_attr "length" "10,18")
+   (set_attr "cc" "clobber")])
+
+;;============================================================================
+;; abs SF
+
+(define_insn "abssf2"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m")
+        (abs:SF (match_operand:SF 1 "nonimmediate_operand" "0,0")))]
+""
+"and	#0x7fff, %B0"
+  [(set_attr "length" "2,3")
+   (set_attr "cc" "clobber")])
+
+
+;; ==========================================================================
+;; there are shift helpers
+
+(define_insn "trunchiqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,m") 
+	(truncate:QI (match_operand:HI 1 "register_operand" "r,r")))]
+""
+"mov.b	%1, %0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "none")])
+
+(define_insn "truncsihi"
+  [(set (match_operand:HI 0 "register_operand" "=r") 
+	(truncate:HI (match_operand:SI 1 "register_operand" "r")))]
+""
+"mov	%1, %0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+
+(define_insn "truncsiqi"
+  [(set (match_operand:QI 0 "register_operand" "=r") 
+	(truncate:QI (match_operand:SI 1 "register_operand" "r")))]
+""
+"mov.b	%1, %0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+
+(define_insn "truncdiqi"
+  [(set (match_operand:QI 0 "register_operand" "=r") 
+	(truncate:QI (match_operand:DI 1 "register_operand" "r")))]
+""
+"mov.b	%1, %0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+(define_insn "truncdisi"
+  [(set (match_operand:SI 0 "register_operand" "=r") 
+	(truncate:SI (match_operand:DI 1 "register_operand" "r")))]
+""
+"mov	%A1,%A0
+	mov    %B1,%B0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+
+(define_expand "rotlhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (rotate:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "const_int_operand"  "")))]
+""
+"
+  if(INTVAL(operands[2])!=8) FAIL;
+")
+
+(define_insn "*rotlhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "=rR,m")
+        (rotate:HI (match_operand:HI 1 "nonimmediate_operand" "0,0")
+                   (const_int 8)))]
+""
+"swpb\\t%0"
+  [(set_attr "length" "1,2")
+     (set_attr "cc" "none")])
+
+
+;;<< << << << << << << << << << << << << << << << << << << << << << << << <<
+;; << << << << << << << << << << << << << << << << << << << << << << << <<
+;;<< << << << << << << << << << << << << << << << << << << << << << << << <<
+;; << << << << << << << << << << << << << << << << << << << << << << << <<
+;;<< << << << << << << << << << << << << << << << << << << << << << << << <<
+;; arithmetic shift left
+
+(define_expand "ashlqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"       "")
+        (ashift:QI (match_operand:QI 1 "nonimmediate_operand" "")
+                   (match_operand:QI 2 "general_operand"  "")))]
+""
+"{
+   if(!const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(QImode,operands[0]);
+     op1 = force_reg(QImode,operands[1]);
+     operands[2] = copy_to_mode_reg(QImode,operands[2]);
+     emit_insn(gen_ashlqi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], QImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(QImode,operands[1]);
+      emit_insn (gen_ashlqi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "ashlqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (ashift:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashlqi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "ashlqi3fnl"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"       "=rm")
+        (ashift:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "0")
+                   (match_operand 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashlqi3(insn, operands,NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; HImode  ======================================
+(define_expand "ashlhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (ashift:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand 2 "general_operand"  "")))]
+""
+"{ msp430_ashlhi3(operands); DONE; }")
+
+(define_insn "ashlhi3_cnt"
+  [(parallel [(set (match_operand:HI 0 "register_operand"       "=r")
+	      (ashift:HI (match_operand:HI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "r")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_ashlhi3(insn, operands,NULL);"
+  [(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlhi3_1"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashift:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0,0")
+                   (const_int 1)))]
+  ""
+  "rla\\t%0"
+  [(set_attr "length" "1,2,3")
+   (set_attr "cc" "set_czn")])
+
+(define_insn "*ashlhi3_15"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashift:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0,0")
+                   (const_int 15)))]
+  ""
+  "rra\\t%0
+\\tclr\\t%0
+\\trrc\\t%0"
+  [(set_attr "length" "3,5,7")
+   (set_attr "cc" "clobber")])
+
+
+;; SImode ======================================
+
+(define_expand "ashlsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"       "")
+        (ashift:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{ msp430_ashlsi3(operands); DONE; }")
+
+(define_insn "ashlsi3_cnt"
+  [(parallel [(set (match_operand:SI 0 "register_operand"       "=r")
+	      (ashift:SI (match_operand:SI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashlsi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlsi3_31"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashift:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+                   (const_int 31)))]
+  ""
+"rra\\t%A0
+\\tclr\\t%A0
+\\tclr\\t%B0
+\\trrc\\t%B0"
+[(set_attr "length" "4,7,8")
+  (set_attr "cc" "clobber")])
+
+
+(define_insn "*ashlsi3_8"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashift:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+                   (const_int 8)))]
+  ""
+  "*{
+  if(which_alternative==0)
+  {
+  return \"xor.b\\t%A0, %B0\\n\\txor\\t%A0, %B0\\n\\tswpb\\t%B0\\n\\tand.b\\t#-1, %A0\\n\\tswpb\\t%A0 \";
+  }
+  else
+  {
+  return \"xor.b\\t%A0, %B0\\n\\tclr.b\\t%L0\\n\\txor\\t%A0, %B0\\n\\tswpb\\t%B0\\n\\tclr.b\\t%J0\\n\\tswpb\\t%A0\";
+  }
+  }"
+  [(set_attr "length" "5,11,12")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashlsi3_16"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,m,r,m")
+        (ashift:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "rR,rR,m,m")
+                   (const_int 16)))]
+""
+"mov	%A1, %B0"
+[(set_attr "length" "1,2,2,3")
+  (set_attr "cc" "clobber")])
+
+(define_insn "*ashlsi3_1"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=m,R,r")
+        (ashift:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+                   (const_int 1)))]
+  ""
+"rla\\t%A0
+\\trlc\\t%B0"
+[(set_attr "length" "6,5,2")
+  (set_attr "cc" "clobber")])
+
+;; DImode ======================================
+
+(define_expand "ashldi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "")
+        (ashift:DI (match_operand:DI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{
+   if( !const_int_operand(operands[2],VOIDmode) ||
+       INTVAL(operands[2]) > 1)
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(DImode,operands[0]);
+     op1 = force_reg(DImode,operands[1]);
+     operands[2] = copy_to_mode_reg(HImode,operands[2]);
+     emit_insn(gen_ashldi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], DImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(DImode,operands[1]);
+      emit_insn (gen_ashldi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "ashldi3_cnt"
+  [(parallel [(set (match_operand:DI 0 "register_operand"       "=r")
+	      (ashift:DI (match_operand:DI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_ashldi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "ashldi3fnl"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "=rm")
+        (ashift:DI (match_operand:DI 1 "nonimmediate_operand" "0")
+                   (match_operand 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashldi3(insn, operands,NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>      
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>     
+;; arithmetic shift right
+
+(define_expand "ashrqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"       "")
+        (ashiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "")
+                   (match_operand:QI 2 "general_operand"  "")))]
+""
+"{
+   if(!const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(QImode,operands[0]);
+     op1 = force_reg(QImode,operands[1]);
+     operands[2] = copy_to_mode_reg(QImode,operands[2]);
+     emit_insn(gen_ashrqi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], QImode) 
+		&& INTVAL(operands[2])>2 
+		&& INTVAL(operands[2])!=7)
+   {
+      operands[1] = copy_to_mode_reg(QImode,operands[1]);
+      emit_insn (gen_ashrqi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+   else if(INTVAL(operands[2]) == 7)
+   {
+      /* to do it simple we need a register */
+      rtx r1 = gen_reg_rtx(HImode);
+      emit_insn(gen_extendqihi2(r1,operands[1]));
+      emit_insn(gen_swpb(r1,r1));
+      emit_insn(gen_trunchiqi(operands[0],r1));
+      DONE;
+   }
+}")
+
+(define_insn "ashrqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashrqi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "ashrqi3fnl"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"       "=rm")
+        (ashiftrt:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "0")
+                   (match_operand 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashrqi3(insn, operands,NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; HImode  ======================================
+(define_expand "ashrhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (ashiftrt:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand 2 "general_operand"  "")))]
+""
+"{msp430_ashrhi3(operands); DONE; }")
+
+(define_insn "ashrhi3_cnt"
+  [(parallel [(set (match_operand:HI 0 "register_operand"       "=r")
+	      (ashiftrt:HI (match_operand:HI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashrhi3(insn, operands,NULL);"
+  [(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*ashrhi3_1"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"       "=rR,m")
+        (ashiftrt:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0")
+		     (const_int 1)))]
+  ""
+  "rra\\t%0"
+  [(set_attr "length" "1,2")
+   (set_attr "cc" "set_czn")])
+
+
+(define_insn "*ashrhi3_15"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashiftrt:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 15)))]
+  ""
+  "rla\\t%0
+\\tsubc\\t%0, %0
+\\tinv\\t%0"
+  [(set_attr "length" "3,6,8")
+   (set_attr "cc" "clobber")])
+
+
+
+;; SImode ======================================
+
+(define_expand "ashrsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"       "")
+        (ashiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{msp430_ashrsi3(operands);DONE; }")
+
+(define_insn "ashrsi3_cnt"
+  [(parallel [(set (match_operand:SI 0 "register_operand"       "=r")
+	      (ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_ashrsi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashrsi3_1"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=rR,m")
+        (ashiftrt:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0")
+		     (const_int 1)))]
+  ""
+  "rra\\t%B0
+\\trrc\\t%A0"
+  [(set_attr "length" "2,4")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashrsi3_31"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashiftrt:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 31)))]
+  ""
+"rla\\t%B0
+\\tsubc\\t%B0, %B0
+\tinv\\t%B0
+\\tmov	%B0, %A0"
+  [(set_attr "length" "4,11,11")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*ashrsi3_8"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (ashiftrt:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 8)))]
+  ""
+"*{
+  if(which_alternative==0)
+  {
+  return \" swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\txor\\t%B0, %A0\\n\\tsxt\\t%B0\";
+  }
+  else
+  {
+  return \" swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\tclr.b\\t%J0\\n\\txor\\t%B0, %A0\\n\\tsxt\\t%B0\";
+  }
+}"
+  [(set_attr "length" "5,11,12")
+   (set_attr "cc" "clobber")])
+
+;; DImode ======================================
+
+(define_expand "ashrdi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "")
+        (ashiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{
+   if( !const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(DImode,operands[0]);
+     op1 = force_reg(DImode,operands[1]);
+     operands[2] = copy_to_mode_reg(HImode,operands[2]);
+     emit_insn(gen_ashrdi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], DImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(DImode,operands[1]);
+      emit_insn (gen_ashrdi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "ashrdi3_cnt"
+  [(parallel [(set (match_operand:DI 0 "register_operand"       "=r")
+	      (ashiftrt:DI (match_operand:DI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_ashrdi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "ashrdi3fnl"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "=rm")
+        (ashiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "0")
+                   (match_operand 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_ashrdi3(insn, operands,NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+
+
+
+
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;;  >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>   
+;; logical shift right
+
+(define_expand "lshrqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand"       "")
+        (lshiftrt:QI (match_operand:QI 1 "nonimmediate_operand" "")
+                   (match_operand:QI 2 "general_operand"  "")))]
+""
+"{
+   if(!const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(QImode,operands[0]);
+     op1 = force_reg(QImode,operands[1]);
+     operands[2] = copy_to_mode_reg(QImode,operands[2]);
+     emit_insn(gen_lshrqi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], QImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(QImode,operands[1]);
+      emit_insn (gen_lshrqi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_expand "lshrqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"")
+
+(define_insn "*lshrqi3_cnt"
+  [(parallel [(set (match_operand:QI 0 "register_operand"       "=r")
+	      (lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
+			 (match_operand:QI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_lshrqi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+(define_insn "lshrqi3fnl"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430"       "=rm")
+        (lshiftrt:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "0")
+                   (match_operand 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_lshrqi3(insn, operands,NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+;; HImode  ======================================
+
+(define_insn "clrc"
+ [(unspec:HI [(const_int 123454321)] 30)]
+""
+ "clrc"
+[(set_attr "length" "1")
+  (set_attr "cc" "clobber")])
+
+ 
+(define_expand "lshrhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand"       "")
+        (lshiftrt:HI (match_operand:HI 1 "nonimmediate_operand" "")
+                   (match_operand 2 "general_operand"  "")))]
+""
+"{msp430_lshrhi3(operands); DONE; }")
+
+(define_insn "lshrhi3_cnt"
+  [(parallel [(set (match_operand:HI 0 "register_operand"       "=r")
+	      (lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_lshrhi3(insn, operands,NULL);"
+  [(set_attr "length" "5")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*lshrhi3_15"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (lshiftrt:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 15)))]
+  ""
+  "rla\\t%0
+\\tclr\\t%0
+\\trlc\\t%0"
+  [(set_attr "length" "3,6,8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*lshrhi3_1"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430"       "=rR,m")
+        (lshiftrt:HI (match_operand:HI 1 "nonimmediate_operand_msp430" "0,0")
+		     (const_int 1)))]
+  ""
+"clrc
+\\trrc\\t%0"
+  [(set_attr "length" "2,3")
+   (set_attr "cc" "clobber")])
+
+;; SImode ======================================
+
+(define_expand "lshrsi3"
+  [(set (match_operand:SI 0 "nonimmediate_operand"       "")
+        (lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{ msp430_lshrsi3(operands); DONE; }")
+
+(define_insn "lshrsi3_cnt"
+  [(parallel [(set (match_operand:SI 0 "register_operand"       "=r")
+	      (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+""
+"* return msp430_emit_lshrsi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*lshrsi3_31"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 31)))]
+  ""
+"rla	%B0
+\\tclr	%B0
+\\tclr	%A0
+\\trlc	%A0"
+  [(set_attr "length" "4,9,10")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "*lshrsi3_8"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 8)))]
+  ""
+"*{
+  if(which_alternative==0)
+  {
+  return \"swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\txor\\t%B0, %A0\\n\\tand.b\\t#-1, %B0\";
+  }
+  else
+  {
+  return \"swpb\\t%A0\\n\\tswpb\\t%B0\\n\\txor.b\\t%B0, %A0\\n\\tclr.b\\t%J0\\n\\txor\\t%B0, %A0\\n\\tclr.b\\t%L0\";
+  }
+}"
+  [(set_attr "length" "5,11,12")
+   (set_attr "cc" "clobber")])
+
+(define_insn "*lshrsi3_1"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430"       "=r,R,m")
+        (lshiftrt:SI (match_operand:SI 1 "nonimmediate_operand_msp430" "0,0,0")
+		     (const_int 1)))]
+  ""
+"clrc
+\\trrc\\t%B0
+\\trrc\\t%A0"
+  [(set_attr "length" "3,4,5")
+   (set_attr "cc" "clobber")])
+
+;; DImode ======================================
+
+(define_expand "lshrdi3"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "")
+        (lshiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "")
+                   (match_operand:HI 2 "general_operand"  "")))]
+""
+"{
+   if( !const_int_operand(operands[2],VOIDmode))
+   {
+     rtx op0,op1;
+     
+     op0 = force_reg(DImode,operands[0]);
+     op1 = force_reg(DImode,operands[1]);
+     operands[2] = copy_to_mode_reg(HImode,operands[2]);
+     emit_insn(gen_lshrdi3_cnt (op0, op1, operands[2]));
+     emit_move_insn(operands[0],op0);
+     /*emit_move_insn(operands[1],op1);*/ 
+     DONE;
+   }
+   else if(!register_operand(operands[1], DImode) 
+		&& is_shift_better_in_reg(operands))
+   {
+      operands[1] = copy_to_mode_reg(DImode,operands[1]);
+      emit_insn (gen_lshrdi3fnl(operands[0], operands[1], operands[2]));
+      DONE;
+   }
+}")
+
+(define_insn "lshrdi3_cnt"
+  [(parallel [(set (match_operand:DI 0 "register_operand"       "=r")
+	      (lshiftrt:DI (match_operand:DI 1 "register_operand" "0")
+			 (match_operand:HI 2 "register_operand" "")))
+	      (clobber (match_dup 2))])]
+  ""
+  "* return msp430_emit_lshrdi3(insn, operands,NULL);"
+  [(set_attr "length" "8")
+   (set_attr "cc" "clobber")])
+
+
+(define_insn "lshrdi3fnl"
+  [(set (match_operand:DI 0 "nonimmediate_operand"       "=rm")
+        (lshiftrt:DI (match_operand:DI 1 "nonimmediate_operand" "0")
+                   (match_operand 2 "const_int_operand"  "i")))]
+  ""
+  "* return msp430_emit_lshrdi3(insn, operands,NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")])
+
+
+
+
+
+
+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
+;; xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x xx<---x
+;; sign extend
+
+(define_insn "subc2"
+ [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,m,m") 
+   (unspec_volatile:HI [(match_operand:HI 1 "nonimmediate_operand" "+rRP,mi,rRP,mi")] 51))]
+ ""
+ "subc\\t%1, %0"
+ [(set_attr "length" "1,2,2,3")
+    (set_attr "cc" "clobber")])
+
+(define_insn "extendqihi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rm,rm")
+        (sign_extend:HI (match_operand:QI 1 "general_operand" "0,*rmi")))]
+  ""
+  "* return signextendqihi(insn, operands,NULL);"
+  [(set_attr "length" "2,2")
+   (set_attr "cc" "clobber")])
+
+(define_expand "extendhisi2"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "")
+        (sign_extend:SI (match_operand:HI 1 "general_operand" "")))] 
+  ""
+  "{
+    rtx op0, op1, op0lo, op0hi;
+    op0 = operands[0];
+    op1 = operands[1];
+    op0hi = gen_highpart(HImode, operands[0]);
+    op0lo = gen_lowpart(HImode, operands[0]);
+    emit_move_insn(op0lo, op1);
+    emit_move_insn(op0hi, op0lo);
+    emit_insn(gen_ashlhi3(op0hi, op0hi, const1_rtx));
+    emit_insn(gen_subc2(op0hi, op0hi));
+    emit_insn(gen_one_cmplhi2(op0hi, op0hi));
+    DONE;
+  }")
+  
+
+(define_insn "extendsidi2"
+  [(set (match_operand:DI 0 "nonimmediate_operand" "=rm,rm")
+        (sign_extend:DI (match_operand:SI 1 "general_operand" "0,*rmi")))]
+  ""
+  "* return signextendsidi(insn, operands,NULL);"
+  [(set_attr "length" "6,6")
+   (set_attr "cc" "clobber")])
+
+;; xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0
+;; xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0
+;; xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0
+;; xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0
+;; xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0
+;; xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0 xx<---0
+;; zero extend
+
+(define_insn "zero_extendqihi2"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=rm,rm")
+        (zero_extend:HI (match_operand:QI 1 "general_operand" "0,*rmi")))]
+  ""
+  "* return zeroextendqihi(insn, operands,NULL);"
+  [(set_attr "length" "2,2")
+   (set_attr "cc" "clobber")])
+
+(define_insn "zero_extendhisi2"
+ [(set (match_operand:SI 0 "nonimmediate_operand" "=rm,rm")
+   (zero_extend:SI (match_operand:HI 1 "general_operand" "0,*rmi")))]
+""
+"* return zeroextendhisi(insn, operands,NULL);"
+[(set_attr "length" "6,6")
+ (set_attr "cc" "clobber")])
+
+(define_insn "zero_extendsidi2"
+ [(set (match_operand:DI 0 "nonimmediate_operand" "=rm,rm")
+   (zero_extend:DI (match_operand:SI 1 "general_operand" "0,*rmi")))]
+""
+"* return zeroextendsidi(insn, operands,NULL);"
+[(set_attr "length" "6,6")
+ (set_attr "cc" "clobber")])
+
+;; =====================================================================
+;; single bit extract
+;; as soon as all operatoins performed on io registers
+;; let use only QImode. 
+
+(define_expand "extv"
+ [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+       (sign_extract:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "") 
+			(match_operand 2 "const_int_operand" "")
+			(match_operand 3 "const_int_operand" "")))]
+""
+"{
+    if(INTVAL(operands[2]) != 1 || INTVAL(operands[3]) <= 0)
+      FAIL;
+    operands[3] = GEN_INT(1<<INTVAL(operands[3]));
+}")
+
+(define_insn "*extv" 
+ [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,r,r,r,m,m,m,m")
+       (sign_extract:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "r,m,r,m,r,m,r,m") 
+			(match_operand 2 "const_int_operand" "i,i,i,i,i,i,i,i")
+			(match_operand 3 "const_int_operand" "P,P,i,i,P,P,i,i")))]
+ ""
+"bit.b\\t%3, %1
+\\tclr.b\\t%0
+\\tadc.b\\t%0"
+  [(set_attr "length" "3,4,4,5,5,6,6,7")
+     (set_attr "cc" "set_czn")])
+
+(define_expand "extzv"
+ [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "")
+       (zero_extract:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "") 
+			(match_operand 2 "const_int_operand" "")
+			(match_operand 3 "const_int_operand" "")))]
+""
+"{
+    if(INTVAL(operands[2]) != 1 || INTVAL(operands[3]) <= 0) 
+      FAIL;
+    operands[3] = GEN_INT(1<<INTVAL(operands[3]));
+}")
+
+(define_insn "*extzv" 
+ [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,r,r,r,m,m,m,m")
+       (zero_extract:QI (match_operand:QI 1 "nonimmediate_operand_msp430" "r,m,r,m,r,m,r,m") 
+			(match_operand 2 "const_int_operand" "i,i,i,i,i,i,i,i")
+			(match_operand 3 "const_int_operand" "P,P,i,i,P,P,i,i")))]
+ ""
+"bit.b\\t%3, %1
+\\tclr.b\\t%0
+\\tadc.b\\t%0"
+  [(set_attr "length" "3,4,4,5,5,6,6,7")
+     (set_attr "cc" "set_czn")])
+;;=======================================================================
+;;  various BRANCH insns...
+;;
+;;
+
+;; return insn
+(define_insn "return"
+  [(return)]
+  "reload_completed && msp430_empty_epilogue()"
+  "* return msp430_emit_return(insn, operands, NULL);"
+  [(set_attr "length" "1")
+   (set_attr "cc" "clobber")]
+
+)
+
+
+;; Unconditional jump instruction.
+(define_insn "jump"
+  [(set (pc) (label_ref (match_operand 0 "" "")))]
+  ""
+  "*
+{
+  int dist = msp430_jump_dist(operands[0],insn);
+  if (dist<500 && dist>-500)
+    return \"jmp	%0\";
+  return \"br	#%0\"; 
+}"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+
+; indirect jump
+(define_expand "indirect_jump"
+  [(set (pc) (match_operand:HI 0 "nonimmediate_operand" ""))]
+  ""
+  "")
+
+(define_insn "*indirect_jump_idx"
+  [(set (pc) (match_operand:HI 0 "memory_operand" "m"))]
+  "indexed_location(operands[0])"
+  "br	@%E0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+(define_insn "*indirect_jump_mem"
+  [(set (pc) (match_operand:HI 0 "memory_operand" "m"))]
+  "!indexed_location(operands[0])"
+  "br	%0"
+  [(set_attr "length" "2")
+   (set_attr "cc" "none")])
+
+
+(define_insn "*indirect_jump_reg"
+  [(set (pc) (match_operand:HI 0 "register_operand" "r"))]
+  ""
+  "br	%0"
+  [(set_attr "length" "1")
+   (set_attr "cc" "none")])
+
+
+;;=======================================================================
+;;
+;;    CASE
+;;
+
+/*
+(define_expand "casesi"
+  [(set (match_dup 6)  
+        (minus:HI (subreg:HI (match_operand:SI 0 "register_operand" "") 0)
+                  (match_operand:HI 1 "register_operand" "")))
+   (parallel [(set (cc0)
+                   (compare (match_dup 6)
+                            (match_operand:HI 2 "register_operand" "")))])
+   (set (pc)
+        (if_then_else (gtu (cc0)
+                           (const_int 0))
+                      (label_ref (match_operand 4 "" ""))
+                      (pc)))
+   (set (match_dup 6)
+        (plus:HI (match_dup 6) (label_ref (match_operand:HI 3 "" ""))))
+
+   (parallel [(set (pc) (unspec:HI [(match_dup 6)] 1))
+              (use (label_ref (match_dup 3)))
+              (clobber (match_dup 6))])]
+  ""
+  " 
+{   
+  operands[6] = gen_reg_rtx (HImode);
+}")
+
+*/ 
+
+;; Table helper
+(define_insn "tablejump"
+  [(set (pc) (match_operand:HI 0 "general_operand" "rRP,i,m"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "br	%0	;	%1"
+ [(set_attr "length" "1,2,2")   
+   (set_attr "cc" "none")])
+
+
+;; =============================================================
+;; match De Morgan's law
+(define_insn "nandqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand_msp430" "=r,m,m,r")
+             (and:QI (not:QI (match_operand:QI 1 "general_operand_msp430" "rRP,mi,rRP,mi"))
+	                     (match_operand:QI 2 "nonimmediate_operand_msp430" "0,0,0,0")))]
+""
+"bic.b	%1, %0"
+[(set_attr "length" "1,3,2,2")
+  (set_attr "cc" "none")])
+
+(define_insn "nandhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=r,m,m,r")
+             (and:HI (not:HI (match_operand:HI 1 "general_operand_msp430" "rRP,mi,rRP,mi"))
+	                     (match_operand:HI 2 "nonimmediate_operand_msp430" "0,0,0,0")))]
+""
+"bic	%1, %0"
+[(set_attr "length" "1,3,2,2")
+  (set_attr "cc" "none")])
+
+(define_insn "nandsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand_msp430" "=r,m,m,r,r,m")
+            (and:SI (not:SI (match_operand:SI 1 "general_operand_msp430" "rP,mi,rP,mi,R,R"))
+	                    (match_operand:SI 2 "nonimmediate_operand_msp430" "0,0,0,0,0,0")))]
+""
+"bic    %A1, %A0
+\\tbic	%B1, %B0"
+[(set_attr "length" "2,6,4,4,3,5")
+  (set_attr "cc" "none")])
+
+;; =============================================================
+;;  MISC
+(define_insn "swpb"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=rR,m")
+    (unspec:HI [(match_operand:HI 1 "nonimmediate_operand_msp430" "0,0")] 4))]
+""
+"swpb	%0"
+  [(set_attr "length" "1,2")
+    (set_attr "cc" "clobber,clobber")])
+
+
+
+
+;; =============================================================
+;; PEEPHOLES
+
+;; a &= ~b;
+
+(define_insn "*bit_clear"
+ [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=r,m,m,r") 
+       (unspec_volatile:HI [(match_operand:HI 1 "general_operand_msp430" "rRP,mi,rRP,mi")] 40))]
+""
+"bic	%1, %0"
+  [(set_attr "length" "1,3,2,2")
+     (set_attr "cc" "none")])
+
+
+;; these two for:
+;; (ulong) x = (ulong) func() << 16;
+;; x |= func();
+;; func() is uint
+;;
+
+
+;; do not check for zeros here, cause this insn already issued.
+(define_peephole2
+   [(set (match_operand:SI 1 "register_operand" "")
+         (sign_extend:SI (match_operand:HI 0 "register_operand" "")))
+    (set (match_dup 1) (ashift:SI (match_dup 1) (const_int 16)))]
+""
+  [(set (subreg:HI (match_dup 1) 2) (match_dup 0))]
+"")
+
+(define_peephole2
+   [(set (match_operand:SI 1 "register_operand" "")
+         (zero_extend:SI (match_operand:HI 0 "register_operand" "")))
+    (set (match_dup 1) (ashift:SI (match_dup 1) (const_int 16)))]
+""
+  [(set (subreg:HI (match_dup 1) 2) (match_dup 0))]
+"")
+
+(define_peephole2
+   [(set (match_operand:SI 0 "register_operand" "")
+         (zero_extend:SI (match_operand:HI 1 "register_operand" "")))
+    (set (match_operand:SI 2 "register_operand" "")
+         (ior:SI (match_dup 2) (match_dup 0)))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (subreg:HI (match_dup 2) 0) 
+        (ior:HI (subreg:HI (match_dup 2) 0) (match_dup 1)))]
+"")
+
+(define_peephole2
+   [(set (match_operand:HI 0 "register_operand" "")  
+         (match_operand:HI 1 "general_operand_msp430" ""))
+    (set (match_operand:SI 2 "register_operand" "")
+         (zero_extend:SI (match_dup 0)))
+    (set (match_operand:SI 3 "register_operand" "") 
+         (ior:SI (match_dup 3) (match_dup 2)))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (subreg:HI (match_dup 3) 0) 
+        (ior:HI (subreg:HI (match_dup 3) 0) (match_dup 1)))]
+"")
+
+
+;; (ulong) x = (ulong) f >> 16;
+;;
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "register_operand" "")) 
+   (set (match_dup 0) 
+	(lshiftrt:SI (match_dup 0) 
+		     (const_int 16)))]
+""
+[(set (subreg:HI (match_dup 0) 0) (subreg:HI (match_dup 1) 2))
+ (set (subreg:HI (match_dup 0) 2) (const_int 0))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "register_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(ior:SI (match_dup 2) (match_dup 0)))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (ior:SI (match_dup 2) 
+		              (match_dup 1)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(zero_extend:SI (match_operand:HI 1 "general_operand" "")))
+   (set (match_dup 0) 
+	(ashift:SI (match_dup 0) (const_int 16)))]
+""
+  [(set (subreg:HI (match_dup 0) 2) (match_dup 1))]
+"")
+
+
+;; shift right & set
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "register_operand" ""))
+   (set (match_operand:HI 2 "register_operand" "")
+	(match_dup 0))
+   (set (match_dup 2) 
+	(and:HI (match_dup 2) 
+		(match_operand 3 "const_int_operand" "")))
+   (set (match_dup 2) 
+	(lshiftrt:HI (match_dup 2) 
+		     (match_operand 4 "const_int_operand" ""))) 
+   (set (match_dup 1) (match_dup 2))]
+"dead_or_set_in_peep(4,insn, operands[2])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 1)  
+	(and:HI (match_dup 1)  
+		(match_dup 3))) 
+   (set (match_dup 1) 
+	(lshiftrt:HI (match_dup 1) 
+		     (match_dup 4)))] 
+"")
+
+;; shift left and set
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "register_operand" ""))
+   (set (match_operand:HI 2 "register_operand" "")
+	(match_dup 0))
+   (set (match_dup 2) 
+	(and:HI (match_dup 2) 
+		(match_operand 3 "const_int_operand" "")))
+   (set (match_dup 2) 
+	(ashift:HI (match_dup 2) 
+		   (match_operand 4 "const_int_operand" ""))) 
+   (set (match_dup 1) (match_dup 2))]
+"dead_or_set_in_peep(4,insn, operands[2])"
+  [(set (match_dup 0) (match_dup 1))
+   (set (match_dup 1)  
+	(and:HI (match_dup 1)  
+		(match_dup 3))) 
+   (set (match_dup 1) 
+	(ashift:HI (match_dup 1) 
+		   (match_dup 4)))] 
+"")
+
+
+;;
+;; these for some shifts and stuff.
+;; every peephole saves up to 4 bytes.
+;;
+
+(define_insn "*addc_reg"
+  [(set (match_operand:HI 0 "register_operand" "=r,r") 
+	(unspec:HI [(match_operand:HI 1 "register_operand" "%0,0") 
+		    (match_operand:HI 2 "general_operand_msp430" "rP,mi")] 0))]
+""
+"addc	%2, %0"
+[(set_attr "length" "1,2")
+   (set_attr "cc" "clobber,clobber")])
+
+
+(define_insn "*addc_any"
+  [(set (match_operand:HI 0 "nonimmediate_operand_msp430" "=m,m") 
+	(unspec:HI [(match_operand:HI 1 "nonimmediate_operand_msp430" "%0,0") 
+		    (match_operand:HI 2 "general_operand_msp430" "rP,mi")] 5))]
+""
+"addc	%2, %0"
+[(set_attr "length" "2,3")
+   (set_attr "cc" "clobber,clobber")])
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "general_operand_msp430" ""))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(zero_extend:SI (match_dup 0)))
+   (set (match_operand:SI 3 "register_operand" "") 
+	(plus:SI (match_dup 3) (match_dup 2)))]
+"dead_or_set_in_peep(2,insn, operands[2])"
+  [(set (subreg:HI (match_dup 3) 0) 
+	(plus:HI (subreg:HI (match_dup 3) 0) 
+		 (match_dup 1)))
+   (set (subreg:HI (match_dup 3) 2) 
+	(unspec:HI [(subreg:HI (match_dup 3) 2) (const_int 0)] 0))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "general_operand_msp430" ""))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(zero_extend:SI (match_dup 0)))
+   (set (match_operand:SI 3 "nonimmediate_operand_msp430" "") 
+	(plus:SI (match_dup 3) (match_dup 2)))]
+"dead_or_set_in_peep(2,insn, operands[2])"
+  [(set (subreg:HI (match_dup 3) 0) 
+	(plus:HI (subreg:HI (match_dup 3) 0) 
+		 (match_dup 1)))
+   (set (subreg:HI (match_dup 3) 2) 
+	(unspec:HI [(subreg:HI (match_dup 3) 2) (const_int 0)] 5))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "general_operand_msp430" ""))
+   (set (match_operand:SI 2 "nonimmediate_operand_msp430" "")
+        (zero_extend:SI (match_dup 0)))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (subreg:HI (match_dup 2) 0) (match_dup 1))
+   (set (subreg:HI (match_dup 2) 2) (const_int 0))]
+"")
+
+;;
+;; these are for redudant moves.
+;;
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(ior:SI (match_dup 2) (match_dup 0)))
+   (set (match_dup 1) (match_dup 2))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 1) (ior:SI (match_dup 1) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(ior:SI (match_dup 0) 
+		(match_operand:SI 1 "register_operand" "")))
+   (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 1) (ior:SI (match_dup 1) (match_dup 0)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "register_operand" ""))
+   (set (match_dup 0) 
+	(not:HI (match_dup 0)))
+   (set (match_operand:HI 2 "register_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && dead_or_set_in_peep(0,insn, operands[1])"
+  [(set (match_dup 1) (not:HI (match_dup 1)))
+   (set (match_dup 2) (match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "register_operand" ""))
+   (set (match_dup 0) 
+	(not:SI (match_dup 0)))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && dead_or_set_in_peep(0,insn, operands[1])"
+  [(set (match_dup 1) (not:SI (match_dup 1)))
+   (set (match_dup 2) (match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SF 0 "register_operand" "")
+	(match_operand:SF 1 "general_operand_msp430" ""))
+   (set (match_operand:SF 2 "nonimmediate_operand_msp430" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (match_dup 1))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "general_operand_msp430" ""))
+   (set (match_operand:SI 2 "nonimmediate_operand_msp430" "") 
+	(match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (match_dup 1))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "general_operand_msp430" ""))
+   (set (match_operand:HI 2 "nonimmediate_operand_msp430" "")
+        (match_dup 0))]
+"dead_or_set_in_peep(1,insn, operands[0])"
+  [(set (match_dup 2) (match_dup 1))]
+"")
+
+
+
+;; =========================================================================
+;;  This one for bit tests like:
+;;	volatile long a;
+;;	while(a&CONST_HALFNIBBLE) ;
+
+(define_insn "*bittest_lo"
+  [(set (cc0) 
+	(unspec:SI [(match_operand:SI 0 "nonimmediate_operand_msp430" "r,r,m,m") 
+		    (match_operand:SI 1 "general_operand_msp430" "rPR,mi,rPR,mi")] 1))]
+""
+"bit	%A1,%A0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+(define_insn "*bittest_hi"
+  [(set (cc0) 
+	(unspec:SI [(match_operand:SI 0 "nonimmediate_operand_msp430" "r,r,m,m") 
+		    (match_operand:SI 1 "general_operand_msp430" "rPR,mi,rPR,mi")] 2))]
+""
+"bit	%B1,%B0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) 
+       (if_then_else (match_operator:SI 3 "equality_operator"
+		      [(match_dup 0) (const_int 0)]) 
+       (label_ref (match_operand 4 "" ""))
+       (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 0"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] 1))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) (if_then_else (match_operator:SI 3 "equality_operator"
+			   [(match_dup 0) (const_int 0)])
+	    (label_ref (match_operand 4 "" ""))
+	    (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 1"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] 2))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) 
+       (if_then_else (match_operator:HI 3 "equality_operator"
+		      [(match_operand:HI 4 "register_operand" "") (const_int 0)]) 
+       (label_ref (match_operand 5 "" ""))
+       (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 1
+	&& REGNO(operands[4]) == REGNO(operands[0])+1"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] 1))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 5))
+	     (pc)))]
+"")
+
+(define_peephole2
+ [(set (match_operand:SI 0 "register_operand" "")
+       (match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+  (set (match_dup 0) (and:SI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) 
+       (if_then_else (match_operator:HI 3 "equality_operator"
+		      [(match_operand:HI 4 "register_operand" "") (const_int 0)]) 
+       (label_ref (match_operand 5 "" ""))
+       (pc)))]
+"(halfnibble_integer(operands[2], VOIDmode) 
+   || halfnibble_constant(operands[2], VOIDmode))
+        && dead_or_set_in_peep(2,insn, operands[0])
+	&& which_nibble(INTVAL(operands[2])) == 0
+	&& REGNO(operands[4]) == REGNO(operands[0])"
+  [(set (cc0) 
+	(unspec:SI [(match_dup 1) (match_dup 2)] 1))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 5))
+	     (pc)))]
+"")
+
+;;
+;;  The same for HI mode: while(smts&0xXXXX) ;
+;;
+(define_insn "*bittest"
+  [(set (cc0)
+        (unspec:HI [(match_operand:HI 0 "general_operand_msp430" "r,r,m,m")
+                    (match_operand:HI 1 "general_operand_msp430" "rPR,mi,rPR,mi")] 6))]
+""
+"bit	%1,%0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+
+(define_peephole2
+ [(set (match_operand:HI 0 "register_operand" "")
+       (match_operand:HI 1 "nonimmediate_operand_msp430" ""))
+  (set (match_dup 0) (and:HI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) (if_then_else (match_operator:HI 3 "equality_operator"
+			   [(match_dup 0) (const_int 0)])
+	    (label_ref (match_operand 4 "" "")) 
+	    (pc)))]
+"dead_or_set_in_peep(2,insn, operands[0]) "
+  [(set (cc0) 
+	(unspec:HI [(match_dup 1) (match_dup 2)] 6))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+
+;; The same for QI mode
+
+(define_insn "*bittest_b"
+  [(set (cc0)
+        (unspec:QI [(match_operand:QI 0 "general_operand_msp430" "r,r,m,m")
+                    (match_operand:QI 1 "general_operand_msp430" "rPR,mi,rPR,mi")] 7))]
+""
+"bit.b	%1,%0"
+[(set_attr "length" "1,2,2,3")
+   (set_attr "cc" "compare,compare,compare,compare")])
+
+
+(define_peephole2
+ [(set (match_operand:QI 0 "register_operand" "")
+       (match_operand:QI 1 "nonimmediate_operand_msp430" ""))
+  (set (match_dup 0) (and:QI (match_dup 0) 
+                             (match_operand 2 "const_int_operand" "")))
+  (set (pc) (if_then_else (match_operator:QI 3 "equality_operator"
+			   [(match_dup 0) (const_int 0)])
+	    (label_ref (match_operand 4 "" "")) 
+	    (pc)))]
+"dead_or_set_in_peep(2,insn, operands[0]) "
+  [(set (cc0) 
+	(unspec:QI [(match_dup 1) (match_dup 2)] 7))
+   (set (pc) (if_then_else (match_op_dup 3
+			    [(cc0) (const_int 0)])
+	     (label_ref (match_dup 4))
+	     (pc)))]
+"")
+
+
+
+;;===========================================================================
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+        (match_operand:QI 1 "general_operand_msp430" ""))
+   (set (match_dup 0)
+	(minus:QI (match_dup 0) 
+		  (match_operand:QI 2 "general_operand_msp430" "")))
+   (set (match_operand:QI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (minus:QI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+        (match_operand:QI 1 "general_operand_msp430" ""))
+   (set (match_dup 0)
+	(plus:QI (match_dup 0) 
+		 (match_operand:QI 2 "general_operand_msp430" "")))
+   (set (match_operand:QI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (plus:QI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "general_operand_msp430" ""))
+   (set (match_dup 0)
+	(minus:HI (match_dup 0) 
+		  (match_operand:HI 2 "general_operand_msp430" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (minus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+        (match_operand:HI 1 "general_operand_msp430" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0) 
+		 (match_operand:HI 2 "general_operand_msp430" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (plus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "general_operand_msp430" ""))
+   (set (match_dup 0)
+	(minus:SI (match_dup 0) 
+		  (match_operand:SI 2 "general_operand_msp430" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (minus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+        (match_operand:SI 1 "general_operand_msp430" ""))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0) 
+		 (match_operand:SI 2 "general_operand_msp430" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+   	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0]) && 0"
+  [(set (match_dup 3) (match_dup 1))
+   (set (match_dup 3) (plus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+
+;; =============================================================
+;; 
+;;  adjust frame pointer index
+;;
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "general_operand_msp430" "")))
+   (set (match_dup 0) 
+	(plus:HI (match_dup 0) (match_operand:HI 2 "general_operand_msp430" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:HI (match_dup 1)))
+   (set (match_dup 3) (plus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(sign_extend:SI (match_operand:HI 1 "general_operand_msp430" "")))
+   (set (match_dup 0) 
+	(plus:SI (match_dup 0) (match_operand:SI 2 "general_operand_msp430" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:SI (match_dup 1)))
+   (set (match_dup 3) (plus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "general_operand_msp430" "")))
+   (set (match_dup 0) 
+	(minus:HI (match_dup 0) (match_operand:HI 2 "general_operand_msp430" "")))
+   (set (match_operand:HI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:HI (match_dup 1)))
+   (set (match_dup 3) (minus:HI (match_dup 3) (match_dup 2)))]
+"")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(sign_extend:SI (match_operand:HI 1 "general_operand_msp430" "")))
+   (set (match_dup 0) 
+	(minus:SI (match_dup 0) (match_operand:SI 2 "general_operand_msp430" "")))
+   (set (match_operand:SI 3 "register_operand" "")
+	(match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 3) (sign_extend:SI (match_dup 1)))
+   (set (match_dup 3) (minus:SI (match_dup 3) (match_dup 2)))]
+"")
+
+;; =============================================================
+;; mov & 'and'
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(match_operand:HI 1 "nonimmediate_operand_msp430" ""))
+   (set (match_dup 0) 
+	(and:HI (match_dup 0) 
+		(match_operand:HI 2 "general_operand_msp430" ""))) 
+   (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 1) 
+	(and:HI (match_dup 1) (match_dup 2)))]
+"")
+
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "") 
+	(match_operand:SI 1 "nonimmediate_operand_msp430" ""))
+   (set (match_dup 0) 
+	(and:SI (match_dup 0) 
+		(match_operand:SI 2 "general_operand_msp430" ""))) 
+   (set (match_dup 1) (match_dup 0))]
+"dead_or_set_in_peep(2,insn, operands[0])"
+  [(set (match_dup 1) 
+	(and:SI (match_dup 1) (match_dup 2)))]
+"")
+
+
+
+;; =============================================================
+
+(define_peephole 
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "register_operand" ""))) 
+   (set (match_operand:HI 2 "register_operand" "") 
+	(plus:HI (match_dup 2) (match_dup 0)))]
+"dead_or_set_in_peep(1,insn,operands[0])" 
+"sxt	%1
+	add	%1, %2"
+[(set_attr "length" "3")
+   (set_attr "cc" "clobber")])
+
+
+(define_peephole 
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(sign_extend:HI (match_operand:QI 1 "nonimmediate_operand_msp430" ""))) 
+   (set (match_operand:HI 2 "register_operand" "") (match_dup 0))]
+"dead_or_set_in_peep(1,insn,operands[0])" 
+"mov.b	%1, %2
+	sxt	%2"
+[(set_attr "length" "2")
+   (set_attr "cc" "clobber")])
+
+;; ============================================================= 
+;; a = (uint16_t)( (uint8_t)SFR ) << 8;
+;; (inderect_jump + 50)
+(define_peephole 
+  [(set (match_operand:QI 0 "register_operand" "") 
+	(match_operand:QI 1 "memory_operand_msp430" "m"))
+   (set (match_operand:HI 2 "register_operand" "")
+	(ashift:HI (match_dup 2) (const_int 8)))]
+  "REGNO(operands[0]) == REGNO(operands[2])"
+"mov.b	%1, %0
+	swpb	%2"
+[(set_attr "length" "3")
+   (set_attr "cc" "clobber")])
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "") 
+	(ior:HI (match_dup 0) 
+		(match_operand:HI 1 "register_operand" "")))
+   (set (match_operand:SI 2 "register_operand" "") 
+	(match_operand:SI 3 "register_operand" ""))]
+"(REGNO(operands[0]) == REGNO(operands[2])
+  && REGNO(operands[3])+1 == REGNO(operands[0]))"
+  [(set (match_dup 1) 
+	(ior:HI (match_dup 1) 
+		(match_dup 0)))
+   (set (subreg:HI (match_dup 2) 0)
+	(subreg:HI (match_dup 3) 0))]
+"")
+
+
diff -Nru gcc-3.3-orig/gcc/config/msp430/msp430-protos.h gcc-3.3/gcc/config/msp430/msp430-protos.h
--- gcc-3.3-orig/gcc/config/msp430/msp430-protos.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/msp430-protos.h	2003-01-14 11:55:05.000000000 +0100
@@ -0,0 +1,297 @@
+/* Prototypes for exported functions defined in msp430.c
+   
+   Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+   Contributed by Dmitry Diky <diwil@mail.ru>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+
+extern void   bootloader_section PARAMS ((void));
+extern void   infomem_section PARAMS ((void));
+
+extern void   asm_file_start            PARAMS ((FILE *file));
+extern void   asm_file_end              PARAMS ((FILE *file));
+extern void   msp430_init_once          PARAMS ((void));
+extern void   msp430_override_options   PARAMS ((void));
+extern void   gas_output_limited_string PARAMS ((FILE *file, const char *str));
+extern void   gas_output_ascii          PARAMS ((FILE *file, const char *str,
+							 size_t length));
+extern void   order_regs_for_local_alloc PARAMS ((void));
+extern void   msp430_trampoline_template PARAMS ((FILE *fd));
+
+extern int frame_pointer_required_p PARAMS ((void));
+extern int msp430_empty_epilogue PARAMS ((void));
+
+int msp430_regno_ok_for_base_p PARAMS ((int));
+
+#ifdef HAVE_MACHINE_MODES
+extern int    msp430_hard_regno_mode_ok PARAMS ((int regno,
+					     enum machine_mode mode));
+#endif
+
+extern int initial_elimination_offset PARAMS ((int, int));
+
+
+
+#ifdef TREE_CODE
+extern void   asm_output_external          PARAMS ((FILE *file, tree decl,
+						   char *name));
+extern void   unique_section               PARAMS ((tree decl, int reloc));
+extern void   encode_section_info          PARAMS ((tree decl));
+extern void   asm_output_section_name      PARAMS ((FILE *file, tree decl,
+						   const char *name,
+						   int reloc));
+extern int    valid_machine_type_attribute PARAMS ((tree type, tree attributes,
+						   tree identifier,
+						   tree args));
+extern int    valid_machine_decl_attribute PARAMS ((tree decl, tree attributes,
+						   tree attr, tree args));
+extern void asm_declare_function_name PARAMS ((FILE *, const char *, tree));
+unsigned int msp430_section_type_flags PARAMS (( tree DECL, const char *NAME, int RELOC));
+
+
+#ifdef RTX_CODE /* inside TREE_CODE */
+extern rtx    msp430_function_value          PARAMS ((tree type, tree func));
+extern void   init_cumulative_args           PARAMS ((CUMULATIVE_ARGS *cum,
+						   tree fntype, rtx libname,
+						   int indirect));
+extern rtx    function_arg         PARAMS ((CUMULATIVE_ARGS *cum,
+					   enum machine_mode mode,
+					   tree type, int named));
+extern void   init_cumulative_incoming_args           PARAMS ((CUMULATIVE_ARGS *cum,
+						   tree fntype, rtx libname));
+extern rtx    function_incoming_arg         PARAMS ((CUMULATIVE_ARGS *cum,
+					   enum machine_mode mode,
+					   tree type, int named));
+
+
+
+#endif /* RTX_CODE inside TREE_CODE */
+
+#ifdef HAVE_MACHINE_MODES /* inside TREE_CODE */
+extern void   function_arg_advance PARAMS ((CUMULATIVE_ARGS *cum,
+					   enum machine_mode mode, tree type,
+					   int named));
+#endif /* HAVE_MACHINE_MODES inside TREE_CODE*/
+#endif /* TREE_CODE */
+
+#ifdef RTX_CODE
+
+
+extern enum rtx_code msp430_canonicalize_comparison PARAMS ((enum rtx_code,rtx *,rtx *));
+
+
+extern void msp430_emit_cbranch PARAMS ((enum rtx_code, rtx));
+extern void msp430_emit_cset PARAMS ((enum rtx_code, rtx));
+
+extern int dead_or_set_in_peep PARAMS ((int, rtx, rtx));
+extern void msp430_initialize_trampoline PARAMS ((rtx,rtx,rtx));   
+
+
+extern enum reg_class msp430_reg_class_from_letter PARAMS ((int));
+extern enum reg_class preferred_reload_class PARAMS ((rtx,enum reg_class));
+enum reg_class msp430_regno_reg_class PARAMS ((int));
+
+extern RTX_CODE followed_compare_condition PARAMS ((rtx));
+
+extern const char * msp430_movesi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_movedi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_addsi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_subsi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_andsi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_iorsi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_xorsi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_adddi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_subdi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_anddi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_iordi_code PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_xordi_code PARAMS ((rtx insn, rtx operands[], int *l));
+
+
+extern int zero_shifted PARAMS ((rtx ));
+extern int indexed_location PARAMS ((rtx ));
+
+
+extern int regsi_ok_safe PARAMS ((rtx operands[]));
+extern int regsi_ok_clobber PARAMS ((rtx operands[]));
+extern int regdi_ok_safe PARAMS ((rtx operands[]));
+extern int regdi_ok_clobber PARAMS ((rtx operands[]));
+extern int sameoperand PARAMS ((rtx operands[], int));
+
+extern int general_operand_msp430 PARAMS ((rtx, enum machine_mode )); 
+extern int nonimmediate_operand_msp430 PARAMS ((rtx, enum machine_mode ));
+extern int memory_operand_msp430 PARAMS ((rtx, enum machine_mode ));
+extern int halfnibble_constant PARAMS ((rtx, enum machine_mode ));
+extern int halfnibble_integer PARAMS ((rtx, enum machine_mode ));
+extern int halfnibble_constant_shift PARAMS ((rtx, enum machine_mode ));
+extern int halfnibble_integer_shift PARAMS ((rtx, enum machine_mode ));
+extern int which_nibble PARAMS ((int));
+extern int which_nibble_shift PARAMS ((int));
+
+
+extern void   asm_output_external_libcall PARAMS ((FILE *file, rtx symref));
+extern int    legitimate_address_p    PARAMS ((enum machine_mode mode, rtx x,
+					int strict));
+extern int    compare_diff_p  PARAMS ((rtx insn));
+
+extern int    emit_indexed_arith PARAMS ((rtx insn, rtx operands[], int, const char *, int));
+
+extern const char * msp430_emit_abssi    PARAMS ((rtx insn, rtx operands[], int *l));
+extern const char * msp430_emit_absdi    PARAMS ((rtx insn, rtx operands[], int *l));
+
+extern const char * msp430_emit_indexed_add2 PARAMS ((rtx insn, rtx op[], int *l));
+extern const char * msp430_emit_indexed_add4 PARAMS ((rtx insn, rtx op[], int *l));
+
+extern const char * msp430_emit_indexed_sub2 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_sub4 PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * msp430_emit_indexed_and2 PARAMS ((rtx insn, rtx op[], int *l));
+extern const char * msp430_emit_indexed_and4 PARAMS ((rtx insn, rtx op[], int *l));
+extern const char * msp430_emit_immediate_and2 PARAMS ((rtx insn, rtx op[], int *l));
+extern const char * msp430_emit_immediate_and4 PARAMS ((rtx insn, rtx op[], int *l));
+
+extern const char * msp430_emit_indexed_ior2 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_ior4 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_immediate_ior2 PARAMS ((rtx insn, rtx op[], int *l));
+extern const char * msp430_emit_immediate_ior4 PARAMS ((rtx insn, rtx op[], int *l));
+
+
+extern int msp430_emit_indexed_mov PARAMS ((rtx insn, rtx operands[], int len, const char *));       
+extern const char * movstrsi_insn PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * clrstrsi_insn PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * movstrhi_insn PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * clrstrhi_insn PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_mov2 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_mov4 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * movsisf_regmode PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * movdidf_regmode PARAMS ((rtx insn, rtx operands[], int *len));
+
+
+extern int is_shift_better_in_reg PARAMS ((rtx operands[]));
+extern int msp430_emit_shift_cnt PARAMS ((int (*funct)(rtx, int, int), const char *, rtx insn, rtx operands[], int *len, int));
+extern const char * msp430_emit_ashlqi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashlhi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashlsi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashldi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashrqi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashrhi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashrsi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_ashrdi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_lshrqi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_lshrhi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_lshrsi3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_lshrdi3 PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * signextendqihi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * signextendqisi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * signextendqidi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * signextendhisi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * signextendhidi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * signextendsidi PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * msp430_emit_indexed_sub2 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_sub4 PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * msp430_emit_indexed_xor2 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_xor4 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_xor2_3 PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_emit_indexed_xor4_3 PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * zeroextendqihi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * zeroextendqisi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * zeroextendqidi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * zeroextendhisi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * zeroextendhidi PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * zeroextendsidi PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * msp430_emit_blt0si PARAMS ((rtx operands[], int len));
+extern const char * msp430_emit_beq PARAMS ((rtx operands[], int len));
+extern const char * msp430_emit_bne PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_bgt PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_bgtu PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_blt PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_bltu PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_bge PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_bgeu PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_ble PARAMS ((rtx operands[], int len));          
+extern const char * msp430_emit_bleu PARAMS ((rtx operands[], int len));          
+
+extern const char * msp430_pushsisf PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_pushdi   PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_pushhi   PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char * msp430_pushqi   PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern const char * msp430_emit_return PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char *msp430_cbranch PARAMS ((rtx insn, rtx operands[], int *len));
+extern const char *msp430_cset PARAMS ((rtx insn, rtx operands[], int *len));
+
+extern void   notice_update_cc       PARAMS ((rtx body, rtx insn));
+extern int    msp430_peep2_scratch_safe PARAMS ((rtx reg_rtx));
+extern int    test_hard_reg_class    PARAMS ((enum reg_class class, rtx x));
+extern void   machine_dependent_reorg PARAMS ((rtx first_insn));
+extern void msp430_output_addr_vec_elt PARAMS ((FILE *stream, int value));
+extern void   final_prescan_insn     PARAMS ((rtx insn, rtx *operand,
+							int num_operands));
+extern int    adjust_insn_length     PARAMS ((rtx insn, int len));
+
+
+extern int    msp430_address_cost    PARAMS ((rtx x));
+extern int    extra_constraint       PARAMS ((rtx x, int c));
+extern rtx    legitimize_address     PARAMS ((rtx x, rtx oldx,
+					     enum machine_mode mode));
+extern rtx    msp430_libcall_value   PARAMS ((enum machine_mode mode));
+extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,
+					     RTX_CODE outer_code));
+extern void   asm_output_char        PARAMS ((FILE *file, rtx value));
+extern void   asm_output_short       PARAMS ((FILE *file, rtx value));
+extern void   asm_output_byte        PARAMS ((FILE *file, int value));
+
+extern void   print_operand          PARAMS ((FILE *file, rtx x, int code));
+extern void   print_operand_address  PARAMS ((FILE *file, rtx addr));
+extern int    reg_unused_after       PARAMS ((rtx insn, rtx reg));
+extern int    msp430_jump_dist       PARAMS ((rtx x, rtx insn));
+extern int    call_insn_operand      PARAMS ((rtx op, enum machine_mode mode));
+extern int    msp430_branch_mode     PARAMS ((rtx x, rtx insn));
+
+extern int 	msp430_easy_mul PARAMS ((rtx [],int));
+extern int	msp430_mul3_guard	PARAMS ((rtx [], int ));
+extern int      msp430_umul3_guard       PARAMS ((rtx [], int ));
+extern int	msp430_mulhisi_guard PARAMS ((rtx [] ));
+extern int	msp430_umulhisi_guard	PARAMS ((rtx [] ));
+extern int	msp430_ashlhi3 		PARAMS ((rtx [] ));
+extern int      msp430_ashlsi3          PARAMS ((rtx [] ));
+extern int      msp430_ashrhi3          PARAMS ((rtx [] ));
+extern int      msp430_ashrsi3          PARAMS ((rtx [] ));
+extern int      msp430_lshrhi3          PARAMS ((rtx [] ));
+extern int      msp430_lshrsi3          PARAMS ((rtx [] ));
+
+
+#endif /* RTX_CODE */
+
+#ifdef HAVE_MACHINE_MODES
+extern int    class_max_nregs        PARAMS ((enum reg_class class,
+					     enum machine_mode mode));
+#endif /* HAVE_MACHINE_MODES */
+
+#ifdef REAL_VALUE_TYPE
+
+extern void   asm_output_float       PARAMS ((FILE *file, REAL_VALUE_TYPE n));
+
+#endif
+
+
diff -Nru gcc-3.3-orig/gcc/config/msp430/t-msp430 gcc-3.3/gcc/config/msp430/t-msp430
--- gcc-3.3-orig/gcc/config/msp430/t-msp430	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/t-msp430	2006-01-30 09:44:49.000000000 +0100
@@ -0,0 +1,96 @@
+# Specific names for MSP430 tools
+AR_FOR_TARGET = msp430-ar
+RANLIB_FOR_TARGET = msp430-ranlib
+NM_FOR_TARGET = msp430-nm
+
+#CROSS_LIBGCC1 = libgcc1-asm.a
+LIB1ASMSRC = msp430/libgcc.S
+LIB1ASMFUNCS = _cmpdi2 \
+	_cmpsf2 \
+	__stop_progExec__ \
+	_mulqi3 \
+	_mulhi3 \
+	_mulsi3 \
+	_umulqihi3 \
+	_umulhisi3 \
+	_mulqihi3 \
+	_mulhisi3 \
+	_udivmodqi4 \
+	_divmodqi4 \
+	_udivmodhi4 \
+	_divmodhi4 \
+	_udivmodsi4 \
+	_divmodsi4 \
+	_reset_vector__ \
+	__prologue_saver \
+	__epilogue_restorer \
+	__epilogue_restorer_intr \
+	_udivmoddi3_parts \
+	_udivdi3 \
+	_umoddi3 \
+	_divdi3 \
+	_moddi3 \
+	_muldi3	\
+	_ctors \
+	_dtors
+	
+
+# libgcc...
+LIBGCC1_TEST =
+
+# We do not have the DF type.
+# Most of the C functions in libgcc2 use almost all registers,
+TARGET_LIBGCC2_CFLAGS = -DDF=SF -Dinhibit_libc -g
+
+fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/msp430/t-msp430
+	echo '#define FLOAT' > fp-bit.c
+	echo '#define FLOAT_ONLY' >> fp-bit.c
+	echo '#define CMPtype HItype' >> fp-bit.c
+	echo '#define DF SF' >> fp-bit.c
+	echo '#define DI SI' >> fp-bit.c
+	echo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c
+	echo '#define SMALL_MACHINE' >> fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+FPBIT = fp-bit.c
+
+MULTILIB_OPTIONS = mmcu=msp1/mmcu=msp2
+MULTILIB_DIRNAMES = msp1 msp2
+
+MULTILIB_MATCHES = \
+	mmcu?msp1=mmcu?msp430x110  mmcu?msp1=mmcu?msp430x112 \
+	mmcu?msp1=mmcu?msp430x1101 mmcu?msp1=mmcu?msp430x1111 mmcu?msp1=mmcu?msp430x1121 \
+	mmcu?msp1=mmcu?msp430x1122 mmcu?msp1=mmcu?msp430x1132 \
+	mmcu?msp1=mmcu?msp430x122  mmcu?msp1=mmcu?msp430x123 \
+	mmcu?msp1=mmcu?msp430x1222 mmcu?msp1=mmcu?msp430x1232 \
+	mmcu?msp1=mmcu?msp430x133  mmcu?msp1=mmcu?msp430x135 \
+	mmcu?msp1=mmcu?msp430x1331 mmcu?msp1=mmcu?msp430x1351 \
+	mmcu?msp2=mmcu?msp430x147  mmcu?msp2=mmcu?msp430x148  mmcu?msp2=mmcu?msp430x149 \
+	mmcu?msp2=mmcu?msp430x1471 mmcu?msp2=mmcu?msp430x1481 mmcu?msp2=mmcu?msp430x1491 \
+	mmcu?msp1=mmcu?msp430x155  mmcu?msp1=mmcu?msp430x156  mmcu?msp1=mmcu?msp430x157 \
+	mmcu?msp2=mmcu?msp430x167  mmcu?msp2=mmcu?msp430x168  mmcu?msp2=mmcu?msp430x169 \
+	mmcu?msp2=mmcu?msp430x1610 mmcu?msp2=mmcu?msp430x1611 mmcu?msp2=mmcu?msp430x1612 \
+	mmcu?msp1=mmcu?msp430x2101 mmcu?msp1=mmcu?msp430x2111 mmcu?msp1=mmcu?msp430x2121 \
+	mmcu?msp1=mmcu?msp430x2131 \
+	mmcu?msp1=mmcu?msp430x311  mmcu?msp1=mmcu?msp430x312  mmcu?msp1=mmcu?msp430x313 \
+	mmcu?msp1=mmcu?msp430x314  mmcu?msp1=mmcu?msp430x315 \
+	mmcu?msp1=mmcu?msp430x323  mmcu?msp1=mmcu?msp430x325 \
+	mmcu?msp2=mmcu?msp430x336  mmcu?msp2=mmcu?msp430x337 \
+	mmcu?msp1=mmcu?msp430x412  mmcu?msp1=mmcu?msp430x413 \
+	mmcu?msp1=mmcu?msp430x415  mmcu?msp1=mmcu?msp430x417 \
+	mmcu?msp2=mmcu?msp430x423  mmcu?msp2=mmcu?msp430x425  mmcu?msp2=mmcu?msp430x427 \
+	mmcu?msp1=mmcu?msp430x4250 mmcu?msp1=mmcu?msp430x4260 mmcu?msp1=mmcu?msp430x4270 \
+	mmcu?msp2=mmcu?msp430xE423 mmcu?msp2=mmcu?msp430xE425 mmcu?msp2=mmcu?msp430xE427 \
+	mmcu?msp1=mmcu?msp430xW423 mmcu?msp1=mmcu?msp430xW425 mmcu?msp1=mmcu?msp430xW427 \
+	mmcu?msp1=mmcu?msp430xG437 mmcu?msp1=mmcu?msp430xG438 mmcu?msp1=mmcu?msp430xG439 \
+	mmcu?msp1=mmcu?msp430x435  mmcu?msp1=mmcu?msp430x436  mmcu?msp1=mmcu?msp430x437 \
+	mmcu?msp2=mmcu?msp430x447  mmcu?msp2=mmcu?msp430x448  mmcu?msp2=mmcu?msp430x449
+
+MULTILIB_EXCEPTIONS =
+
+LIBGCC = stmp-multilib
+INSTALL_LIBGCC = install-multilib
+
+STMP_FIXINC = 
+
+
diff -Nru gcc-3.3-orig/gcc/config/msp430/xm-msp430.h gcc-3.3/gcc/config/msp430/xm-msp430.h
--- gcc-3.3-orig/gcc/config/msp430/xm-msp430.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-3.3/gcc/config/msp430/xm-msp430.h	2003-01-09 12:01:44.000000000 +0100
@@ -0,0 +1 @@
+#include "tm.h"
diff -Nru gcc-3.3-orig/gcc/config.gcc gcc-3.3/gcc/config.gcc
--- gcc-3.3-orig/gcc/config.gcc	2007-04-03 19:29:09.000000000 +0200
+++ gcc-3.3/gcc/config.gcc	2003-06-03 15:32:26.000000000 +0200
@@ -747,6 +747,8 @@
 	;;
 avr-*-*)
 	;;
+msp430-*-*)
+	;;
 c4x-*-rtems* | tic4x-*-rtems*)
 	xm_defines=POSIX
 	tmake_file="c4x/t-c4x t-rtems"
@@ -2014,6 +2016,8 @@
 	;;
 avr-*-*)
 	;;
+msp430-*-*)
+	;;
 ns32k-*-openbsd*)
 	# Nothing special
 	;;
